{
  "types": [
    {
      "title": "Built-in Type",
      "docs": [
        {
          "name": "simple",
          "desc": [
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "export [method ]<functionName>([[simple ]<paramType>] <paramName>[ = <defaultValue>])\n\n[method ]<functionName>([simple <paramType> ]<paramName>[ = <defaultValue>])\n\n[var/varip ]simple <variableType> <variableName> = <variableValue></variableValue>"
          ],
          "examples": [
            "//@version=6\n//@description A library with custom functions.\nlibrary(\"CustomFunctions\", overlay = true)\n\n//@function         Calculates the length values for a ribbon of four EMAs by multiplying the `baseLength`.\n//@param baseLength The initial EMA length. Requires \"simple int\" because you can't use \"series int\" in `ta.ema()`.\n//@returns          A tuple of length values.\nexport ribbonLengths(simple int baseLength) =>\n    simple int length1 = baseLength\n    simple int length2 = baseLength * 2\n    simple int length3 = baseLength * 3\n    simple int length4 = baseLength * 4\n    [length1, length2, length3, length4]\n\n// Get a tuple of \"simple int\" length values.\n[len1, len2, len3, len4] = ribbonLengths(14)\n\n// Plot four EMAs using the values from the tuple.\nplot(ta.ema(close, len1), \"EMA 1\", color = color.red)\nplot(ta.ema(close, len2), \"EMA 1\", color = color.orange)\nplot(ta.ema(close, len3), \"EMA 1\", color = color.green)\nplot(ta.ema(close, len4), \"EMA 1\", color = color.blue)"
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"can't change simple to series\")\n\n//@variable A variable declared as \"simple float\" with a value of 5.0.\nsimple float myVar = 5.0\n\n// This reassignment causes an error.\n// The `close` variable returns a \"series float\" value. Since `myVar` is restricted to \"simple\" values, it cannot\n// change its qualifier to \"series\".\nmyVar := close\n\nplot(myVar)"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[series](#type_series)",
            "[const](#type_const)"
          ]
        },
        {
          "name": "series",
          "desc": [
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "export [method ]<functionName>([[series ]<paramType>] <paramName>[ = <defaultValue>])\n\n[method ]<functionName>([series <paramType> ]<paramName>[ = <defaultValue>])\n\n[var/varip ]series <variableType> <variableName> = <variableValue>"
          ],
          "examples": [
            "//@version=6\n//@description A library with custom functions.\nlibrary(\"CustomFunctions\", overlay = true)\n\n//@function Finds the highest `source` value over `length` bars, filtered by the `cond` condition.\nexport conditionalHighest(series float source, series bool cond, series int length) =>\n    //@variable The highest `source` value from when the `cond` was `true` over `length` bars.\n    series float result = na\n    // Loop to find the highest value.\n    for i = 0 to length - 1\n        if cond[i]\n            value   = source[i]\n            result := math.max(nz(result, value), value)\n    // Return the `result`.\n    result\n\n//@variable Is `true` once every five bars.\nseries bool condition = bar_index % 5 == 0\n\n//@variable The highest `close` value from every fifth bar over the last 100 bars.\nseries float hiValue = conditionalHighest(close, condition, 100)\n\nplot(hiValue)\nbgcolor(condition ? color.new(color.teal, 80) : na)"
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"series variable not allowed\")\n\n//@variable A variable declared as \"series int\" with a value of 5.\nseries int myVar = 5\n\n// This call causes an error.\n// The `histbase` accepts \"input int/float\". It can't accept the stronger \"series int\" qualified type.\nplot(close, style = plot.style_histogram, histbase = myVar)"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[simple](#type_simple)",
            "[const](#type_const)"
          ]
        },
        {
          "name": "const",
          "desc": [
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "[method ]<functionName>([const <paramType> ]<paramName>[ = <defaultValue>])\n\n[var/varip ]const <variableType> <variableName> = <variableValue>"
          ],
          "examples": [
            "//@version=6\nindicator(\"custom plot title\")\n\n//@function Concatenates two \"const string\" values.\nconcatStrings(const string x, const string y) =>\n    const string result = x + y\n\n//@variable The title of the plot.\nconst string myTitle = concatStrings(\"My \", \"Plot\")\n\nplot(close, myTitle)"
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"can't assign input to const\")\n\n//@variable A variable declared as \"const float\" that attempts to assign the result of `input.float()` as its value.\n//          This declaration causes an error. The \"input float\" qualified type is stronger than \"const float\".\nconst float myVar = input.float(2.0)\n\nplot(myVar)"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[simple](#type_simple)",
            "[series](#type_series)"
          ]
        },
        {
          "name": "int",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"int\")\nint i = 14    // Same as `i = 14`\ni := na\nplot(i)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[varip](#kw_varip)",
            "[float](#type_float)",
            "[bool](#type_bool)",
            "[color](#type_color)",
            "[string](#type_string)"
          ]
        },
        {
          "name": "float",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"float\")\nfloat f = 3.14    // Same as `f = 3.14`\nf := na\nplot(f)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[varip](#kw_varip)",
            "[int](#type_int)",
            "[bool](#type_bool)",
            "[color](#type_color)",
            "[string](#type_string)"
          ]
        },
        {
          "name": "bool",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"bool\")\nbool b = true    // Same as `b = true`\nplot(b ? open : close)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[varip](#kw_varip)",
            "[int](#type_int)",
            "[float](#type_float)",
            "[color](#type_color)",
            "[string](#type_string)",
            "[true](#const_true)",
            "[false](#const_false)"
          ]
        },
        {
          "name": "string",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"string\")\nstring s = \"Hello World!\"    // Same as `s = \"Hello world!\"`\n// string s = na // same as \"\"\nplot(na, title=s)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[varip](#kw_varip)",
            "[int](#type_int)",
            "[float](#type_float)",
            "[bool](#type_bool)",
            "[str.tostring()](#fun_str.tostring)",
            "[str.format()](#fun_str.format)"
          ]
        },
        {
          "name": "color",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"color\", overlay = true)\n\ncolor textColor = color.green\ncolor labelColor = #FF000080 // Red color (FF0000) with 50% transparency (80 which is half of FF).\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, text = \"Label\", color = labelColor, textcolor = textColor)\n\n// When declaring variables with color literals, built-in constants(color.green) or functions (color.new(), color.rgb()), the \"color\" keyword for the type can be omitted.\nc = color.rgb(0,255,0,0)\nplot(close, color = c)"
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[varip](#kw_varip)",
            "[int](#type_int)",
            "[float](#type_float)",
            "[string](#type_string)",
            "[color.rgb()](#fun_color.rgb)",
            "[color.new()](#fun_color.new)"
          ]
        },
        {
          "name": "line",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"line\")\n// Empty `line1` line ID.\nvar line line1 = na\n// `line` type is unnecessary because `line.new()` returns \"line\" type.\nvar line2 = line.new(na, na, na, na)\nline3 = line.new(bar_index - 1, high, bar_index, high, extend = extend.right)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[label](#type_label)",
            "[box](#type_box)",
            "[line.new()](#fun_line.new)"
          ]
        },
        {
          "name": "label",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"label\")\n// Empty `label1` label ID.\nvar label label1 = na\n// `label` type is unnecessary because `label.new()` returns \"label\" type.\nvar label2 = label.new(na, na, na)\nif barstate.islastconfirmedhistory\n\tlabel3 = label.new(bar_index, high, text = \"label3 text\")"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[line](#type_line)",
            "[box](#type_box)",
            "[label.new()](#fun_label.new)"
          ]
        },
        {
          "name": "box",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"box\")\n// Empty `box1` box ID.\nvar box box1 = na\n// `box` type is unnecessary because `box.new()` returns a \"box\" type.\nvar box2 = box.new(na, na, na, na)\nbox3 = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[line](#type_line)",
            "[label](#type_label)",
            "[table](#type_table)",
            "[box.new()](#fun_box.new)"
          ]
        },
        {
          "name": "table",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"table\")\n// Empty `table1` table ID.\nvar table table1 = na\n// `table` type is unnecessary because `table.new()` returns \"table\" type.\nvar table2 = table.new(position.top_left, na, na)\n\nif barstate.islastconfirmedhistory\n\tvar table3 = table.new(position = position.top_right, columns = 1, rows = 1, bgcolor = color.yellow, border_width = 1)\n\ttable.cell(table_id = table3, column = 0, row = 0, text = \"table3 text\")"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[line](#type_line)",
            "[label](#type_label)",
            "[box](#type_box)",
            "[table.new()](#fun_table.new)"
          ]
        },
        {
          "name": "linefill",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"linefill\", overlay=true)\n// Empty `linefill1` line ID.\nvar linefill linefill1 = na\n// `linefill` type is unnecessary because `linefill.new()` returns \"linefill\" type.\nvar linefill2 = linefill.new(na, na, na)\n\nif barstate.islastconfirmedhistory\n\tline1 = line.new(bar_index - 10, high+1, bar_index, high+1, extend = extend.right)\n\tline2 = line.new(bar_index - 10, low+1, bar_index, low+1, extend = extend.right)\n\tlinefill3 = linefill.new(line1, line2, color = color.new(color.green, 80))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[line](#type_line)",
            "[label](#type_label)",
            "[table](#type_table)",
            "[box](#type_box)",
            "[linefill.new()](#fun_linefill.new)"
          ]
        },
        {
          "name": "array",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"array\", overlay=true)\narray<float> a = na\na := array.new<float>(1, close)\nplot(array.get(a, 0))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[line](#type_line)",
            "[label](#type_label)",
            "[table](#type_table)",
            "[box](#type_box)",
            "[array.new<type>()](#fun_array.new<type>)",
            "[array.from()](#fun_array.from)"
          ]
        },
        {
          "name": "matrix",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"matrix example\")\n\n// Create `m1` matrix of `int` type.\nmatrix<int> m1 = matrix.new<int>(2, 3, 0)\n\n// `matrix<int>` is unnecessary because the `matrix.new<int>()` function returns an `int` type matrix object.\nm2 = matrix.new<int>(2, 3, 0)\n\n// Display matrix using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m2))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[var](#kw_var)",
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[array](#type_array)"
          ]
        },
        {
          "name": "chart.point",
          "desc": [
            ""
          ],
          "fields": [
            {
              "name": "index",
              "desc": "",
              "type": "series int"
            },
            {
              "name": "time",
              "desc": "",
              "type": "series int"
            },
            {
              "name": "price",
              "desc": "",
              "type": "series float"
            }
          ],
          "seeAlso": [
            "[polyline](#type_polyline)"
          ]
        },
        {
          "name": "map",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"map\", overlay=true)\nmap<int, float> a = na\na := map.new<int, float>()\na.put(bar_index, close)\nlabel.new(bar_index, a.get(bar_index), \"Current close\")"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)"
          ]
        },
        {
          "name": "polyline",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[chart.point](#type_chart.point)"
          ]
        }
      ]
    }
  ],
  "methods": [
    {
      "title": "Built-in Method",
      "docs": [
        {
          "name": "copy",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator('Last 50 bars price ranges', overlay = true)\nLOOKBACK = 50\nhighest = ta.highest(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nif barstate.islastconfirmedhistory\n\tvar BoxLast = box.new(bar_index[LOOKBACK], highest, bar_index, lowest, bgcolor = color.new(color.green, 80))\n\tvar BoxPrev = box.copy(BoxLast)\n\tbox.set_lefttop(BoxPrev, bar_index[LOOKBACK * 2], highest[50])\n\tbox.set_rightbottom(BoxPrev, bar_index[LOOKBACK], lowest[50])\n\tbox.set_bgcolor(BoxPrev, color.new(color.red, 80))"
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.delete()](#fun_box.delete)"
          ],
          "syntax": [
            "box.copy(id) → series box"
          ],
          "returnedTypes": [
            "series box"
          ],
          "originalName": "box.copy",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "delete",
          "desc": [
            ""
          ],
          "args": [],
          "seeAlso": [
            "[box.new()](#fun_box.new)"
          ],
          "syntax": [
            "box.delete(id) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.delete",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "get_left",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.set_left()](#fun_box.set_left)"
          ],
          "syntax": [
            "box.get_left(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "box.get_left",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "get_right",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.set_right()](#fun_box.set_right)"
          ],
          "syntax": [
            "box.get_right(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "box.get_right",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "get_top",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.set_top()](#fun_box.set_top)"
          ],
          "syntax": [
            "box.get_top(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "box.get_top",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "get_bottom",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.set_bottom()](#fun_box.set_bottom)"
          ],
          "syntax": [
            "box.get_bottom(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "box.get_bottom",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_left",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "left",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.get_left()](#fun_box.get_left)"
          ],
          "syntax": [
            "box.set_left(id, left) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_left",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_lefttop",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "left",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "top",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.get_left()](#fun_box.get_left)",
            "[box.get_top()](#fun_box.get_top)"
          ],
          "syntax": [
            "box.set_lefttop(id, left, top) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_lefttop",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_right",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "right",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.get_right()](#fun_box.get_right)"
          ],
          "syntax": [
            "box.set_right(id, right) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_right",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_rightbottom",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "right",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "bottom",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.get_right()](#fun_box.get_right)",
            "[box.get_bottom()](#fun_box.get_bottom)"
          ],
          "syntax": [
            "box.set_rightbottom(id, right, bottom) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_rightbottom",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_top",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "top",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.get_top()](#fun_box.get_top)"
          ],
          "syntax": [
            "box.set_top(id, top) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_top",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_bottom",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "bottom",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.get_bottom()](#fun_box.get_bottom)"
          ],
          "syntax": [
            "box.set_bottom(id, bottom) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_bottom",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_border_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)"
          ],
          "syntax": [
            "box.set_border_color(id, color) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_border_color",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_bgcolor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)"
          ],
          "syntax": [
            "box.set_bgcolor(id, color) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_bgcolor",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_border_width",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "width",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)"
          ],
          "syntax": [
            "box.set_border_width(id, width) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_border_width",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_border_style",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "style",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)"
          ],
          "syntax": [
            "box.set_border_style(id, style) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_border_style",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_extend",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "extend",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[extend.none](#const_extend.none)",
            "[extend.right](#const_extend.right)",
            "[extend.left](#const_extend.left)",
            "[extend.both](#const_extend.both)"
          ],
          "syntax": [
            "box.set_extend(id, extend) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_extend",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_xloc",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "left",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "right",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "xloc",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[xloc.bar_index](#const_xloc.bar_index)",
            "[xloc.bar_time](#const_xloc.bar_time)"
          ],
          "syntax": [
            "box.set_xloc(id, left, right, xloc) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_xloc",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_text_font_family",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "text_font_family",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Example of setting the box font\")\nif barstate.islastconfirmedhistory\n    b = box.new(bar_index, open-ta.tr, bar_index-50, open-ta.tr*5, text=\"monospace\")\n    box.set_text_font_family(b, font.family_monospace)"
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[font.family_default](#const_font.family_default)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "syntax": [
            "box.set_text_font_family(id, text_font_family) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_text_font_family",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_text_halign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "text_halign",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_size()](#fun_box.set_text_size)",
            "[box.set_text_valign()](#fun_box.set_text_valign)",
            "[box.set_text_color()](#fun_box.set_text_color)"
          ],
          "syntax": [
            "box.set_text_halign(id, text_halign) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_text_halign",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_text_valign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "text_valign",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_size()](#fun_box.set_text_size)",
            "[box.set_text_color()](#fun_box.set_text_color)",
            "[box.set_text_halign()](#fun_box.set_text_halign)"
          ],
          "syntax": [
            "box.set_text_valign(id, text_valign) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_text_valign",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_text_size",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "text_size",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series int/string"
            }
          ],
          "seeAlso": [
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_color()](#fun_box.set_text_color)",
            "[box.set_text_valign()](#fun_box.set_text_valign)",
            "[box.set_text_halign()](#fun_box.set_text_halign)"
          ],
          "syntax": [
            "box.set_text_size(id, text_size) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_text_size",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_text",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "text",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.set_text_color()](#fun_box.set_text_color)",
            "[box.set_text_size()](#fun_box.set_text_size)",
            "[box.set_text_valign()](#fun_box.set_text_valign)",
            "[box.set_text_halign()](#fun_box.set_text_halign)",
            "[box.set_text_formatting()](#fun_box.set_text_formatting)"
          ],
          "syntax": [
            "box.set_text(id, text) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_text",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_text_formatting",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "text_formatting",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const text_format"
              ],
              "displayType": "const text_format"
            }
          ],
          "seeAlso": [
            "[box.set_text_color()](#fun_box.set_text_color)",
            "[box.set_text_size()](#fun_box.set_text_size)",
            "[box.set_text_valign()](#fun_box.set_text_valign)",
            "[box.set_text_halign()](#fun_box.set_text_halign)",
            "[box.set_text()](#fun_box.set_text)"
          ],
          "syntax": [
            "box.set_text_formatting(id, text_formatting) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_text_formatting",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_text_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "text_color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_size()](#fun_box.set_text_size)",
            "[box.set_text_valign()](#fun_box.set_text_valign)",
            "[box.set_text_halign()](#fun_box.set_text_halign)"
          ],
          "syntax": [
            "box.set_text_color(id, text_color) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_text_color",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "copy",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator('Last 100 bars price range', overlay = true)\nLOOKBACK = 100\nhighest = ta.highest(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nif barstate.islastconfirmedhistory\n\tvar lineTop = line.new(bar_index[LOOKBACK], highest, bar_index, highest, color = color.green)\n\tvar lineBottom = line.copy(lineTop)\n\tline.set_y1(lineBottom, lowest)\n\tline.set_y2(lineBottom, lowest)\n\tline.set_color(lineBottom, color.red)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[line.delete()](#fun_line.delete)"
          ],
          "syntax": [
            "line.copy(id) → series line"
          ],
          "returnedTypes": [
            "series line"
          ],
          "originalName": "line.copy",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_text_wrap",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "text_wrap",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_size()](#fun_box.set_text_size)",
            "[box.set_text_valign()](#fun_box.set_text_valign)",
            "[box.set_text_halign()](#fun_box.set_text_halign)",
            "[box.set_text_color()](#fun_box.set_text_color)"
          ],
          "syntax": [
            "box.set_text_wrap(id, text_wrap) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_text_wrap",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_x1",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_x1(id, x) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_x1",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_y1",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_y1(id, y) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_y1",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_xy1",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_xy1(id, x, y) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_xy1",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_x2",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_x2(id, x) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_x2",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_y2",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_y2(id, y) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_y2",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_xy2",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_xy2(id, x, y) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_xy2",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_xloc",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "x2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "xloc",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[xloc.bar_index](#const_xloc.bar_index)",
            "[xloc.bar_time](#const_xloc.bar_time)",
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_xloc(id, x1, x2, xloc) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_xloc",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_extend",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "extend",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[extend.none](#const_extend.none)",
            "[extend.right](#const_extend.right)",
            "[extend.left](#const_extend.left)",
            "[extend.both](#const_extend.both)",
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_extend(id, extend) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_extend",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_color(id, color) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_color",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_style",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "style",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_right](#const_line.style_arrow_right)",
            "[line.style_arrow_both](#const_line.style_arrow_both)",
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_style(id, style) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_style",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_width",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "width",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_width(id, width) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_width",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "delete",
          "desc": [
            ""
          ],
          "args": [],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.delete(id) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.delete",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "get_x1",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"line.get_x1\")\nmy_line = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)\na = line.get_x1(my_line)\nplot(time - line.get_x1(my_line)) //draws zero plot"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.get_x1(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "line.get_x1",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "get_y1",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.get_y1(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "line.get_y1",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "get_x2",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.get_x2(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "line.get_x2",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "get_y2",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.get_y2(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "line.get_y2",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "get_price",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"GetPrice\", overlay=true)\nvar line l = na\nif bar_index == 10\n    l := line.new(0, high[5], bar_index, high)\nplot(line.get_price(l, bar_index), color=color.green)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.get_price(id, x) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "line.get_price",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "copy",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator('Last 100 bars highest/lowest', overlay = true)\nLOOKBACK = 100\nhighest = ta.highest(LOOKBACK)\nhighestBars = ta.highestbars(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nlowestBars = ta.lowestbars(LOOKBACK)\nif barstate.islastconfirmedhistory\n\tvar labelHigh = label.new(bar_index + highestBars, highest, str.tostring(highest), color = color.green)\n\tvar labelLow = label.copy(labelHigh)\n\tlabel.set_xy(labelLow, bar_index + lowestBars, lowest)\n\tlabel.set_text(labelLow, str.tostring(lowest))\n\tlabel.set_color(labelLow, color.red)\n\tlabel.set_style(labelLow, label.style_label_up)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.delete()](#fun_label.delete)"
          ],
          "syntax": [
            "label.copy(id) → series label"
          ],
          "returnedTypes": [
            "series label"
          ],
          "originalName": "label.copy",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "delete",
          "desc": [
            ""
          ],
          "args": [],
          "syntax": [
            "linefill.delete(id) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "linefill.delete",
          "thisType": [
            "series linefill"
          ]
        },
        {
          "name": "set_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "syntax": [
            "linefill.set_color(id, color) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "linefill.set_color",
          "thisType": [
            "series linefill"
          ]
        },
        {
          "name": "get_line1",
          "desc": [
            ""
          ],
          "args": [],
          "syntax": [
            "linefill.get_line1(id) → series line"
          ],
          "returnedTypes": [
            "series line"
          ],
          "originalName": "linefill.get_line1",
          "thisType": [
            "series linefill"
          ]
        },
        {
          "name": "get_line2",
          "desc": [
            ""
          ],
          "args": [],
          "syntax": [
            "linefill.get_line2(id) → series line"
          ],
          "returnedTypes": [
            "series line"
          ],
          "originalName": "linefill.get_line2",
          "thisType": [
            "series linefill"
          ]
        },
        {
          "name": "set_x",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_x(id, x) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_x",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_y",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_y(id, y) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_y",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_xy",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_xy(id, x, y) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_xy",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_xloc",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "xloc",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[xloc.bar_index](#const_xloc.bar_index)",
            "[xloc.bar_time](#const_xloc.bar_time)",
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_xloc(id, x, xloc) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_xloc",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_yloc",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "yloc",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[yloc.price](#const_yloc.price)",
            "[yloc.abovebar](#const_yloc.abovebar)",
            "[yloc.belowbar](#const_yloc.belowbar)",
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_yloc(id, yloc) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_yloc",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_text",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "text",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_text_formatting()](#fun_label.set_text_formatting)"
          ],
          "syntax": [
            "label.set_text(id, text) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_text",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_text_formatting",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "text_formatting",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const text_format"
              ],
              "displayType": "const text_format"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_text()](#fun_label.set_text)"
          ],
          "syntax": [
            "label.set_text_formatting(id, text_formatting) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_text_formatting",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_text_font_family",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "text_font_family",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Example of setting the label font\")\nif barstate.islastconfirmedhistory\n    l = label.new(bar_index, 0, \"monospace\", yloc=yloc.abovebar)\n    label.set_text_font_family(l, font.family_monospace)"
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[font.family_default](#const_font.family_default)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "syntax": [
            "label.set_text_font_family(id, text_font_family) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_text_font_family",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_color(id, color) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_color",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_style",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "style",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_style(id, style) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_style",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_textcolor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "textcolor",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_textcolor(id, textcolor) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_textcolor",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_size",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "size",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series int/string"
            }
          ],
          "seeAlso": [
            "[size.auto](#const_size.auto)",
            "[size.tiny](#const_size.tiny)",
            "[size.small](#const_size.small)",
            "[size.normal](#const_size.normal)",
            "[size.large](#const_size.large)",
            "[size.huge](#const_size.huge)",
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_size(id, size) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_size",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_textalign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "textalign",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[text.align_left](#const_text.align_left)",
            "[text.align_center](#const_text.align_center)",
            "[text.align_right](#const_text.align_right)",
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_textalign(id, textalign) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_textalign",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_tooltip",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "tooltip",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_tooltip(id, tooltip) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_tooltip",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "delete",
          "desc": [
            ""
          ],
          "args": [],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.delete(id) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.delete",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "get_x",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"label.get_x\")\nmy_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)\na = label.get_x(my_label)\nplot(time - label.get_x(my_label)) //draws zero plot"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.get_x(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "label.get_x",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "get_y",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.get_y(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "label.get_y",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "get_text",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"label.get_text\")\nmy_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)\na = label.get_text(my_label)\nlabel.new(time, close, text = a + \" new\", xloc=xloc.bar_time)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.get_text(id) → series string"
          ],
          "returnedTypes": [
            "series string"
          ],
          "originalName": "label.get_text",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "copy",
          "desc": [
            ""
          ],
          "syntax": [
            "array.copy(id) → array<type>"
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.copy example\")\nlength = 5\na = array.new_float(length, close)\nb = array.copy(a)\na := array.new_float(length, open)\nplot(array.sum(a) / length)\nplot(array.sum(b) / length)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)",
            "[array.sort()](#fun_array.sort)"
          ],
          "originalName": "array.copy",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "slice",
          "desc": [
            ""
          ],
          "syntax": [
            "array.slice(id, index_from, index_to) → array<type>"
          ],
          "args": [
            {
              "name": "index_from",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "index_to",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.slice example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\n// take elements from 0 to 4\n// *note that changes in slice also modify original array\nslice = array.slice(a, 0, 5)\nplot(array.sum(a) / 10)\nplot(array.sum(slice) / 5)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)",
            "[array.sort()](#fun_array.sort)"
          ],
          "originalName": "array.slice",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "size",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.size example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\n// note that changes in slice also modify original array\nslice = array.slice(a, 0, 5)\narray.push(slice, open)\n// size was changed in slice and in original array\nplot(array.size(a))\nplot(array.size(slice))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.sum()](#fun_array.sum)",
            "[array.slice()](#fun_array.slice)",
            "[array.sort()](#fun_array.sort)"
          ],
          "syntax": [
            "array.size(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.size",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "first",
          "desc": [
            ""
          ],
          "syntax": [
            "array.first(id) → series <type>"
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.first example\")\narr = array.new_int(3, 10)\nplot(array.first(arr))"
          ],
          "seeAlso": [
            "[array.last()](#fun_array.last)",
            "[array.get()](#fun_array.get)"
          ],
          "originalName": "array.first",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "last",
          "desc": [
            ""
          ],
          "syntax": [
            "array.last(id) → series <type>"
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.last example\")\narr = array.new_int(3, 10)\nplot(array.last(arr))"
          ],
          "seeAlso": [
            "[array.first()](#fun_array.first)",
            "[array.get()](#fun_array.get)"
          ],
          "originalName": "array.last",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "every",
          "desc": [
            ""
          ],
          "args": [],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.some()](#fun_array.some)",
            "[array.get()](#fun_array.get)"
          ],
          "syntax": [
            "array.every(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "array.every",
          "thisType": [
            "array<bool>"
          ]
        },
        {
          "name": "some",
          "desc": [
            ""
          ],
          "args": [],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.every()](#fun_array.every)",
            "[array.get()](#fun_array.get)"
          ],
          "syntax": [
            "array.some(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "array.some",
          "thisType": [
            "array<bool>"
          ]
        },
        {
          "name": "get",
          "desc": [
            ""
          ],
          "syntax": [
            "array.get(id, index) → series <type>"
          ],
          "args": [
            {
              "name": "index",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.get example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i] - open[i])\nplot(array.get(a, 9))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.slice()](#fun_array.slice)",
            "[array.sort()](#fun_array.sort)"
          ],
          "originalName": "array.get",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "nth",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.min\")\na = array.from(5, -2, 0, 9, 1)\nsecondLowest = array.min(a, 1) // 0\nplot(secondLowest)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.sum()](#fun_array.sum)"
          ],
          "syntax": [
            "array.min(id, nth) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.min",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "nth",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.min\")\na = array.from(5, -2, 0, 9, 1)\nsecondLowest = array.min(a, 1) // 0\nplot(secondLowest)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.sum()](#fun_array.sum)"
          ],
          "syntax": [
            "array.min(id, nth) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.min",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "nth",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.max\")\na = array.from(5, -2, 0, 9, 1)\nthirdHighest = array.max(a, 2) // 1\nplot(thirdHighest)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.min()](#fun_array.min)",
            "[array.sum()](#fun_array.sum)"
          ],
          "syntax": [
            "array.max(id, nth) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.max",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "nth",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.max\")\na = array.from(5, -2, 0, 9, 1)\nthirdHighest = array.max(a, 2) // 1\nplot(thirdHighest)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.min()](#fun_array.min)",
            "[array.sum()](#fun_array.sum)"
          ],
          "syntax": [
            "array.max(id, nth) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.max",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "range",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.range example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.range(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.min()](#fun_array.min)",
            "[array.max()](#fun_array.max)",
            "[array.sum()](#fun_array.sum)"
          ],
          "syntax": [
            "array.range(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.range",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "range",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.range example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.range(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.min()](#fun_array.min)",
            "[array.max()](#fun_array.max)",
            "[array.sum()](#fun_array.sum)"
          ],
          "syntax": [
            "array.range(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.range",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "sum",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.sum example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.sum(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)"
          ],
          "syntax": [
            "array.sum(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.sum",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "sum",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.sum example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.sum(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)"
          ],
          "syntax": [
            "array.sum(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.sum",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "set",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "index",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.set example\")\na = array.new_float(10)\nfor i = 0 to 9\n\tarray.set(a, i, close[i])\nplot(array.sum(a) / 10)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)"
          ],
          "syntax": [
            "array.set(id, index, value) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "array.set",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "fill",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            },
            {
              "name": "index_from",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "index_to",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.fill example\")\na = array.new_float(10)\narray.fill(a, close)\nplot(array.sum(a))"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.slice()](#fun_array.slice)"
          ],
          "syntax": [
            "array.fill(id, value, index_from, index_to) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "array.fill",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "insert",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "index",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.insert example\")\na = array.new_float(5, close)\narray.insert(a, 0, open)\nplot(array.get(a, 5))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.push()](#fun_array.push)",
            "[array.remove()](#fun_array.remove)",
            "[array.pop()](#fun_array.pop)",
            "[array.unshift()](#fun_array.unshift)"
          ],
          "syntax": [
            "array.insert(id, index, value) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "array.insert",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "join",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "separator",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.join example\")\na = array.new_float(5, 5)\nlabel.new(bar_index, close, array.join(a, \",\"))"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.insert()](#fun_array.insert)",
            "[array.remove()](#fun_array.remove)",
            "[array.pop()](#fun_array.pop)",
            "[array.unshift()](#fun_array.unshift)"
          ],
          "syntax": [
            "array.join(id, separator) → series string"
          ],
          "returnedTypes": [
            "series string"
          ],
          "originalName": "array.join",
          "thisType": [
            "array<float>",
            "array<int>",
            "array<string>"
          ]
        },
        {
          "name": "push",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.push example\")\na = array.new_float(5, 0)\narray.push(a, open)\nplot(array.get(a, 5))"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.insert()](#fun_array.insert)",
            "[array.remove()](#fun_array.remove)",
            "[array.pop()](#fun_array.pop)",
            "[array.unshift()](#fun_array.unshift)"
          ],
          "syntax": [
            "array.push(id, value) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "array.push",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "remove",
          "desc": [
            ""
          ],
          "syntax": [
            "array.remove(id, index) → series <type>"
          ],
          "args": [
            {
              "name": "index",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.remove example\")\na = array.new_float(5,high)\nremovedEl = array.remove(a, 0)\nplot(array.size(a))\nplot(removedEl)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.push()](#fun_array.push)",
            "[array.insert()](#fun_array.insert)",
            "[array.pop()](#fun_array.pop)",
            "[array.shift()](#fun_array.shift)"
          ],
          "originalName": "array.remove",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "pop",
          "desc": [
            ""
          ],
          "syntax": [
            "array.pop(id) → series <type>"
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.pop example\")\na = array.new_float(5,high)\nremovedEl = array.pop(a)\nplot(array.size(a))\nplot(removedEl)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.push()](#fun_array.push)",
            "[array.remove()](#fun_array.remove)",
            "[array.insert()](#fun_array.insert)",
            "[array.shift()](#fun_array.shift)"
          ],
          "originalName": "array.pop",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "clear",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.clear example\")\na = array.new_float(5,high)\narray.clear(a)\narray.push(a, close)\nplot(array.get(a,0))\nplot(array.size(a))"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.push()](#fun_array.push)",
            "[array.remove()](#fun_array.remove)",
            "[array.pop()](#fun_array.pop)"
          ],
          "syntax": [
            "array.clear(id) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "array.clear",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "sort",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "order",
              "desc": "",
              "allowedTypeIDs": [
                "series sort_order",
                "simple sort_order",
                "input sort_order",
                "const sort_order"
              ],
              "displayType": "series sort_order"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.sort example\")\na = array.new_float(0,0)\nfor i = 0 to 5\n\tarray.push(a, high[i])\narray.sort(a, order.descending)\nif barstate.islast\n\tlabel.new(bar_index, close, str.tostring(a))"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.sort(id, order) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "array.sort",
          "thisType": [
            "array<float>",
            "array<int>",
            "array<string>"
          ]
        },
        {
          "name": "sort_indices",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "order",
              "desc": "",
              "allowedTypeIDs": [
                "series sort_order",
                "simple sort_order",
                "input sort_order",
                "const sort_order"
              ],
              "displayType": "series sort_order"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.sort_indices\")\na = array.from(5, -2, 0, 9, 1)\nsortedIndices = array.sort_indices(a) // [1, 2, 4, 0, 3]\nindexOfSmallestValue = array.get(sortedIndices, 0) // 1\nsmallestValue = array.get(a, indexOfSmallestValue) // -2\nplot(smallestValue)"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.sort_indices(id, order) → array<int>"
          ],
          "returnedTypes": [
            "array<int>"
          ],
          "originalName": "array.sort_indices",
          "thisType": [
            "array<float>",
            "array<int>",
            "array<string>"
          ]
        },
        {
          "name": "percentrank",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "index",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.percentrank(id, index) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.percentrank",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "percentrank",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "index",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.percentrank(id, index) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.percentrank",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "percentile_nearest_rank",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "percentage",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.percentile_nearest_rank(id, percentage) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.percentile_nearest_rank",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "percentile_nearest_rank",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "percentage",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.percentile_nearest_rank(id, percentage) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.percentile_nearest_rank",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "percentile_linear_interpolation",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "percentage",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.percentile_linear_interpolation(id, percentage) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.percentile_linear_interpolation",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "percentile_linear_interpolation",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "percentage",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.percentile_linear_interpolation(id, percentage) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.percentile_linear_interpolation",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "abs",
          "desc": [
            ""
          ],
          "args": [],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.abs(id) → array<float>"
          ],
          "returnedTypes": [
            "array<float>"
          ],
          "originalName": "array.abs",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "abs",
          "desc": [
            ""
          ],
          "args": [],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.abs(id) → array<int>"
          ],
          "returnedTypes": [
            "array<int>"
          ],
          "originalName": "array.abs",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "binary_search",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "val",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.binary_search\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search(a, 0) // 1\nplot(position)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.binary_search(id, val) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.binary_search",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "binary_search_leftmost",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "val",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"array.binary_search_leftmost\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search_leftmost(a, 3) // 2\nplot(position)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"array.binary_search_leftmost, repetitive elements\")\na = array.from(4, 5, 5, 5)\n// Returns the index of the first instance.\nposition = array.binary_search_leftmost(a, 5)\nplot(position) // Plots 1"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.binary_search_leftmost(id, val) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.binary_search_leftmost",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "binary_search_rightmost",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "val",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"array.binary_search_rightmost\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search_rightmost(a, 3) // 3\nplot(position)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"array.binary_search_rightmost, repetitive elements\")\na = array.from(4, 5, 5, 5)\n// Returns the index of the last instance.\nposition = array.binary_search_rightmost(a, 5)\nplot(position) // Plots 3"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.binary_search_rightmost(id, val) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.binary_search_rightmost",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "concat",
          "desc": [
            ""
          ],
          "syntax": [
            "array.concat(id1, id2) → array<type>"
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.concat example\")\na = array.new_float(0,0)\nb = array.new_float(0,0)\nfor i = 0 to 4\n    array.push(a, high[i])\n    array.push(b, low[i])\nc = array.concat(a,b)\nplot(array.size(a))\nplot(array.size(b))\nplot(array.size(c))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)"
          ],
          "originalName": "array.concat",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "avg",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.avg example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.avg(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)",
            "[array.stdev()](#fun_array.stdev)"
          ],
          "syntax": [
            "array.avg(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.avg",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "avg",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.avg example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.avg(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)",
            "[array.stdev()](#fun_array.stdev)"
          ],
          "syntax": [
            "array.avg(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.avg",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "stdev",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "biased",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.stdev example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.stdev(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)",
            "[array.avg()](#fun_array.avg)"
          ],
          "syntax": [
            "array.stdev(id, biased) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.stdev",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "stdev",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "biased",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.stdev example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.stdev(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)",
            "[array.avg()](#fun_array.avg)"
          ],
          "syntax": [
            "array.stdev(id, biased) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.stdev",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "variance",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "biased",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.variance example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.variance(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.stdev()](#fun_array.stdev)",
            "[array.min()](#fun_array.min)",
            "[array.avg()](#fun_array.avg)",
            "[array.covariance()](#fun_array.covariance)"
          ],
          "syntax": [
            "array.variance(id, biased) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.variance",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "variance",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "biased",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.variance example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.variance(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.stdev()](#fun_array.stdev)",
            "[array.min()](#fun_array.min)",
            "[array.avg()](#fun_array.avg)",
            "[array.covariance()](#fun_array.covariance)"
          ],
          "syntax": [
            "array.variance(id, biased) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.variance",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "covariance",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "biased",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.covariance example\")\na = array.new_float(0)\nb = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\n\tarray.push(b, open[i])\nplot(array.covariance(a, b))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.stdev()](#fun_array.stdev)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)"
          ],
          "syntax": [
            "array.covariance(id1, id2, biased) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.covariance",
          "thisType": [
            "array<int>",
            "array<float>"
          ]
        },
        {
          "name": "mode",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.mode example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.mode(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[ta.mode()](#fun_ta.mode)",
            "[matrix.mode()](#fun_matrix.mode)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)",
            "[array.min()](#fun_array.min)"
          ],
          "syntax": [
            "array.mode(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.mode",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "mode",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.mode example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.mode(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[ta.mode()](#fun_ta.mode)",
            "[matrix.mode()](#fun_matrix.mode)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)",
            "[array.min()](#fun_array.min)"
          ],
          "syntax": [
            "array.mode(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.mode",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "median",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.median example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.median(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.median()](#fun_array.median)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)",
            "[array.min()](#fun_array.min)"
          ],
          "syntax": [
            "array.median(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "array.median",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "median",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.median example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.median(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.median()](#fun_array.median)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)",
            "[array.min()](#fun_array.min)"
          ],
          "syntax": [
            "array.median(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.median",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "standardize",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.standardize example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nb = array.standardize(a)\nplot(array.min(b))\nplot(array.max(b))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)",
            "[array.mode()](#fun_array.mode)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)",
            "[array.stdev()](#fun_array.stdev)"
          ],
          "syntax": [
            "array.standardize(id) → array<float>"
          ],
          "returnedTypes": [
            "array<float>"
          ],
          "originalName": "array.standardize",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "standardize",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.standardize example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nb = array.standardize(a)\nplot(array.min(b))\nplot(array.max(b))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)",
            "[array.mode()](#fun_array.mode)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)",
            "[array.stdev()](#fun_array.stdev)"
          ],
          "syntax": [
            "array.standardize(id) → array<int>"
          ],
          "returnedTypes": [
            "array<int>"
          ],
          "originalName": "array.standardize",
          "thisType": [
            "array<float>",
            "array<int>"
          ]
        },
        {
          "name": "indexof",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.indexof example\")\na = array.new_float(5,high)\nindex = array.indexof(a, high)\nplot(index)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.lastindexof()](#fun_array.lastindexof)",
            "[array.get()](#fun_array.get)",
            "[array.lastindexof()](#fun_array.lastindexof)",
            "[array.remove()](#fun_array.remove)",
            "[array.insert()](#fun_array.insert)"
          ],
          "syntax": [
            "array.indexof(id, value) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.indexof",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "lastindexof",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.lastindexof example\")\na = array.new_float(5,high)\nindex = array.lastindexof(a, high)\nplot(index)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.push()](#fun_array.push)",
            "[array.remove()](#fun_array.remove)",
            "[array.insert()](#fun_array.insert)"
          ],
          "syntax": [
            "array.lastindexof(id, value) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "array.lastindexof",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "includes",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.includes example\")\na = array.new_float(5,high)\np = close\nif array.includes(a, high)\n\tp := open\nplot(p)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.indexof()](#fun_array.indexof)",
            "[array.shift()](#fun_array.shift)",
            "[array.remove()](#fun_array.remove)",
            "[array.insert()](#fun_array.insert)"
          ],
          "syntax": [
            "array.includes(id, value) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "array.includes",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "shift",
          "desc": [
            ""
          ],
          "syntax": [
            "array.shift(id) → series <type>"
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.shift example\")\na = array.new_float(5,high)\nremovedEl = array.shift(a)\nplot(array.size(a))\nplot(removedEl)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.unshift()](#fun_array.unshift)",
            "[array.set()](#fun_array.set)",
            "[array.push()](#fun_array.push)",
            "[array.remove()](#fun_array.remove)",
            "[array.includes()](#fun_array.includes)"
          ],
          "originalName": "array.shift",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "unshift",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.unshift example\")\na = array.new_float(5, 0)\narray.unshift(a, open)\nplot(array.get(a, 0))"
          ],
          "seeAlso": [
            "[array.shift()](#fun_array.shift)",
            "[array.set()](#fun_array.set)",
            "[array.insert()](#fun_array.insert)",
            "[array.remove()](#fun_array.remove)",
            "[array.indexof()](#fun_array.indexof)"
          ],
          "syntax": [
            "array.unshift(id, value) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "array.unshift",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "reverse",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"array.reverse example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.get(a, 0))\narray.reverse(a)\nplot(array.get(a, 0))"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.sort()](#fun_array.sort)",
            "[array.push()](#fun_array.push)",
            "[array.set()](#fun_array.set)",
            "[array.avg()](#fun_array.avg)"
          ],
          "syntax": [
            "array.reverse(id) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "array.reverse",
          "thisType": [
            "array<>"
          ]
        },
        {
          "name": "delete",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"table.delete example\")\nvar testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)\nif barstate.islast\n    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))\n    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)\nif barstate.isrealtime\n    table.delete(testTable)"
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[table.clear()](#fun_table.clear)"
          ],
          "syntax": [
            "table.delete(table_id) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.delete",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "set_position",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "position",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)",
            "[table.set_bgcolor()](#fun_table.set_bgcolor)",
            "[table.set_border_color()](#fun_table.set_border_color)",
            "[table.set_border_width()](#fun_table.set_border_width)",
            "[table.set_frame_color()](#fun_table.set_frame_color)",
            "[table.set_frame_width()](#fun_table.set_frame_width)"
          ],
          "syntax": [
            "table.set_position(table_id, position) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.set_position",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "set_bgcolor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "bgcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)",
            "[table.set_border_color()](#fun_table.set_border_color)",
            "[table.set_border_width()](#fun_table.set_border_width)",
            "[table.set_frame_color()](#fun_table.set_frame_color)",
            "[table.set_frame_width()](#fun_table.set_frame_width)",
            "[table.set_position()](#fun_table.set_position)"
          ],
          "syntax": [
            "table.set_bgcolor(table_id, bgcolor) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.set_bgcolor",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "set_frame_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "frame_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)",
            "[table.set_border_color()](#fun_table.set_border_color)",
            "[table.set_border_width()](#fun_table.set_border_width)",
            "[table.set_bgcolor()](#fun_table.set_bgcolor)",
            "[table.set_frame_width()](#fun_table.set_frame_width)",
            "[table.set_position()](#fun_table.set_position)"
          ],
          "syntax": [
            "table.set_frame_color(table_id, frame_color) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.set_frame_color",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "set_border_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "border_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)",
            "[table.set_frame_color()](#fun_table.set_frame_color)",
            "[table.set_border_width()](#fun_table.set_border_width)",
            "[table.set_bgcolor()](#fun_table.set_bgcolor)",
            "[table.set_frame_width()](#fun_table.set_frame_width)",
            "[table.set_position()](#fun_table.set_position)"
          ],
          "syntax": [
            "table.set_border_color(table_id, border_color) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.set_border_color",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "set_frame_width",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "frame_width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)",
            "[table.set_frame_color()](#fun_table.set_frame_color)",
            "[table.set_border_width()](#fun_table.set_border_width)",
            "[table.set_bgcolor()](#fun_table.set_bgcolor)",
            "[table.set_border_color()](#fun_table.set_border_color)",
            "[table.set_position()](#fun_table.set_position)"
          ],
          "syntax": [
            "table.set_frame_width(table_id, frame_width) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.set_frame_width",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "set_border_width",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "border_width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)",
            "[table.set_frame_color()](#fun_table.set_frame_color)",
            "[table.set_frame_width()](#fun_table.set_frame_width)",
            "[table.set_bgcolor()](#fun_table.set_bgcolor)",
            "[table.set_border_color()](#fun_table.set_border_color)",
            "[table.set_position()](#fun_table.set_position)"
          ],
          "syntax": [
            "table.set_border_width(table_id, border_width) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.set_border_width",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "cell",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "height",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "text_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "text_halign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_valign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series int/string"
            },
            {
              "name": "bgcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_font_family",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_formatting",
              "desc": "",
              "allowedTypeIDs": [
                "const text_format"
              ],
              "displayType": "const text_format"
            }
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_formatting()](#fun_table.cell_set_text_formatting)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell(table_id, column, row, text, width, height, text_color, text_halign, text_valign, text_size, bgcolor, tooltip, text_font_family, text_formatting) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.cell",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "cell_set_text",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"TABLE example\")\nvar tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)\ntable.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)\ntable.cell_set_text(tLog, row = 0, column = 0, text = \"sometext\")"
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)",
            "[table.cell_set_text_formatting()](#fun_table.cell_set_text_formatting)"
          ],
          "syntax": [
            "table.cell_set_text(table_id, column, row, text) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.cell_set_text",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "cell_set_text_formatting",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text_formatting",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const text_format"
              ],
              "displayType": "const text_format"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)",
            "[table.cell_set_text()](#fun_table.cell_set_text)"
          ],
          "syntax": [
            "table.cell_set_text_formatting(table_id, column, row, text_formatting) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.cell_set_text_formatting",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "cell_set_text_font_family",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text_font_family",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Example of setting the table cell font\")\nvar t = table.new(position.top_left, rows = 1, columns = 1)\ntable.cell(t, 0, 0, \"monospace\", text_color = color.blue)\ntable.cell_set_text_font_family(t, 0, 0, font.family_monospace)"
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[font.family_default](#const_font.family_default)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "syntax": [
            "table.cell_set_text_font_family(table_id, column, row, text_font_family) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.cell_set_text_font_family",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "cell_set_tooltip",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"TABLE example\")\nvar tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)\ntable.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)\ntable.cell_set_tooltip(tLog, row = 0, column = 0, tooltip = \"sometext\")"
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_text()](#fun_table.cell_set_text)"
          ],
          "syntax": [
            "table.cell_set_tooltip(table_id, column, row, tooltip) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.cell_set_tooltip",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "cell_set_width",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_width(table_id, column, row, width) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.cell_set_width",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "cell_set_height",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "height",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_height(table_id, column, row, height) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.cell_set_height",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "cell_set_text_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_text_color(table_id, column, row, text_color) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.cell_set_text_color",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "cell_set_text_halign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text_halign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_text_halign(table_id, column, row, text_halign) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.cell_set_text_halign",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "cell_set_text_valign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text_valign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_text_valign(table_id, column, row, text_valign) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.cell_set_text_valign",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "cell_set_text_size",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text_size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series int/string"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_text_size(table_id, column, row, text_size) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.cell_set_text_size",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "cell_set_bgcolor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "bgcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_bgcolor(table_id, column, row, bgcolor) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.cell_set_bgcolor",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "clear",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "start_column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "start_row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "end_column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "end_row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"A donut\", overlay=true)\nif barstate.islast\n    colNum = 8, rowNum = 8\n    padding = \"◯\"\n    donutTable = table.new(position.middle_right, colNum, rowNum)\n    for c = 0 to colNum - 1\n        for r = 0 to rowNum - 1\n            table.cell(donutTable, c, r, text=padding, bgcolor=#face6e, text_color=color.new(color.black, 100))\n    table.clear(donutTable, 2, 2, 5, 5)"
          ],
          "seeAlso": [
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)"
          ],
          "syntax": [
            "table.clear(table_id, start_column, start_row, end_column, end_row) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.clear",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "row",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.row()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from `hlc3` values.\nm = matrix.new<float>(2, 3, hlc3)\n\n// Return an array with the values of the first row of the matrix.\na = matrix.row(m, 0)\n\n// Plot the first value from the array `a`.\nplot(array.get(a, 0))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[array.get()](#fun_array.get)",
            "[matrix.col()](#fun_matrix.col)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.row(id, row) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ],
          "originalName": "matrix.row",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "col",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.col()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from `hlc3` values.\nm = matrix.new<float>(2, 3, hlc3)\n\n// Return an array with the values of the first column of matrix `m`.\na = matrix.col(m, 0)\n\n// Plot the first value from the array `a`.\nplot(array.get(a, 0))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[array.get()](#fun_array.get)",
            "[matrix.col()](#fun_matrix.col)",
            "[matrix.columns()](#fun_matrix.columns)"
          ],
          "syntax": [
            "matrix.col(id, column) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ],
          "originalName": "matrix.col",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "reshape",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "rows",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "columns",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.reshape()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix.\n\tvar m1 = matrix.new<float>(2, 3)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 0, 2, 3)\n\tmatrix.set(m1, 1, 0, 4)\n\tmatrix.set(m1, 1, 1, 5)\n\tmatrix.set(m1, 1, 2, 6)\n\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\n\t// Reshape the copy to a 3x2.\n\tmatrix.reshape(m2, 3, 2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Reshaped matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.add_row()](#fun_matrix.add_row)",
            "[matrix.add_col()](#fun_matrix.add_col)"
          ],
          "syntax": [
            "matrix.reshape(id, rows, columns) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "matrix.reshape",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "get",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.get()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from the `hl2` values.\nm = matrix.new<float>(2, 3, hl2)\n\n// Return the value of the element at index [0, 0] of matrix `m`.\nx = matrix.get(m, 0, 0)\n\nplot(x)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.get(id, row, column) → <matrix_type>"
          ],
          "returnedTypes": [],
          "originalName": "matrix.get",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "set",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the matrix's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.set()` Example\")\n\n// Create a 2x3 \"int\" matrix containing values `4`.\nm = matrix.new<int>(2, 3, 4)\n\n// Replace the value of element at row 1 and column 2 with value `3`.\nmatrix.set(m, 0, 1, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))"
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.set(id, row, column, value) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "matrix.set",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "add_row",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "array_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.add_row()` Example 1\")\n\n// Create a 2x3 \"int\" matrix containing values `0`.\nm = matrix.new<int>(2, 3, 0)\n\n// Add a row with `na` values to the matrix.\nmatrix.add_row(m)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.add_row()` Example 2\")\n\nif barstate.islastconfirmedhistory\n\t// Create an empty matrix object.\n\tvar m = matrix.new<int>()\n\n\t// Create an array with values `1` and `2`.\n\tvar a = array.from(1, 2)\n\n\t// Add the `a` array as the first row of the empty matrix.\n\tmatrix.add_row(m, 0, a)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)",
            "[matrix.add_col()](#fun_matrix.add_col)"
          ],
          "syntax": [
            "matrix.add_row(id, row, array_id) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "matrix.add_row",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "add_col",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "array_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.add_col()` Example 1\")\n\n// Create a 2x3 \"int\" matrix containing values `0`.\nm = matrix.new<int>(2, 3, 0)\n\n// Add a column with `na` values to the matrix.\nmatrix.add_col(m)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.add_col()` Example 2\")\n\nif barstate.islastconfirmedhistory\n\t// Create an empty matrix object.\n\tvar m = matrix.new<int>()\n\n\t// Create an array with values `1` and `3`.\n\tvar a = array.from(1, 3)\n\n\t// Add the `a` array as the first column of the empty matrix.\n\tmatrix.add_col(m, 0, a)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)",
            "[matrix.add_row()](#fun_matrix.add_row)"
          ],
          "syntax": [
            "matrix.add_col(id, column, array_id) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "matrix.add_col",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "remove_row",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"matrix_remove_row\", overlay = true)\n\n// Create a 2x2 \"int\" matrix containing values `1`.\nvar matrixOrig = matrix.new<int>(2, 2, 1)\n\n// Set values to the 'matrixOrig' matrix.\nmatrix.set(matrixOrig, 0, 1, 2)\nmatrix.set(matrixOrig, 1, 0, 3)\nmatrix.set(matrixOrig, 1, 1, 4)\n\n// Create a copy of the 'matrixOrig' matrix.\nmatrixCopy = matrix.copy(matrixOrig)\n\n// Remove the first row from the matrix `matrixCopy`.\narr = matrix.remove_row(matrixCopy, 0)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 3, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(matrixOrig))\n\ttable.cell(t, 1, 0, \"Removed Elements:\")\n\ttable.cell(t, 1, 1, str.tostring(arr))\n\ttable.cell(t, 2, 0, \"Result Matrix:\")\n\ttable.cell(t, 2, 1, str.tostring(matrixCopy))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.copy()](#fun_matrix.copy)",
            "[matrix.remove_col()](#fun_matrix.remove_col)"
          ],
          "syntax": [
            "matrix.remove_row(id, row) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ],
          "originalName": "matrix.remove_row",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "remove_col",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"matrix_remove_col\", overlay = true)\n\n// Create a 2x2 matrix with ones.\nvar matrixOrig = matrix.new<int>(2, 2, 1)\n\n// Set values to the 'matrixOrig' matrix.\nmatrix.set(matrixOrig, 0, 1, 2)\nmatrix.set(matrixOrig, 1, 0, 3)\nmatrix.set(matrixOrig, 1, 1, 4)\n\n\n// Create a copy of the 'matrixOrig' matrix.\nmatrixCopy = matrix.copy(matrixOrig)\n\n// Remove the first column from the `matrixCopy` matrix.\narr = matrix.remove_col(matrixCopy, 0)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 3, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(matrixOrig))\n\ttable.cell(t, 1, 0, \"Removed Elements:\")\n\ttable.cell(t, 1, 1, str.tostring(arr))\n\ttable.cell(t, 2, 0, \"Result Matrix:\")\n\ttable.cell(t, 2, 1, str.tostring(matrixCopy))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.copy()](#fun_matrix.copy)",
            "[matrix.remove_row()](#fun_matrix.remove_row)"
          ],
          "syntax": [
            "matrix.remove_col(id, column) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ],
          "originalName": "matrix.remove_col",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "fill",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the matrix's elements>"
            },
            {
              "name": "from_row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "to_row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "from_column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "to_column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.fill()` Example\")\n\n// Create a 4x5 \"int\" matrix containing values `0`.\nm = matrix.new<float>(4, 5, 0)\n\n// Fill the intersection of rows 1 to 2 and columns 2 to 3 of the matrix with `hl2` values.\nmatrix.fill(m, hl2, 0, 2, 1, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))"
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.fill(id, value, from_row, to_row, from_column, to_column) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "matrix.fill",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "submatrix",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "from_row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "to_row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "from_column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "to_column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.submatrix()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix matrix with values `0`.\n\tvar m1 = matrix.new<int>(2, 3, 0)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 0, 2, 3)\n\tmatrix.set(m1, 1, 0, 4)\n\tmatrix.set(m1, 1, 1, 5)\n\tmatrix.set(m1, 1, 2, 6)\n\n\t// Create a 2x2 submatrix of the `m1` matrix.\n\tvar m2 = matrix.submatrix(m1, 0, 2, 1, 3)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Submatrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.row()](#fun_matrix.row)",
            "[matrix.col()](#fun_matrix.col)",
            "[matrix.reshape()](#fun_matrix.reshape)"
          ],
          "syntax": [
            "matrix.submatrix(id, from_row, to_row, from_column, to_column) → matrix<type>"
          ],
          "returnedTypes": [
            "matrix<>"
          ],
          "originalName": "matrix.submatrix",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "copy",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.copy()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 \"float\" matrix with `1` values.\n\tvar m1 = matrix.new<float>(2, 3, 1)\n\n\t// Copy the matrix to a new one.\n\t// Note that unlike what `matrix.copy()` does,\n\t// the simple assignment operation `m2 = m1`\n\t// would NOT create a new copy of the `m1` matrix.\n\t// It would merely create a copy of its ID referencing the same matrix.\n\tvar m2 = matrix.copy(m1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix Copy:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.copy(id) → matrix<type>"
          ],
          "returnedTypes": [
            "matrix<>"
          ],
          "originalName": "matrix.copy",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "columns",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.columns()` Example\")\n\n// Create a 2x6 matrix with values `0`.\nvar m = matrix.new<int>(2, 6, 0)\n\n// Get the quantity of columns in matrix `m`.\nvar x = matrix.columns(m)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, \"Columns: \" + str.tostring(x) + \"\\n\" + str.tostring(m))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.col()](#fun_matrix.col)",
            "[matrix.row()](#fun_matrix.row)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.columns(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "matrix.columns",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "rows",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.rows()` Example\")\n\n// Create a 2x6 matrix with values `0`.\nvar m = matrix.new<int>(2, 6, 0)\n\n// Get the quantity of rows in the matrix.\nvar x = matrix.rows(m)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, \"Rows: \" + str.tostring(x) + \"\\n\" + str.tostring(m))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.row()](#fun_matrix.row)"
          ],
          "syntax": [
            "matrix.rows(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "matrix.rows",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "elements_count",
          "desc": [
            ""
          ],
          "args": [],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.elements_count(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "matrix.elements_count",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "concat",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.concat()` Example\")\n\n// Create a 2x4 \"int\" matrix containing values `0`.\nm1 = matrix.new<int>(2, 4, 0)\n// Create a 2x4 \"int\" matrix containing values `1`.\nm2 = matrix.new<int>(2, 4, 1)\n\n// Append matrix `m2` to `m1`.\nmatrix.concat(m1, m2)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix Elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.concat(id1, id2) → matrix<type>"
          ],
          "returnedTypes": [
            "matrix<>"
          ],
          "originalName": "matrix.concat",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "swap_rows",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "row1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.swap_rows()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 3x2 matrix with ‘na’ values.\n\tvar m1 = matrix.new<int>(3, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\tmatrix.set(m1, 2, 0, 5)\n\tmatrix.set(m1, 2, 1, 6)\n\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\n\t// Swap the first and second rows of the matrix copy.\n\tmatrix.swap_rows(m2, 0, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Swapped rows in copy:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.swap_columns()](#fun_matrix.swap_columns)"
          ],
          "syntax": [
            "matrix.swap_rows(id, row1, row2) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "matrix.swap_rows",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "swap_columns",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "column2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.swap_columns()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix with ‘na’ values.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\n\t// Swap the first and second columns of the matrix copy.\n\tmatrix.swap_columns(m2, 0, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Swapped columns in copy:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.swap_columns(id, column1, column2) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "matrix.swap_columns",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "reverse",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.reverse()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Copy the matrix to a new one.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Copy matrix elements to a new matrix.\n\tvar m2 = matrix.copy(m1)\n\n\t// Reverse the `m2` copy of the original matrix.\n\tmatrix.reverse(m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Reversed matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)",
            "[matrix.reshape()](#fun_matrix.reshape)"
          ],
          "syntax": [
            "matrix.reverse(id) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "matrix.reverse",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "sort",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "order",
              "desc": "",
              "allowedTypeIDs": [
                "series sort_order",
                "simple sort_order",
                "input sort_order",
                "const sort_order"
              ],
              "displayType": "series sort_order"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.sort()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<float>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 3)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 1)\n\tmatrix.set(m1, 1, 1, 2)\n\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\t// Sort the rows of `m2` using the default arguments (first column and ascending order).\n\tmatrix.sort(m2)\n\n\t// Display using a table.\n\tif barstate.islastconfirmedhistory\n\t\tvar t = table.new(position.top_right, 2, 2, color.green)\n\t\ttable.cell(t, 0, 0, \"Original matrix:\")\n\t\ttable.cell(t, 0, 1, str.tostring(m1))\n\t\ttable.cell(t, 1, 0, \"Sorted matrix:\")\n\t\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.max()](#fun_matrix.max)",
            "[matrix.min()](#fun_matrix.min)",
            "[matrix.avg()](#fun_matrix.avg)"
          ],
          "syntax": [
            "matrix.sort(id, column, order) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "matrix.sort",
          "thisType": [
            "matrix<int>",
            "matrix<float>",
            "matrix<string>"
          ]
        },
        {
          "name": "det",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.det` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<float>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0,  3)\nmatrix.set(m, 0, 1,  7)\nmatrix.set(m, 1, 0,  1)\nmatrix.set(m, 1, 1, -4)\n\n// Get the determinant of the matrix.\nvar x = matrix.det(m)\n\nplot(x, 'Matrix determinant')"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)"
          ],
          "syntax": [
            "matrix.det(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "matrix.det",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "det",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.det` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<float>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0,  3)\nmatrix.set(m, 0, 1,  7)\nmatrix.set(m, 1, 0,  1)\nmatrix.set(m, 1, 1, -4)\n\n// Get the determinant of the matrix.\nvar x = matrix.det(m)\n\nplot(x, 'Matrix determinant')"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)"
          ],
          "syntax": [
            "matrix.det(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "matrix.det",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "min",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.min()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the minimum value from the matrix.\nvar x = matrix.min(m)\n\nplot(x, 'Matrix minimum value')"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.max()](#fun_matrix.max)",
            "[matrix.avg()](#fun_matrix.avg)",
            "[matrix.sort()](#fun_matrix.sort)"
          ],
          "syntax": [
            "matrix.min(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "matrix.min",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "min",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.min()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the minimum value from the matrix.\nvar x = matrix.min(m)\n\nplot(x, 'Matrix minimum value')"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.max()](#fun_matrix.max)",
            "[matrix.avg()](#fun_matrix.avg)",
            "[matrix.sort()](#fun_matrix.sort)"
          ],
          "syntax": [
            "matrix.min(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "matrix.min",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "max",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.max()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the maximum value in the matrix.\nvar x = matrix.max(m)\n\nplot(x, 'Matrix maximum value')"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.min()](#fun_matrix.min)",
            "[matrix.avg()](#fun_matrix.avg)",
            "[matrix.sort()](#fun_matrix.sort)"
          ],
          "syntax": [
            "matrix.max(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "matrix.max",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "max",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.max()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the maximum value in the matrix.\nvar x = matrix.max(m)\n\nplot(x, 'Matrix maximum value')"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.min()](#fun_matrix.min)",
            "[matrix.avg()](#fun_matrix.avg)",
            "[matrix.sort()](#fun_matrix.sort)"
          ],
          "syntax": [
            "matrix.max(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "matrix.max",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "avg",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.avg()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the average value of the matrix.\nvar x = matrix.avg(m)\n\nplot(x, 'Matrix average value')"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.avg(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "matrix.avg",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "avg",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.avg()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the average value of the matrix.\nvar x = matrix.avg(m)\n\nplot(x, 'Matrix average value')"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.avg(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "matrix.avg",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "median",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.median()` Example\")\n\n// Create a 2x2 matrix.\nm = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the median of the matrix.\nx = matrix.median(m)\n\nplot(x, 'Median of the matrix')"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.mode()](#fun_matrix.mode)",
            "[matrix.sort()](#fun_matrix.sort)",
            "[matrix.avg()](#fun_matrix.avg)"
          ],
          "syntax": [
            "matrix.median(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "matrix.median",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "median",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.median()` Example\")\n\n// Create a 2x2 matrix.\nm = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the median of the matrix.\nx = matrix.median(m)\n\nplot(x, 'Median of the matrix')"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.mode()](#fun_matrix.mode)",
            "[matrix.sort()](#fun_matrix.sort)",
            "[matrix.avg()](#fun_matrix.avg)"
          ],
          "syntax": [
            "matrix.median(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "matrix.median",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "mode",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.mode()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 0)\nmatrix.set(m, 0, 1, 0)\nmatrix.set(m, 1, 0, 1)\nmatrix.set(m, 1, 1, 1)\n\n// Get the mode of the matrix.\nvar x = matrix.mode(m)\n\nplot(x, 'Mode of the matrix')"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.median()](#fun_matrix.median)",
            "[matrix.sort()](#fun_matrix.sort)",
            "[matrix.avg()](#fun_matrix.avg)"
          ],
          "syntax": [
            "matrix.mode(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "matrix.mode",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "mode",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.mode()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 0)\nmatrix.set(m, 0, 1, 0)\nmatrix.set(m, 1, 0, 1)\nmatrix.set(m, 1, 1, 1)\n\n// Get the mode of the matrix.\nvar x = matrix.mode(m)\n\nplot(x, 'Mode of the matrix')"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.median()](#fun_matrix.median)",
            "[matrix.sort()](#fun_matrix.sort)",
            "[matrix.avg()](#fun_matrix.avg)"
          ],
          "syntax": [
            "matrix.mode(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "matrix.mode",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "transpose",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.transpose()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<float>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Create a transpose of the matrix.\n\tvar m2 = matrix.transpose(m1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Transposed matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)",
            "[matrix.reshape()](#fun_matrix.reshape)",
            "[matrix.reverse()](#fun_matrix.reverse)"
          ],
          "syntax": [
            "matrix.transpose(id) → matrix<type>"
          ],
          "returnedTypes": [
            "matrix<>"
          ],
          "originalName": "matrix.transpose",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "sum",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>"
              ],
              "displayType": "series int/float/matrix<int>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.sum()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(2, 3, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix that sums matrices `m1` and `m2`.\n\tvar m3 = matrix.sum(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Sum of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.sum()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix with values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix containing the sum of the `m1` matrix with the \"int\" value `1`.\n\tvar m2 = matrix.sum(m1, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Sum of a matrix and a scalar:\")\n\ttable.cell(t, 0, 1, str.tostring(m2))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.sum(id1, id2) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ],
          "originalName": "matrix.sum",
          "thisType": [
            "matrix<int>",
            "matrix<float>"
          ]
        },
        {
          "name": "sum",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "series int/float/matrix<int/float>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.sum()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(2, 3, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix that sums matrices `m1` and `m2`.\n\tvar m3 = matrix.sum(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Sum of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.sum()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix with values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix containing the sum of the `m1` matrix with the \"int\" value `1`.\n\tvar m2 = matrix.sum(m1, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Sum of a matrix and a scalar:\")\n\ttable.cell(t, 0, 1, str.tostring(m2))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.sum(id1, id2) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ],
          "originalName": "matrix.sum",
          "thisType": [
            "matrix<int>",
            "matrix<float>"
          ]
        },
        {
          "name": "diff",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>"
              ],
              "displayType": "series int/float/matrix<int>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.diff()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(2, 3, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix containing the difference between matrices `m1` and `m2`.\n\tvar m3 = matrix.diff(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Difference between two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.diff()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix with values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix containing the difference between the `m1` matrix and the \"int\" value `1`.\n\tvar m2 = matrix.diff(m1, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Difference between a matrix and a scalar:\")\n\ttable.cell(t, 0, 1, str.tostring(m2))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.diff(id1, id2) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ],
          "originalName": "matrix.diff",
          "thisType": [
            "matrix<int>",
            "matrix<float>"
          ]
        },
        {
          "name": "diff",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "series int/float/matrix<int/float>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.diff()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(2, 3, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix containing the difference between matrices `m1` and `m2`.\n\tvar m3 = matrix.diff(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Difference between two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.diff()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix with values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix containing the difference between the `m1` matrix and the \"int\" value `1`.\n\tvar m2 = matrix.diff(m1, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Difference between a matrix and a scalar:\")\n\ttable.cell(t, 0, 1, str.tostring(m2))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.diff(id1, id2) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ],
          "originalName": "matrix.diff",
          "thisType": [
            "matrix<int>",
            "matrix<float>"
          ]
        },
        {
          "name": "mult",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>"
              ],
              "displayType": "series int/float/matrix<int>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 6x2 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(6, 2, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\t// Note that it must have the same quantity of rows as there are columns in the first matrix.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix from the multiplication of the two matrices.\n\tvar m3 = matrix.mult(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Product of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix from the product of the two matrices.\n\tscalar = 5\n\tvar m2 = matrix.mult(m1, scalar)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Scalar:\")\n\ttable.cell(t, 2, 1, str.tostring(scalar))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 2:\")\n\ttable.cell(t, 4, 1, str.tostring(m2))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 3\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<int>(2, 3, 4)\n\n\t// Create an array of three elements.\n\tvar array<int> a = array.from(1, 1, 1)\n\n\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.\n\tvar m3 = matrix.mult(m1, a)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Value:\")\n\ttable.cell(t, 2, 1, str.tostring(a, \" \"))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 3:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.sum()](#fun_matrix.sum)",
            "[matrix.diff()](#fun_matrix.diff)"
          ],
          "syntax": [
            "matrix.mult(id1, id2) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ],
          "originalName": "matrix.mult",
          "thisType": [
            "matrix<int>",
            "matrix<float>"
          ]
        },
        {
          "name": "mult",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "series int/float/matrix<int/float>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 6x2 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(6, 2, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\t// Note that it must have the same quantity of rows as there are columns in the first matrix.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix from the multiplication of the two matrices.\n\tvar m3 = matrix.mult(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Product of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix from the product of the two matrices.\n\tscalar = 5\n\tvar m2 = matrix.mult(m1, scalar)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Scalar:\")\n\ttable.cell(t, 2, 1, str.tostring(scalar))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 2:\")\n\ttable.cell(t, 4, 1, str.tostring(m2))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 3\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<int>(2, 3, 4)\n\n\t// Create an array of three elements.\n\tvar array<int> a = array.from(1, 1, 1)\n\n\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.\n\tvar m3 = matrix.mult(m1, a)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Value:\")\n\ttable.cell(t, 2, 1, str.tostring(a, \" \"))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 3:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.sum()](#fun_matrix.sum)",
            "[matrix.diff()](#fun_matrix.diff)"
          ],
          "syntax": [
            "matrix.mult(id1, id2) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ],
          "originalName": "matrix.mult",
          "thisType": [
            "matrix<int>",
            "matrix<float>"
          ]
        },
        {
          "name": "mult",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 6x2 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(6, 2, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\t// Note that it must have the same quantity of rows as there are columns in the first matrix.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix from the multiplication of the two matrices.\n\tvar m3 = matrix.mult(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Product of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix from the product of the two matrices.\n\tscalar = 5\n\tvar m2 = matrix.mult(m1, scalar)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Scalar:\")\n\ttable.cell(t, 2, 1, str.tostring(scalar))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 2:\")\n\ttable.cell(t, 4, 1, str.tostring(m2))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 3\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<int>(2, 3, 4)\n\n\t// Create an array of three elements.\n\tvar array<int> a = array.from(1, 1, 1)\n\n\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.\n\tvar m3 = matrix.mult(m1, a)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Value:\")\n\ttable.cell(t, 2, 1, str.tostring(a, \" \"))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 3:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.sum()](#fun_matrix.sum)",
            "[matrix.diff()](#fun_matrix.diff)"
          ],
          "syntax": [
            "matrix.mult(id1, id2) → array<int>"
          ],
          "returnedTypes": [
            "array<int>"
          ],
          "originalName": "matrix.mult",
          "thisType": [
            "matrix<int>",
            "matrix<float>"
          ]
        },
        {
          "name": "mult",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 6x2 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(6, 2, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\t// Note that it must have the same quantity of rows as there are columns in the first matrix.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix from the multiplication of the two matrices.\n\tvar m3 = matrix.mult(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Product of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix from the product of the two matrices.\n\tscalar = 5\n\tvar m2 = matrix.mult(m1, scalar)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Scalar:\")\n\ttable.cell(t, 2, 1, str.tostring(scalar))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 2:\")\n\ttable.cell(t, 4, 1, str.tostring(m2))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 3\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<int>(2, 3, 4)\n\n\t// Create an array of three elements.\n\tvar array<int> a = array.from(1, 1, 1)\n\n\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.\n\tvar m3 = matrix.mult(m1, a)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Value:\")\n\ttable.cell(t, 2, 1, str.tostring(a, \" \"))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 3:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.sum()](#fun_matrix.sum)",
            "[matrix.diff()](#fun_matrix.diff)"
          ],
          "syntax": [
            "matrix.mult(id1, id2) → array<float>"
          ],
          "returnedTypes": [
            "array<float>"
          ],
          "originalName": "matrix.mult",
          "thisType": [
            "matrix<int>",
            "matrix<float>"
          ]
        },
        {
          "name": "pinv",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.pinv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Pseudoinverse of the matrix.\n\tvar m2 = matrix.pinv(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Pseudoinverse matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.inv()](#fun_matrix.inv)"
          ],
          "syntax": [
            "matrix.pinv(id) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ],
          "originalName": "matrix.pinv",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "pinv",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.pinv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Pseudoinverse of the matrix.\n\tvar m2 = matrix.pinv(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Pseudoinverse matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.inv()](#fun_matrix.inv)"
          ],
          "syntax": [
            "matrix.pinv(id) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ],
          "originalName": "matrix.pinv",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "inv",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.inv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Inverse of the matrix.\n\tvar m2 = matrix.inv(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Inverse matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.pinv()](#fun_matrix.pinv)",
            "[matrix.copy()](#fun_matrix.copy)",
            "[str.tostring()](#fun_str.tostring)"
          ],
          "syntax": [
            "matrix.inv(id) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ],
          "originalName": "matrix.inv",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "inv",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.inv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Inverse of the matrix.\n\tvar m2 = matrix.inv(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Inverse matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.pinv()](#fun_matrix.pinv)",
            "[matrix.copy()](#fun_matrix.copy)",
            "[str.tostring()](#fun_str.tostring)"
          ],
          "syntax": [
            "matrix.inv(id) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ],
          "originalName": "matrix.inv",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "rank",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.rank()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Get the rank of the matrix.\n\tr = matrix.rank(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Rank of the matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(r))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[str.tostring()](#fun_str.tostring)"
          ],
          "syntax": [
            "matrix.rank(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "matrix.rank",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "trace",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.trace()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Get the trace of the matrix.\n\ttr = matrix.trace(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Trace of the matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(tr))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.trace(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ],
          "originalName": "matrix.trace",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "trace",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.trace()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Get the trace of the matrix.\n\ttr = matrix.trace(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Trace of the matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(tr))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.trace(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "matrix.trace",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "eigenvalues",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.eigenvalues()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 2)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 6)\n\tmatrix.set(m1, 1, 1, 8)\n\n\t// Get the eigenvalues of the matrix.\n\ttr = matrix.eigenvalues(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Array of Eigenvalues:\")\n\ttable.cell(t, 1, 1, str.tostring(tr))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.eigenvectors()](#fun_matrix.eigenvectors)"
          ],
          "syntax": [
            "matrix.eigenvalues(id) → array<float>"
          ],
          "returnedTypes": [
            "array<float>"
          ],
          "originalName": "matrix.eigenvalues",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "eigenvalues",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.eigenvalues()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 2)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 6)\n\tmatrix.set(m1, 1, 1, 8)\n\n\t// Get the eigenvalues of the matrix.\n\ttr = matrix.eigenvalues(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Array of Eigenvalues:\")\n\ttable.cell(t, 1, 1, str.tostring(tr))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.eigenvectors()](#fun_matrix.eigenvectors)"
          ],
          "syntax": [
            "matrix.eigenvalues(id) → array<int>"
          ],
          "returnedTypes": [
            "array<int>"
          ],
          "originalName": "matrix.eigenvalues",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "eigenvectors",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.eigenvectors()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix\n\tvar m1 = matrix.new<int>(2, 2, 1)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 2)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 6)\n\tmatrix.set(m1, 1, 1, 8)\n\n\t// Get the eigenvectors of the matrix.\n\tm2 = matrix.eigenvectors(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix Elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix Eigenvectors:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.eigenvalues()](#fun_matrix.eigenvalues)"
          ],
          "syntax": [
            "matrix.eigenvectors(id) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ],
          "originalName": "matrix.eigenvectors",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "eigenvectors",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"`matrix.eigenvectors()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix\n\tvar m1 = matrix.new<int>(2, 2, 1)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 2)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 6)\n\tmatrix.set(m1, 1, 1, 8)\n\n\t// Get the eigenvectors of the matrix.\n\tm2 = matrix.eigenvectors(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix Elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix Eigenvectors:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.eigenvalues()](#fun_matrix.eigenvalues)"
          ],
          "syntax": [
            "matrix.eigenvectors(id) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ],
          "originalName": "matrix.eigenvectors",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "kron",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.kron()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n\t// Create two matrices with default values `1` and `2`.\n\tvar m1 = matrix.new<float>(2, 2, 1)\n\tvar m2 = matrix.new<float>(2, 2, 2)\n\n\t// Calculate the Kronecker product of the matrices.\n\tvar m3 = matrix.kron(m1, m2)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"⊗\")\n\ttable.cell(t, 2, 0, \"Matrix 2:\")\n\ttable.cell(t, 2, 1, str.tostring(m2))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Kronecker product:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.mult()](#fun_matrix.mult)",
            "[str.tostring()](#fun_str.tostring)",
            "[table.new()](#fun_table.new)"
          ],
          "syntax": [
            "matrix.kron(id1, id2) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ],
          "originalName": "matrix.kron",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "kron",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.kron()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n\t// Create two matrices with default values `1` and `2`.\n\tvar m1 = matrix.new<float>(2, 2, 1)\n\tvar m2 = matrix.new<float>(2, 2, 2)\n\n\t// Calculate the Kronecker product of the matrices.\n\tvar m3 = matrix.kron(m1, m2)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"⊗\")\n\ttable.cell(t, 2, 0, \"Matrix 2:\")\n\ttable.cell(t, 2, 1, str.tostring(m2))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Kronecker product:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.mult()](#fun_matrix.mult)",
            "[str.tostring()](#fun_str.tostring)",
            "[table.new()](#fun_table.new)"
          ],
          "syntax": [
            "matrix.kron(id1, id2) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ],
          "originalName": "matrix.kron",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "pow",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "power",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.pow()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, 2)\n\t// Calculate the power of three of the matrix.\n\tvar m2 = matrix.pow(m1, 3)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix³:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.mult()](#fun_matrix.mult)"
          ],
          "syntax": [
            "matrix.pow(id, power) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ],
          "originalName": "matrix.pow",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "pow",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "power",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.pow()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, 2)\n\t// Calculate the power of three of the matrix.\n\tvar m2 = matrix.pow(m1, 3)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix³:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.mult()](#fun_matrix.mult)"
          ],
          "syntax": [
            "matrix.pow(id, power) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ],
          "originalName": "matrix.pow",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "is_zero",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)"
          ],
          "syntax": [
            "matrix.is_zero(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "matrix.is_zero",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "is_identity",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.is_square()](#fun_matrix.is_square)",
            "[matrix.is_diagonal()](#fun_matrix.is_diagonal)"
          ],
          "syntax": [
            "matrix.is_identity(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "matrix.is_identity",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "is_binary",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)"
          ],
          "syntax": [
            "matrix.is_binary(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "matrix.is_binary",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "is_symmetric",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)"
          ],
          "syntax": [
            "matrix.is_symmetric(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "matrix.is_symmetric",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "is_antisymmetric",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)"
          ],
          "syntax": [
            "matrix.is_antisymmetric(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "matrix.is_antisymmetric",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "is_diagonal",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)",
            "[matrix.is_identity()](#fun_matrix.is_identity)",
            "[matrix.is_antidiagonal()](#fun_matrix.is_antidiagonal)"
          ],
          "syntax": [
            "matrix.is_diagonal(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "matrix.is_diagonal",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "is_antidiagonal",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)",
            "[matrix.is_identity()](#fun_matrix.is_identity)",
            "[matrix.is_diagonal()](#fun_matrix.is_diagonal)"
          ],
          "syntax": [
            "matrix.is_antidiagonal(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "matrix.is_antidiagonal",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "is_triangular",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)"
          ],
          "syntax": [
            "matrix.is_triangular(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "matrix.is_triangular",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "is_stochastic",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)"
          ],
          "syntax": [
            "matrix.is_stochastic(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "matrix.is_stochastic",
          "thisType": [
            "matrix<float>",
            "matrix<int>"
          ]
        },
        {
          "name": "is_square",
          "desc": [
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.is_square(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "matrix.is_square",
          "thisType": [
            "matrix<>"
          ]
        },
        {
          "name": "merge_cells",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "start_column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "start_row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "end_column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "end_row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"table.merge_cells example\")\nSMA50  = ta.sma(close, 50)\nSMA100 = ta.sma(close, 100)\nSMA200 = ta.sma(close, 200)\nif barstate.islast\n\tmaTable = table.new(position.bottom_right, 3, 3, bgcolor = color.gray, border_width = 1, border_color = color.black)\n\t// Header\n\ttable.cell(maTable, 0, 0, text = \"SMA Table\")\n\ttable.merge_cells(maTable, 0, 0, 2, 0)\n\t// Cell Titles\n\ttable.cell(maTable, 0, 1, text = \"SMA 50\")\n\ttable.cell(maTable, 1, 1, text = \"SMA 100\")\n\ttable.cell(maTable, 2, 1, text = \"SMA 200\")\n\t// Values\n\ttable.cell(maTable, 0, 2, bgcolor = color.white, text = str.tostring(SMA50))\n\ttable.cell(maTable, 1, 2, bgcolor = color.white, text = str.tostring(SMA100))\n\ttable.cell(maTable, 2, 2, bgcolor = color.white, text = str.tostring(SMA200))"
          ],
          "remarks": [
            "",
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)"
          ],
          "syntax": [
            "table.merge_cells(table_id, start_column, start_row, end_column, end_row) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "table.merge_cells",
          "thisType": [
            "series table"
          ]
        },
        {
          "name": "copy",
          "desc": [
            ""
          ],
          "args": [],
          "syntax": [
            "chart.point.copy(id) → chart.point"
          ],
          "returnedTypes": [
            "chart.point"
          ],
          "originalName": "chart.point.copy",
          "thisType": [
            "chart.point"
          ]
        },
        {
          "name": "set_first_point",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            }
          ],
          "syntax": [
            "line.set_first_point(id, point) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_first_point",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_second_point",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            }
          ],
          "syntax": [
            "line.set_second_point(id, point) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "line.set_second_point",
          "thisType": [
            "series line"
          ]
        },
        {
          "name": "set_point",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            }
          ],
          "syntax": [
            "label.set_point(id, point) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "label.set_point",
          "thisType": [
            "series label"
          ]
        },
        {
          "name": "set_top_left_point",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            }
          ],
          "syntax": [
            "box.set_top_left_point(id, point) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_top_left_point",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "set_bottom_right_point",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            }
          ],
          "syntax": [
            "box.set_bottom_right_point(id, point) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "box.set_bottom_right_point",
          "thisType": [
            "series box"
          ]
        },
        {
          "name": "copy",
          "desc": [
            ""
          ],
          "returns": [
            ""
          ],
          "args": [],
          "syntax": [
            "map.copy(id) → map<keyType, valueType>"
          ],
          "examples": [
            "//@version=6\nindicator(\"map.copy example\")\na = map.new<string, int>()\na.put(\"example\", 1)\nb = map.copy(a)\na := map.new<string, int>()\na.put(\"example\", 2)\nplot(a.get(\"example\"))\nplot(b.get(\"example\"))"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.get()](#fun_map.get)",
            "[map.size()](#fun_map.size)"
          ],
          "originalName": "map.copy",
          "thisType": [
            "map<>"
          ]
        },
        {
          "name": "size",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"map.size example\")\na = map.new<int, int>()\nsize = 10\nfor i = 0 to size\n\ta.put(i, size-i)\nplot(map.size(a))"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.get()](#fun_map.get)"
          ],
          "syntax": [
            "map.size(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ],
          "originalName": "map.size",
          "thisType": [
            "map<>"
          ]
        },
        {
          "name": "get",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "key",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the map's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.get example\")\na = map.new<int, int>()\nsize = 10\nfor i = 0 to size\n\ta.put(i, size-i)\nplot(map.get(a, 1))"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.contains()](#fun_map.contains)"
          ],
          "syntax": [
            "map.get(id, key) → <value_type>"
          ],
          "returnedTypes": [],
          "originalName": "map.get",
          "thisType": [
            "map<>"
          ]
        },
        {
          "name": "contains",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "key",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the map's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.includes example\")\na = map.new<string, float>()\na.put(\"open\", open)\np = close\nif map.contains(a, \"open\")\n\tp := a.get(\"open\")\nplot(p)"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.size()](#fun_map.size)"
          ],
          "syntax": [
            "map.contains(id, key) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ],
          "originalName": "map.contains",
          "thisType": [
            "map<>"
          ]
        },
        {
          "name": "keys",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"map.keys example\")\na = map.new<string, float>()\na.put(\"open\", open)\na.put(\"high\", high)\na.put(\"low\", low)\na.put(\"close\", close)\nkeys = map.keys(a)\nohlc = 0.0\nfor key in keys\n\tohlc += a.get(key)\nplot(ohlc/4)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.get()](#fun_map.get)",
            "[map.values()](#fun_map.values)",
            "[map.size()](#fun_map.size)"
          ],
          "syntax": [
            "map.keys(id) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ],
          "originalName": "map.keys",
          "thisType": [
            "map<>"
          ]
        },
        {
          "name": "values",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"map.values example\")\na = map.new<string, float>()\na.put(\"open\", open)\na.put(\"high\", high)\na.put(\"low\", low)\na.put(\"close\", close)\nvalues = map.values(a)\nohlc = 0.0\nfor value in values\n\tohlc += value\nplot(ohlc/4)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.get()](#fun_map.get)",
            "[map.keys()](#fun_map.keys)",
            "[map.size()](#fun_map.size)"
          ],
          "syntax": [
            "map.values(id) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ],
          "originalName": "map.values",
          "thisType": [
            "map<>"
          ]
        },
        {
          "name": "put",
          "desc": [
            ""
          ],
          "returns": [
            ""
          ],
          "args": [
            {
              "name": "key",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the map's elements>"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the map's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.put example\")\na = map.new<string, float>()\nmap.put(a, \"first\", 10)\nmap.put(a, \"second\", 15)\nprevFirst = map.put(a, \"first\", 20)\ncurrFirst = a.get(\"first\")\nplot(prevFirst)\nplot(currFirst)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put_all()](#fun_map.put_all)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.remove()](#fun_map.remove)"
          ],
          "syntax": [
            "map.put(id, key, value) → <value_type>"
          ],
          "returnedTypes": [],
          "originalName": "map.put",
          "thisType": [
            "map<>"
          ]
        },
        {
          "name": "put_all",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "map<>"
              ],
              "displayType": "any map type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.put_all example\")\na = map.new<string, float>()\nb = map.new<string, float>()\na.put(\"first\", 10)\na.put(\"second\", 15)\nb.put(\"third\", 20)\nmap.put_all(a, b)\nplot(a.get(\"third\"))"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.remove()](#fun_map.remove)"
          ],
          "syntax": [
            "map.put_all(id, id2) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "map.put_all",
          "thisType": [
            "map<>"
          ]
        },
        {
          "name": "remove",
          "desc": [
            ""
          ],
          "returns": [
            ""
          ],
          "args": [
            {
              "name": "key",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the map's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.remove example\")\na = map.new<string, color>()\na.put(\"firstColor\", color.green)\noldColorValue = map.remove(a, \"firstColor\")\nplot(close, color = oldColorValue)"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.clear()](#fun_map.clear)"
          ],
          "syntax": [
            "map.remove(id, key) → <value_type>"
          ],
          "returnedTypes": [],
          "originalName": "map.remove",
          "thisType": [
            "map<>"
          ]
        },
        {
          "name": "clear",
          "desc": [
            ""
          ],
          "args": [],
          "examples": [
            "//@version=6\nindicator(\"map.clear example\")\noddMap = map.new<int, bool>()\noddMap.put(1, true)\noddMap.put(2, false)\noddMap.put(3, true)\nmap.clear(oddMap)\nplot(oddMap.size())"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put_all()](#fun_map.put_all)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.remove()](#fun_map.remove)"
          ],
          "syntax": [
            "map.clear(id) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "map.clear",
          "thisType": [
            "map<>"
          ]
        },
        {
          "name": "delete",
          "desc": [
            ""
          ],
          "args": [],
          "syntax": [
            "polyline.delete(id) → void"
          ],
          "returnedTypes": [
            "void"
          ],
          "originalName": "polyline.delete",
          "thisType": [
            "series polyline"
          ]
        }
      ]
    }
  ],
  "controls": [
    {
      "title": "Control-Flow Keyword",
      "docs": [
        {
          "name": "or",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 or expr2"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": "and",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 and expr2"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": "not",
          "desc": [
            ""
          ],
          "syntax": [
            "not expr1"
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": "if",
          "desc": [
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "var_declarationX = if condition\n    var_decl_then0\n    var_decl_then1\n    …\n    var_decl_thenN\nelse if [optional block]\n    var_decl_else0\n    var_decl_else1\n    …\n    var_decl_elseN\nelse\n    var_decl_else0\n    var_decl_else1\n    …\n    var_decl_elseN\n    return_expression_else"
          ],
          "detailedDesc": [
            {
              "desc": [
                "",
                "",
                "",
                "",
                "",
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"if\")\n// This code compiles\nx = if close > open\n    close\nelse\n    open\n\n// This code doesn’t compile\n// y = if close > open\n//     close\n// else\n//     \"open\"\nplot(x)"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"if\")\nx = if close > open\n    close\n// If current close > current open, then x = close.\n// Otherwise the x = na.\nplot(x)"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"if\")\nx = if open > close\n    5\nelse if high > low\n    close\nelse\n    open\nplot(x)"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nstrategy(\"if\")\nif (ta.crossover(high, low))\n    strategy.entry(\"BBandLE\", strategy.long, stop=low, oca_name=\"BollingerBands\", oca_type=strategy.oca.cancel, comment=\"BBandLE\")\nelse\n    strategy.cancel(id=\"BBandLE\")"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"if\")\nfloat x = na\nif close > open\n    if close > close[1]\n        x := close\n    else\n        x := close[1]\nelse\n    x := open\nplot(x)"
              ]
            }
          ]
        },
        {
          "name": "switch",
          "desc": [
            ""
          ],
          "syntax": [
            "[variable_declaration = ] switch expression\n    value1 => local_block\n    value2 => local_block\n    …\n    => default_local_block\n\n[variable_declaration = ] switch\n    condition1 => local_block\n    condition2 => local_block\n    …\n    => default_local_block"
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Switch using an expression\")\n\nstring i_maType = input.string(\"EMA\", \"MA type\", options = [\"EMA\", \"SMA\", \"RMA\", \"WMA\"])\n\nfloat ma = switch i_maType\n\t\"EMA\" => ta.ema(close, 10)\n\t\"SMA\" => ta.sma(close, 10)\n\t\"RMA\" => ta.rma(close, 10)\n\t// Default used when the three first cases do not match.\n\t=> ta.wma(close, 10)\n\nplot(ma)"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nstrategy(\"Switch without an expression\", overlay = true)\n\nbool longCondition  = ta.crossover( ta.sma(close, 14), ta.sma(close, 28))\nbool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\n\nswitch\n\tlongCondition  => strategy.entry(\"Long ID\", strategy.long)\n\tshortCondition => strategy.entry(\"Short ID\", strategy.short)"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[if](#kw_if)",
            "[?:](#op_?:)"
          ]
        },
        {
          "name": "for",
          "desc": [
            ""
          ],
          "syntax": [
            "[variables =|:=] for counter = from_num to to_num [by step_num]\n    statements | continue | break\n    return_expression"
          ],
          "detailedDesc": [
            {
              "desc": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Basic `for` loop\")\n\n//@function Calculates the number of bars in the last `length` bars that have their `close` above the current `close`.\n//@param length The number of bars used in the calculation.\ngreaterCloseCount(length) =>\n\tint result = 0\n\tfor i = 1 to length\n\t\tif close[i] > close\n\t\t\tresult += 1\n\tresult\n\nplot(greaterCloseCount(14))"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"`for` loop with a step\")\n\na = array.from(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\nsum = 0.0\n\nfor i = 0 to 9 by 5\n\t// Because the step is set to 5, we are adding only the first (0) and the sixth (5) value from the array `a`.\n\tsum += array.get(a, i)\n\nplot(sum)"
              ]
            }
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[for...in](#kw_for...in)",
            "[while](#kw_while)"
          ]
        },
        {
          "name": "for...in",
          "desc": [
            ""
          ],
          "syntax": [
            "[variables = | :=] for item in collection_id\n    statements | continue | break\n    return_expression\n\n[variables = | :=] for [index, item] in collection_id\n    statements | continue | break\n    return_expression"
          ],
          "detailedDesc": [
            {
              "desc": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"'for...in' array (first form) demo\")\n\n//@function Counts the number of 'id' array elements that are greater than the specified value. \nnumGreaterThan(array<float> id, float value) =>\n    int result = 0\n    for element in id\n        if element > value\n            result += 1\n    result\n\n//@variable References an array containing the current bar's OHLC values. \narray<float> ohlcValues = array.from(open, high, low, close)\n\n// Plot the number of 'ohlcValues' elements that are greater than the 20-bar SMA of 'close'. \nplot(numGreaterThan(ohlcValues, ta.sma(close, 20)))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`for...in` array (second form) demo\")\n\n//@function Creates a new array whose elements are the sums of corresponding elements in the `id1` and `id2` arrays. \nelementWiseAdd(array<float> id1, array<float> id2) =>\n    array<float> result = array.new<float>()\n    // Loop through the `id1` array while tracking each element's index *and* value.\n    for [index, element1] in id1\n        // Use `index` to retrieve the corresponding element in the `id2` array, then push the sum into the new array.\n        float element2 = id2.get(index)\n        result.push(element1 + element2)\n    result\n\nif barstate.isfirst\n    // Create two arrays for which to perform element-wise addition.\n    array<float> array1 = array.from(1.0, 2.0, 3.0, 4.0)\n    array<float> array2 = array.from(2.0, 3.0, 4.0, 5.0)\n\n    //@variable References the resulting array of element-wise sums. \n    array<float> sums = elementWiseAdd(array1, array2)\n    // Log a string representation of the `sums` array's contents in the Pine Logs pane. \n    log.info(str.tostring(sums))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`for...in` matrix (first form) demo\")\n\n//@function Creates a matrix that organizes the contents of the `arrayID` array into a specified shape.\nmatrixFromArray(array<float> arrayID, int rows, int columns) =>\n    matrix<float> result = matrix.new<float>()\n    result.add_row(0, arrayID)\n    result.reshape(rows, columns)\n    result\n\n//@function Creates an array containing the sum of elements in each row of the `matrixID` matrix.\ncalcRowSums(matrix<float> matrixID) =>\n    array<float> result = array.new<float>()\n    // Iterate over the matrix rows, where `rowArrayID` references an *array* containing the current row's values. \n    for rowArrayID in matrixID\n        // Push the sum of `rowArrayID` elements into the `result` array. \n        result.push(rowArrayID.sum())\n    result\n    \nif barstate.isfirst\n    // Create a 2x2 matrix of pseudorandom values.\n    array<float>  randArray = array.from(math.random(), math.random(), math.random(), math.random())  \n    matrix<float> randMat   = matrixFromArray(randArray, 2, 2)\n    // Log string representation of the `randMat` matrix and the calculated array of row sums in the Pine Logs pane.\n    log.info(\"\\n\" + str.tostring(randMat))\n    log.info(str.tostring(calcRowSums(randMat)))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`for...in` map demo\")\n\n//@function Creates a custom string representation of a map containing \"string\" keys and \"float\" values. \ntoString(map<string, float> id) =>\n    string result = \"{\"\n    // Iterate through the key-value pairs of the `id` map, in insertion order. \n    for [key, value] in id\n        result += str.format(\"''{0}'': {1}, \", key, value)\n    result += \"}\"\n    result := str.replace(result, \", }\", \"}\")\n\nif barstate.islastconfirmedhistory\n    //@variable References a map to store \"float\" OHLC values with corresponding \"string\" keys. \n    map<string, float> ohlcMap = map.new<string, float>()\n    // Put key-value pairs into the map. \n    ohlcMap.put(\"Open\",  open)\n    ohlcMap.put(\"High\",  high)\n    ohlcMap.put(\"Low\",   low)\n    ohlcMap.put(\"Close\", close)\n    // Log the `toString()` result for the map referenced by `ohlcMap`.\n    log.info(toString(ohlcMap))"
              ]
            }
          ],
          "remarks": [
            "",
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[for](#kw_for)",
            "[while](#kw_while)",
            "[array.sum()](#fun_array.sum)",
            "[array.min()](#fun_array.min)",
            "[array.max()](#fun_array.max)"
          ]
        },
        {
          "name": "while",
          "desc": [
            ""
          ],
          "syntax": [
            "[variables = | :=] while condition\n    statements | continue | break\n    return_expression"
          ],
          "detailedDesc": [
            {
              "desc": [
                "",
                "",
                "",
                "",
                "",
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`while` demo\")\n\n//@variable The number for which to calculate the factorial (N!).\n//          The factorial is the product of all integers from 1 to `n`, with the exception (0! == 1).\nint n = input.int(10, \"N\", 0)\n\n//@variable The current value to multiply in the factorial calculation. \nvar int counter = n\n//@variable The factorial value.\nvar int factorial = 1\n\nif barstate.isfirst\n    // Repeatedly multiply `factorial` by `counter` and decrease the `counter` value by 1.\n    // The loop ends after the value of `counter` becomes 0.  \n    while counter > 0\n        factorial *= counter\n        counter   -= 1\n\nplot(factorial, \"N!\")"
              ]
            }
          ],
          "remarks": [
            "",
            ""
          ]
        },
        {
          "name": "var",
          "desc": [
            "",
            ""
          ],
          "syntax": [
            "var variable_name = expression"
          ],
          "detailedDesc": [
            {
              "desc": [
                "",
                "",
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Var keyword example\")\nvar a = close\nvar b = 0.0\nvar c = 0.0\nvar green_bars_count = 0\nif close > open\n\tvar x = close\n\tb := x\n\tgreen_bars_count := green_bars_count + 1\n\tif green_bars_count >= 10\n\t\tvar y = close\n\t\tc := y\nplot(a)\nplot(b)\nplot(c)"
              ]
            },
            {
              "desc": [
                "",
                "",
                ""
              ]
            }
          ]
        },
        {
          "name": "varip",
          "desc": [
            ""
          ],
          "syntax": [
            "varip [<variable_type> ]<variable_name> = <expression>\n\n[export ]type <UDT_identifier>\n    varip <field_type> <field_name> [= <value>]"
          ],
          "detailedDesc": [
            {
              "desc": [
                "",
                "",
                "",
                "",
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"varip\")\nvarip int v = -1\nv := v + 1\nplot(v)"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"varip with types\")\ntype barData\n    int index = -1\n    varip int ticks = -1\n\nvar currBar = barData.new()\ncurrBar.index += 1\ncurrBar.ticks += 1\n\n// Will be equal to bar_index on all bars\nplot(currBar.index)\n// In real time, will increment per every tick on the chart\nplot(currBar.ticks)"
              ]
            },
            {
              "desc": [
                ""
              ]
            }
          ],
          "remarks": [
            "",
            ""
          ]
        },
        {
          "name": "import",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "username",
              "desc": "",
              "displayType": "literal string"
            },
            {
              "name": "libraryName",
              "desc": "",
              "displayType": "literal string"
            },
            {
              "name": "libraryVersion",
              "desc": "",
              "displayType": "literal int"
            },
            {
              "name": "alias",
              "desc": "",
              "displayType": "literal string"
            }
          ],
          "syntax": [
            "import {username}/{libraryName}/{libraryVersion} as {alias}"
          ],
          "examples": [
            "//@version=6\nindicator(\"num_methods import\")\n// Import the first version of the username’s \"num_methods\" library and assign it to the \"m\" namespace\",\nimport username/num_methods/1 as m\n// Call the “sinh()” function from the imported library\ny = m.sinh(3.14)\n// Plot value returned by the \"sinh()\" function\",\nplot(y)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[library()](#fun_library)",
            "[export](#kw_export)"
          ]
        },
        {
          "name": "enum",
          "desc": [
            "",
            "",
            ""
          ],
          "syntax": [
            "[export ]enum <enumName> \n<field_1> [= <title_1>] \n<field_2> [= <title_2>] \n... \n<field_N> [= <title_N>]"
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Session highlight\", overlay = true)\n\n//@enum       Contains fields with popular timezones as titles.\n//@field exch Has an empty string as the title to represent the chart timezone.\nenum tz\n\tutc  = \"UTC\"\n\texch = \"\"\n\tny   = \"America/New_York\"\n\tchi  = \"America/Chicago\"\n\tlon  = \"Europe/London\"\n\ttok  = \"Asia/Tokyo\"\n\n//@variable The session string.\nselectedSession = input.session(\"1200-1500\", \"Session\")\n//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.\nselectedTimezone = input.enum(tz.utc, \"Session Timezone\")\n\n//@variable Is `true` if the current bar's time is in the specified session.\nbool inSession = false\nif not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))\n\tinSession := true\n\n// Highlight the background when `inSession` is `true`.\nbgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Map with enum keys\")\n\n//@enum        Contains fields with titles representing ticker IDs.\n//@field aapl  Has an Apple ticker ID as its title.\n//@field tsla  Has a Tesla ticker ID as its title.\n//@field amzn  Has an Amazon ticker ID as its title.\nenum symbols\n\taapl = \"NASDAQ:AAPL\"\n    tsla = \"NASDAQ:TSLA\"\n    amzn = \"NASDAQ:AMZN\"\n\n//@variable A map that accepts fields from the `symbols` enum as keys and \"float\" values.\nmap<symbols, float> data = map.new<symbols, float>()\n// Put key-value pairs into the `data` map.\ndata.put(symbols.aapl, request.security(str.tostring(symbols.aapl), timeframe.period, close))\ndata.put(symbols.tsla, request.security(str.tostring(symbols.tsla), timeframe.period, close))\ndata.put(symbols.amzn, request.security(str.tostring(symbols.amzn), timeframe.period, close))\n// Plot the value from the `data` map accessed by the `symbols.aapl` key.\nplot(data.get(symbols.aapl))"
              ]
            }
          ]
        },
        {
          "name": "export",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\n//@description Library of debugging functions.\nlibrary(\"Debugging_library\", overlay = true)\n//@function Displays a string as a table cell for debugging purposes.\n//@param txt String to display.\n//@returns Void.\nexport print(string txt) =>\n\tvar table t = table.new(position.middle_right, 1, 1)\n\ttable.cell(t, 0, 0, txt, bgcolor = color.yellow)\n// Using the function from inside the library to show an example on the published chart.\n// This has no impact on scripts using the library.\nprint(\"Library Test\")"
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[library()](#fun_library)",
            "[import](#kw_import)",
            "[simple](#type_simple)",
            "[series](#type_series)",
            "[type](#kw_type)"
          ]
        },
        {
          "name": "type",
          "desc": [
            ""
          ],
          "syntax": [
            "[export ]type <UDT_identifier>\n    [varip ]<field_type> <field_name> [= <value>]\n    …"
          ],
          "detailedDesc": [
            {
              "desc": [
                "",
                "",
                "",
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Multi Time Period Chart\", overlay = true)\n\ntimeframeInput = input.timeframe(\"1D\")\n\ntype bar\n    float o = open\n    float h = high\n    float l = low\n    float c = close\n    int   t = time\n\ndrawBox(bar b, right) =>\n    color boxColor = b.c >= b.o ? color.green : color.red\n    box.new(b.t, b.h, right, b.l, boxColor, xloc = xloc.bar_time, bgcolor = color.new(boxColor, 90))\n\nupdateBox(box boxId, bar b) =>\n    color boxColor = b.c >= b.o ? color.green : color.red\n    box.set_border_color(boxId, boxColor)\n    box.set_bgcolor(boxId, color.new(boxColor, 90))\n    box.set_top(boxId, b.h)\n    box.set_bottom(boxId, b.l)\n    box.set_right(boxId, time)\n\nsecBar = request.security(syminfo.tickerid, timeframeInput, bar.new())\n\nif not na(secBar)\n    // To avoid a runtime error, only process data when an object exists.\n    if not barstate.islast\n        if timeframe.change(timeframeInput)\n            // On historical bars, draw a new box in the past when the HTF closes.\n            drawBox(secBar, time[1])\n    else\n        var box lastBox = na\n        if na(lastBox) or timeframe.change(timeframeInput)\n            // On the last bar, only draw a new current box the first time we get there or when HTF changes.\n            lastBox := drawBox(secBar, time)\n        else\n            // On other chart updates, use setters to modify the current box.\n            updateBox(lastBox, secBar)"
              ]
            }
          ]
        },
        {
          "name": "method",
          "desc": [
            "",
            ""
          ],
          "syntax": [
            "[export] method <functionName>(<paramType> <paramName> [= <defaultValue>], …) =>\n    <functionBlock>"
          ],
          "examples": [
            "//@version=6\nindicator(\"\")\n\nvar prices = array.new<float>()\n\n//@function Pushes a new value into the array and removes the first one if the resulting array is greater than `maxSize`. Can be used as a method.\nmethod maintainArray(array<float> id, maxSize, value) =>\n    id.push(value)\n    if id.size() > maxSize\n        id.shift()\n\nprices.maintainArray(50, close)\n// The method can also be called like a function, without using dot notation.\n// In this case an argument must be supplied for its first parameter.\n// maintainArray(prices, 50, close)\n\n// This calls the `array.avg()` built-in using dot notation with the `prices` array.\n// It is possible because built-in functions belonging to some namespaces that are a special Pine type\n// can be invoked with method notation when the function's first parameter is an ID of that type.\n// Those namespaces are: `array`, `matrix`, `line`, `linefill`, `label`, `box`, and `table`.\nplot(prices.avg())"
          ]
        },
        {
          "name": "else"
        },
        {
          "name": "to"
        },
        {
          "name": "by"
        },
        {
          "name": "break"
        },
        {
          "name": "continue"
        },
        {
          "name": "as"
        },
        {
          "name": "in"
        }
      ]
    }
  ],
  "variables": [
    {
      "title": "Built-in Variable",
      "docs": [
        {
          "name": "session.isfirstbar",
          "type": "series bool",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nstrategy(\"`session.isfirstbar` Example\", overlay = true)\nlongCondition = year >= 2022\n// Place a long order at the `close` of the trading session's first bar.\nif session.isfirstbar and longCondition\n    strategy.entry(\"Long\", strategy.long)\n\n// Close the long position at the `close` of the trading session's last bar.\nif session.islastbar and barstate.isconfirmed\n    strategy.close(\"Long\", immediately = true)"
          ],
          "seeAlso": [
            "[session.isfirstbar_regular](#var_session.isfirstbar_regular)",
            "[session.islastbar](#var_session.islastbar)",
            "[session.islastbar_regular](#var_session.islastbar_regular)"
          ]
        },
        {
          "name": "session.islastbar",
          "type": "series bool",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nstrategy(\"`session.islastbar` Example\", overlay = true)\nlongCondition = year >= 2022\n// Place a long order at the `close` of the trading session's last bar.\n// The position will enter on the `open` of next session's first bar.\nif session.islastbar and longCondition\n    strategy.entry(\"Long\", strategy.long)\n // Close 'Long' position at the close of the last bar of the trading session\nif session.islastbar and barstate.isconfirmed\n    strategy.close(\"Long\", immediately = true)"
          ],
          "seeAlso": [
            "[session.isfirstbar](#var_session.isfirstbar)",
            "[session.islastbar_regular](#var_session.islastbar_regular)"
          ],
          "remarks": [
            "",
            ""
          ]
        },
        {
          "name": "session.isfirstbar_regular",
          "type": "series bool",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nstrategy(\"`session.isfirstbar_regular` Example\", overlay = true)\nlongCondition = year >= 2022\n// Place a long order at the `close` of the trading session's first bar.\nif session.isfirstbar and longCondition\n    strategy.entry(\"Long\", strategy.long)\n// Close the long position at the `close` of the trading session's last bar.\nif session.islastbar_regular and barstate.isconfirmed\n    strategy.close(\"Long\", immediately = true)"
          ],
          "seeAlso": [
            "[session.isfirstbar](#var_session.isfirstbar)",
            "[session.islastbar](#var_session.islastbar)"
          ]
        },
        {
          "name": "session.islastbar_regular",
          "type": "series bool",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nstrategy(\"`session.islastbar_regular` Example\", overlay = true)\nlongCondition = year >= 2022\n// Place a long order at the `close` of the trading session's first bar.\nif session.isfirstbar and longCondition\n    strategy.entry(\"Long\", strategy.long)\n// Close the long position at the `close` of the trading session's last bar.\nif session.islastbar_regular and barstate.isconfirmed\n    strategy.close(\"Long\", immediately = true)"
          ],
          "seeAlso": [
            "[session.isfirstbar](#var_session.isfirstbar)",
            "[session.islastbar](#var_session.islastbar)",
            "[session.isfirstbar_regular](#var_session.isfirstbar_regular)"
          ],
          "remarks": [
            "",
            ""
          ]
        },
        {
          "name": "bar_index",
          "type": "series int",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"bar_index\")\nplot(bar_index)\nplot(bar_index > 5000 ? close : 0)"
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[last_bar_index](#var_last_bar_index)",
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.isrealtime](#var_barstate.isrealtime)"
          ]
        },
        {
          "name": "last_bar_index",
          "type": "series int",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nstrategy(\"Mark Last X Bars For Backtesting\", overlay = true, calc_on_every_tick = true)\nlastBarsFilterInput = input.int(100, \"Bars Count:\")\n// Here, we store the 'last_bar_index' value that is known from the beginning of the script's calculation.\n// The 'last_bar_index' will change when new real-time bars appear, so we declare 'lastbar' with the 'var' keyword.\nvar lastbar = last_bar_index\n// Check if the current bar_index is 'lastBarsFilterInput' removed from the last bar on the chart, or the chart is traded in real-time.\nallowedToTrade = (lastbar - bar_index <= lastBarsFilterInput) or barstate.isrealtime\nbgcolor(allowedToTrade ? color.new(color.green, 80) : na)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[bar_index](#var_bar_index)",
            "[last_bar_time](#var_last_bar_time)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isrealtime](#var_barstate.isrealtime)"
          ]
        },
        {
          "name": "last_bar_time",
          "type": "series int",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[time](#var_time)",
            "[timenow](#var_timenow)",
            "[timestamp()](#fun_timestamp)",
            "[last_bar_index](#var_last_bar_index)"
          ]
        },
        {
          "name": "na",
          "type": "simple na",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"na\")\n// CORRECT\n// Plot no value when on bars zero to nine. Plot `close` on other bars.\nplot(bar_index < 10 ? na : close)\n// CORRECT ALTERNATIVE\n// Initialize `a` to `na`. Reassign `close` to `a` on bars 10 and later.\nfloat a = na\nif bar_index >= 10\n\ta := close\nplot(a)\n\n// INCORRECT\n// Trying to test the preceding bar's `close` for `na`.\n// The next line, if uncommented, will cause a compilation error, because direct comparison with `na` is not allowed.\n// plot(close[1] == na ? close : close[1])\n// CORRECT\n// Use the `na()` function to test for `na`.\nplot(na(close[1]) ? close : close[1])\n// CORRECT ALTERNATIVE\n// `nz()` tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.\nplot(nz(close[1], close))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[na()](#fun_na)",
            "[nz()](#fun_nz)",
            "[fixnan()](#fun_fixnan)"
          ]
        },
        {
          "name": "volume",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[time()](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)",
            "[ask](#var_ask)",
            "[bid](#var_bid)"
          ]
        },
        {
          "name": "open",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[high](#var_high)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time()](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)",
            "[ask](#var_ask)",
            "[bid](#var_bid)"
          ]
        },
        {
          "name": "high",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[open](#var_open)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time()](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)",
            "[ask](#var_ask)",
            "[bid](#var_bid)"
          ]
        },
        {
          "name": "low",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time()](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)",
            "[ask](#var_ask)",
            "[bid](#var_bid)"
          ]
        },
        {
          "name": "close",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[volume](#var_volume)",
            "[time()](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)",
            "[ask](#var_ask)",
            "[bid](#var_bid)"
          ]
        },
        {
          "name": "hl2",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time()](#fun_time)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)",
            "[ask](#var_ask)",
            "[bid](#var_bid)"
          ]
        },
        {
          "name": "hlc3",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time()](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)",
            "[ask](#var_ask)",
            "[bid](#var_bid)"
          ]
        },
        {
          "name": "hlcc4",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time()](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[ohlc4](#var_ohlc4)",
            "[ask](#var_ask)",
            "[bid](#var_bid)"
          ]
        },
        {
          "name": "ohlc4",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[close](#var_close)",
            "[volume](#var_volume)",
            "[time()](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)"
          ]
        },
        {
          "name": "ask",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[volume](#var_volume)",
            "[time()](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)",
            "[bid](#var_bid)"
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "bid",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[open](#var_open)",
            "[high](#var_high)",
            "[low](#var_low)",
            "[volume](#var_volume)",
            "[time()](#fun_time)",
            "[hl2](#var_hl2)",
            "[hlc3](#var_hlc3)",
            "[hlcc4](#var_hlcc4)",
            "[ohlc4](#var_ohlc4)",
            "[ask](#var_ask)"
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "ta.vwap",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[ta.vwap()](#fun_ta.vwap)"
          ]
        },
        {
          "name": "ta.accdist",
          "type": "series float",
          "desc": [
            ""
          ]
        },
        {
          "name": "ta.tr",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[ta.tr()](#fun_ta.tr)",
            "[ta.atr()](#fun_ta.atr)"
          ]
        },
        {
          "name": "ta.iii",
          "type": "series float",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"Intraday Intensity Index\")\nplot(ta.iii, color=color.yellow)\n\n// the same on pine\nf_iii() =>\n    (2 * close - high - low) / ((high - low) * volume)\n\nplot(f_iii())"
          ]
        },
        {
          "name": "ta.wvad",
          "type": "series float",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"Williams Variable Accumulation/Distribution\")\nplot(ta.wvad, color=color.yellow)\n\n// the same on pine\nf_wvad() =>\n    (close - open) / (high - low) * volume\n\nplot(f_wvad())"
          ]
        },
        {
          "name": "ta.wad",
          "type": "series float",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"Williams Accumulation/Distribution\")\nplot(ta.wad, color=color.yellow)\n\n// the same on pine\nf_wad() =>\n    trueHigh = math.max(high, close[1])\n    trueLow = math.min(low, close[1])\n    mom = ta.change(close)\n    gain = (mom > 0) ? close - trueLow : (mom < 0) ? close - trueHigh : 0\n    ta.cum(gain)\n\nplot(f_wad())"
          ]
        },
        {
          "name": "ta.obv",
          "type": "series float",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"On Balance Volume\")\nplot(ta.obv, color=color.yellow)\n\n// the same on pine\nf_obv() =>\n    ta.cum(math.sign(ta.change(close)) * volume)\n\nplot(f_obv())"
          ]
        },
        {
          "name": "ta.pvt",
          "type": "series float",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"Price-Volume Trend\")\nplot(ta.pvt, color=color.yellow)\n\n// the same on pine\nf_pvt() =>\n    ta.cum((ta.change(close) / close[1]) * volume)\n\nplot(f_pvt())"
          ]
        },
        {
          "name": "ta.nvi",
          "type": "series float",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"Negative Volume Index\")\n\nplot(ta.nvi, color=color.yellow)\n\n// the same on pine\nf_nvi() =>\n    float ta_nvi = 1.0\n    float prevNvi = (nz(ta_nvi[1], 0.0) == 0.0) ? 1.0 : ta_nvi[1]\n    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0\n        ta_nvi := prevNvi\n    else\n        ta_nvi := (volume < nz(volume[1], 0.0)) ? prevNvi + ((close - close[1]) / close[1]) * prevNvi : prevNvi\n    result = ta_nvi\n\nplot(f_nvi())"
          ]
        },
        {
          "name": "ta.pvi",
          "type": "series float",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"Positive Volume Index\")\n\nplot(ta.pvi, color=color.yellow)\n\n// the same on pine\nf_pvi() =>\n    float ta_pvi = 1.0\n    float prevPvi = (nz(ta_pvi[1], 0.0) == 0.0) ? 1.0 : ta_pvi[1]\n    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0\n        ta_pvi := prevPvi\n    else\n        ta_pvi := (volume > nz(volume[1], 0.0)) ? prevPvi + ((close - close[1]) / close[1]) * prevPvi : prevPvi\n    result = ta_pvi\n\nplot(f_pvi())"
          ]
        },
        {
          "name": "syminfo.ticker",
          "type": "simple string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[timeframe.period](#var_timeframe.period)",
            "[timeframe.multiplier](#var_timeframe.multiplier)",
            "[syminfo.root](#var_syminfo.root)"
          ]
        },
        {
          "name": "syminfo.mincontract",
          "type": "simple float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.mintick](#var_syminfo.mintick)",
            "[syminfo.pointvalue](#var_syminfo.pointvalue)"
          ]
        },
        {
          "name": "syminfo.current_contract",
          "type": "simple string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.description](#var_syminfo.description)"
          ]
        },
        {
          "name": "syminfo.isin",
          "type": "simple string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.description](#var_syminfo.description)"
          ]
        },
        {
          "name": "syminfo.tickerid",
          "type": "simple string",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[ticker.new()](#fun_ticker.new)",
            "[syminfo.main_tickerid](#var_syminfo.main_tickerid)",
            "[timeframe.main_period](#var_timeframe.main_period)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[timeframe.period](#var_timeframe.period)",
            "[timeframe.multiplier](#var_timeframe.multiplier)",
            "[syminfo.root](#var_syminfo.root)"
          ]
        },
        {
          "name": "syminfo.main_tickerid",
          "type": "simple string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[ticker.new()](#fun_ticker.new)",
            "[timeframe.main_period](#var_timeframe.main_period)",
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[timeframe.period](#var_timeframe.period)",
            "[timeframe.multiplier](#var_timeframe.multiplier)",
            "[syminfo.root](#var_syminfo.root)"
          ]
        },
        {
          "name": "syminfo.expiration_date",
          "type": "simple int",
          "desc": [
            ""
          ]
        },
        {
          "name": "syminfo.minmove",
          "type": "simple int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[ticker.new()](#fun_ticker.new)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[timeframe.period](#var_timeframe.period)",
            "[timeframe.multiplier](#var_timeframe.multiplier)",
            "[syminfo.root](#var_syminfo.root)"
          ]
        },
        {
          "name": "syminfo.pricescale",
          "type": "simple int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[ticker.new()](#fun_ticker.new)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[timeframe.period](#var_timeframe.period)",
            "[timeframe.multiplier](#var_timeframe.multiplier)",
            "[syminfo.root](#var_syminfo.root)"
          ]
        },
        {
          "name": "timeframe.period",
          "type": "simple string",
          "desc": [
            "",
            "",
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[timeframe.main_period](#var_timeframe.main_period)",
            "[syminfo.main_tickerid](#var_syminfo.main_tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[timeframe.multiplier](#var_timeframe.multiplier)"
          ]
        },
        {
          "name": "timeframe.main_period",
          "type": "simple string",
          "desc": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[timeframe.period](#var_timeframe.period)",
            "[syminfo.main_tickerid](#var_syminfo.main_tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[timeframe.multiplier](#var_timeframe.multiplier)"
          ]
        },
        {
          "name": "syminfo.root",
          "type": "simple string",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo.root\")\n\n// If the current chart symbol is continuous futures ('ES1!'), it would display 'ES'.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, syminfo.root)"
          ],
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ]
        },
        {
          "name": "syminfo.prefix",
          "type": "simple string",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo.prefix\")\n\n// If current chart symbol is 'BATS:MSFT' then syminfo.prefix is 'BATS'.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, text=syminfo.prefix)"
          ],
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ]
        },
        {
          "name": "syminfo.mintick",
          "type": "simple float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.pointvalue](#var_syminfo.pointvalue)",
            "[syminfo.mincontract](#var_syminfo.mincontract)"
          ]
        },
        {
          "name": "syminfo.pointvalue",
          "type": "simple float",
          "desc": [
            "",
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[syminfo.mintick](#var_syminfo.mintick)",
            "[syminfo.mincontract](#var_syminfo.mincontract)"
          ]
        },
        {
          "name": "syminfo.session",
          "type": "simple string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[session.regular](#const_session.regular)",
            "[session.extended](#const_session.extended)"
          ]
        },
        {
          "name": "syminfo.timezone",
          "type": "simple string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[timestamp()](#fun_timestamp)"
          ]
        },
        {
          "name": "syminfo.description",
          "type": "simple string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.prefix](#var_syminfo.prefix)"
          ]
        },
        {
          "name": "syminfo.currency",
          "type": "simple string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.basecurrency](#var_syminfo.basecurrency)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[currency.USD](#const_currency.USD)",
            "[currency.EUR](#const_currency.EUR)"
          ]
        },
        {
          "name": "syminfo.basecurrency",
          "type": "simple string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.currency](#var_syminfo.currency)",
            "[syminfo.ticker](#var_syminfo.ticker)"
          ]
        },
        {
          "name": "syminfo.type",
          "type": "simple string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)"
          ]
        },
        {
          "name": "syminfo.sector",
          "type": "simple string",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "syminfo.industry",
          "type": "simple string",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "syminfo.country",
          "type": "simple string",
          "desc": [
            ""
          ]
        },
        {
          "name": "syminfo.volumetype",
          "type": "simple string",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.type](#var_syminfo.type)"
          ]
        },
        {
          "name": "syminfo.employees",
          "type": "simple int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.shareholders](#var_syminfo.shareholders)",
            "[syminfo.shares_outstanding_float](#var_syminfo.shares_outstanding_float)",
            "[syminfo.shares_outstanding_total](#var_syminfo.shares_outstanding_total)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n\t// Add header cells\n\ttable.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n\ttable.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n\t// Add employee info cells.\n\ttable.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n\ttable.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n\t// Add shareholder cells.\n\ttable.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n\ttable.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n\t// Add float shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n\ttable.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n\t// Add total shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n\ttable.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
          ]
        },
        {
          "name": "syminfo.shareholders",
          "type": "simple int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.employees](#var_syminfo.employees)",
            "[syminfo.shares_outstanding_float](#var_syminfo.shares_outstanding_float)",
            "[syminfo.shares_outstanding_total](#var_syminfo.shares_outstanding_total)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n\t// Add header cells\n\ttable.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n\ttable.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n\t// Add employee info cells.\n\ttable.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n\ttable.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n\t// Add shareholder cells.\n\ttable.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n\ttable.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n\t// Add float shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n\ttable.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n\t// Add total shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n\ttable.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
          ]
        },
        {
          "name": "syminfo.shares_outstanding_float",
          "type": "simple float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.employees](#var_syminfo.employees)",
            "[syminfo.shareholders](#var_syminfo.shareholders)",
            "[syminfo.shares_outstanding_total](#var_syminfo.shares_outstanding_total)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n\t// Add header cells\n\ttable.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n\ttable.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n\t// Add employee info cells.\n\ttable.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n\ttable.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n\t// Add shareholder cells.\n\ttable.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n\ttable.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n\t// Add float shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n\ttable.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n\t// Add total shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n\ttable.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
          ]
        },
        {
          "name": "syminfo.shares_outstanding_total",
          "type": "simple int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.employees](#var_syminfo.employees)",
            "[syminfo.shareholders](#var_syminfo.shareholders)",
            "[syminfo.shares_outstanding_float](#var_syminfo.shares_outstanding_float)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n\t// Add header cells\n\ttable.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n\ttable.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n\t// Add employee info cells.\n\ttable.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n\ttable.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n\t// Add shareholder cells.\n\ttable.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n\ttable.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n\t// Add float shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n\ttable.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n\t// Add total shares outstanding cells.\n\ttable.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n\ttable.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
          ]
        },
        {
          "name": "syminfo.target_price_average",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.target_price_date](#var_syminfo.target_price_date)",
            "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
            "[syminfo.target_price_high](#var_syminfo.target_price_high)",
            "[syminfo.target_price_low](#var_syminfo.target_price_low)",
            "[syminfo.target_price_median](#var_syminfo.target_price_median)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t//@variable A line connecting the current `close` to the highest yearly price estimate.\n\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the lowest yearly price estimate.\n\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the median yearly price estimate.\n\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the average yearly price estimate.\n\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n\t// Fill the space between targets\n\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))\n\tlinefill.new(medianLine, highLine, color.new(color.green, 90))\n\t// Create a label displaying the total number of analyst estimates.\n\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
          ]
        },
        {
          "name": "syminfo.target_price_date",
          "type": "series int",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.target_price_average](#var_syminfo.target_price_average)",
            "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
            "[syminfo.target_price_high](#var_syminfo.target_price_high)",
            "[syminfo.target_price_low](#var_syminfo.target_price_low)",
            "[syminfo.target_price_median](#var_syminfo.target_price_median)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t//@variable A line connecting the current `close` to the highest yearly price estimate.\n\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the lowest yearly price estimate.\n\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the median yearly price estimate.\n\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the average yearly price estimate.\n\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n\t// Fill the space between targets\n\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))\n\tlinefill.new(medianLine, highLine, color.new(color.green, 90))\n\t// Create a label displaying the total number of analyst estimates.\n\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
          ]
        },
        {
          "name": "syminfo.target_price_estimates",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.target_price_average](#var_syminfo.target_price_average)",
            "[syminfo.target_price_date](#var_syminfo.target_price_date)",
            "[syminfo.target_price_high](#var_syminfo.target_price_high)",
            "[syminfo.target_price_low](#var_syminfo.target_price_low)",
            "[syminfo.target_price_median](#var_syminfo.target_price_median)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t//@variable A line connecting the current `close` to the highest yearly price estimate.\n\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the lowest yearly price estimate.\n\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the median yearly price estimate.\n\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the average yearly price estimate.\n\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n\t// Fill the space between targets\n\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))\n\tlinefill.new(medianLine, highLine, color.new(color.green, 90))\n\t// Create a label displaying the total number of analyst estimates.\n\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
          ]
        },
        {
          "name": "syminfo.target_price_high",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.target_price_average](#var_syminfo.target_price_average)",
            "[syminfo.target_price_date](#var_syminfo.target_price_date)",
            "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
            "[syminfo.target_price_low](#var_syminfo.target_price_low)",
            "[syminfo.target_price_median](#var_syminfo.target_price_median)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t//@variable A line connecting the current `close` to the highest yearly price estimate.\n\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the lowest yearly price estimate.\n\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the median yearly price estimate.\n\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the average yearly price estimate.\n\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n\t// Fill the space between targets\n\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))\n\tlinefill.new(medianLine, highLine, color.new(color.green, 90))\n\t// Create a label displaying the total number of analyst estimates.\n\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
          ]
        },
        {
          "name": "syminfo.target_price_low",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.target_price_average](#var_syminfo.target_price_average)",
            "[syminfo.target_price_date](#var_syminfo.target_price_date)",
            "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
            "[syminfo.target_price_high](#var_syminfo.target_price_high)",
            "[syminfo.target_price_median](#var_syminfo.target_price_median)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t//@variable A line connecting the current `close` to the highest yearly price estimate.\n\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the lowest yearly price estimate.\n\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the median yearly price estimate.\n\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the average yearly price estimate.\n\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n\t// Fill the space between targets\n\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))\n\tlinefill.new(medianLine, highLine, color.new(color.green, 90))\n\t// Create a label displaying the total number of analyst estimates.\n\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
          ]
        },
        {
          "name": "syminfo.target_price_median",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.target_price_average](#var_syminfo.target_price_average)",
            "[syminfo.target_price_date](#var_syminfo.target_price_date)",
            "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
            "[syminfo.target_price_high](#var_syminfo.target_price_high)",
            "[syminfo.target_price_low](#var_syminfo.target_price_low)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t//@variable A line connecting the current `close` to the highest yearly price estimate.\n\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the lowest yearly price estimate.\n\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the median yearly price estimate.\n\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n\t//@variable A line connecting the current `close` to the average yearly price estimate.\n\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n\t// Fill the space between targets\n\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))\n\tlinefill.new(medianLine, highLine, color.new(color.green, 90))\n\t// Create a label displaying the total number of analyst estimates.\n\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
          ]
        },
        {
          "name": "syminfo.recommendations_buy",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
            "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
            "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
            "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
            "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
            "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
          ]
        },
        {
          "name": "syminfo.recommendations_buy_strong",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
            "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
            "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
            "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
            "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
            "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
          ]
        },
        {
          "name": "syminfo.recommendations_date",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
            "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
            "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
            "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
            "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
            "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
          ]
        },
        {
          "name": "syminfo.recommendations_hold",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
            "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
            "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
            "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
            "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
            "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
          ]
        },
        {
          "name": "syminfo.recommendations_total",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
            "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
            "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
            "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
            "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
            "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
          ]
        },
        {
          "name": "syminfo.recommendations_sell",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
            "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
            "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
            "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
            "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
            "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
          ]
        },
        {
          "name": "syminfo.recommendations_sell_strong",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
            "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
            "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
            "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
            "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
            "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)"
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n\t//@variable The time value one year from the date of the last analyst recommendations.\n\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n\t// Add header cells.\n\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n\t// Recommendation strings\n\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)\n\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)\n\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)\n\tstring totalRatings      = str.tostring(syminfo.recommendations_total)\n\t// Add value cells\n\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
          ]
        },
        {
          "name": "timeframe.multiplier",
          "type": "simple int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[timeframe.period](#var_timeframe.period)"
          ]
        },
        {
          "name": "timeframe.isdwm",
          "type": "simple bool",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isticks](#var_timeframe.isticks)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.isweekly](#var_timeframe.isweekly)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ]
        },
        {
          "name": "timeframe.isintraday",
          "type": "simple bool",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isticks](#var_timeframe.isticks)",
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.isweekly](#var_timeframe.isweekly)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ]
        },
        {
          "name": "timeframe.isdaily",
          "type": "simple bool",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isticks](#var_timeframe.isticks)",
            "[timeframe.isweekly](#var_timeframe.isweekly)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ]
        },
        {
          "name": "timeframe.isweekly",
          "type": "simple bool",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isticks](#var_timeframe.isticks)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ]
        },
        {
          "name": "timeframe.ismonthly",
          "type": "simple bool",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isticks](#var_timeframe.isticks)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.isweekly](#var_timeframe.isweekly)"
          ]
        },
        {
          "name": "timeframe.isminutes",
          "type": "simple bool",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isticks](#var_timeframe.isticks)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.isweekly](#var_timeframe.isweekly)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ]
        },
        {
          "name": "timeframe.isseconds",
          "type": "simple bool",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isticks](#var_timeframe.isticks)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.isweekly](#var_timeframe.isweekly)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ]
        },
        {
          "name": "timeframe.isticks",
          "type": "simple bool",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[timeframe.isdwm](#var_timeframe.isdwm)",
            "[timeframe.isintraday](#var_timeframe.isintraday)",
            "[timeframe.isminutes](#var_timeframe.isminutes)",
            "[timeframe.isseconds](#var_timeframe.isseconds)",
            "[timeframe.isdaily](#var_timeframe.isdaily)",
            "[timeframe.isweekly](#var_timeframe.isweekly)",
            "[timeframe.ismonthly](#var_timeframe.ismonthly)"
          ]
        },
        {
          "name": "timenow",
          "type": "series int",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[timestamp()](#fun_timestamp)",
            "[time](#var_time)",
            "[time_close](#var_time_close)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ]
        },
        {
          "name": "time",
          "type": "series int",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[time()](#fun_time)",
            "[time_close](#var_time_close)",
            "[timenow](#var_timenow)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ]
        },
        {
          "name": "time_close",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[time](#var_time)",
            "[timenow](#var_timenow)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ]
        },
        {
          "name": "time_tradingday",
          "type": "series int",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"Friday session\")\n\n//@variable The day of week, based on the current `time_tradingday` value. \n//          Uses \"UTC+0\" to return the daily session's timestamp at 00:00 UTC. \nint tradingDayOfWeek = dayofweek(time_tradingday, \"UTC+0\")\n\n//@variable Returns `true` if the `dayofweek` represents Friday, in exchange time.\n//          It might never return `true` on overnight symbols, depending on the timeframe, since the Friday session\n//          starts on Thursday.\nbool isFriday = dayofweek == dayofweek.friday\n//@variable Returns `true` if the `tradingDayOfWeek` is Friday. \n//          Differs from `isFriday` on symbols with overnight sessions and for timeframes > \"1D\" on others.\nbool isFridaySession = tradingDayOfWeek == dayofweek.friday\n\n// Create a horizontal line at the `dayofweek.friday` value.\nhline(dayofweek.friday, \"Friday value\", color.gray, hline.style_dashed, 2)\n// Plot the `dayofweek` and `tradingDayOfWeek` for comparison.\nplot(dayofweek, \"Day of week\", color.blue, 2)\nplot(tradingDayOfWeek, \"Trading day\", color.teal, 3)\n// Highlight the background when `isFriday` and `isFridaySession` occur.\nbgcolor(isFriday ? color.new(color.blue, 90) : na, title = \"isFriday highlight\")\nbgcolor(isFridaySession ? color.new(color.teal, 80) : na, title = \"isFridaySession highlight\")"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[time](#var_time)",
            "[time_close](#var_time_close)"
          ]
        },
        {
          "name": "year",
          "type": "series int",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[year()](#fun_year)",
            "[time](#var_time)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ]
        },
        {
          "name": "month",
          "type": "series int",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[month()](#fun_month)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ]
        },
        {
          "name": "weekofyear",
          "type": "series int",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[weekofyear()](#fun_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ]
        },
        {
          "name": "dayofmonth",
          "type": "series int",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[dayofmonth()](#fun_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[weekofyear](#var_weekofyear)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ]
        },
        {
          "name": "dayofweek",
          "type": "series int",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[dayofweek()](#fun_dayofweek)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[hour](#var_hour)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ]
        },
        {
          "name": "hour",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[hour()](#fun_hour)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[minute](#var_minute)",
            "[second](#var_second)"
          ]
        },
        {
          "name": "minute",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[minute()](#fun_minute)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[second](#var_second)"
          ]
        },
        {
          "name": "second",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[second()](#fun_second)",
            "[time](#var_time)",
            "[year](#var_year)",
            "[month](#var_month)",
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek](#var_dayofweek)",
            "[hour](#var_hour)",
            "[minute](#var_minute)"
          ]
        },
        {
          "name": "strategy.position_size",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.position_avg_price](#var_strategy.position_avg_price)"
          ]
        },
        {
          "name": "strategy.position_avg_price",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)"
          ]
        },
        {
          "name": "strategy.openprofit",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.position_size](#var_strategy.position_size)"
          ]
        },
        {
          "name": "strategy.netprofit",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.openprofit](#var_strategy.openprofit)",
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.grossprofit](#var_strategy.grossprofit)",
            "[strategy.grossloss](#var_strategy.grossloss)"
          ]
        },
        {
          "name": "strategy.equity",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.openprofit](#var_strategy.openprofit)",
            "[strategy.position_size](#var_strategy.position_size)"
          ]
        },
        {
          "name": "strategy.position_entry_name",
          "type": "series string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)"
          ]
        },
        {
          "name": "strategy.grossprofit",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.grossloss](#var_strategy.grossloss)"
          ]
        },
        {
          "name": "strategy.grossloss",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.grossprofit](#var_strategy.grossprofit)"
          ]
        },
        {
          "name": "strategy.max_drawdown",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.equity](#var_strategy.equity)",
            "[strategy.max_runup](#var_strategy.max_runup)"
          ]
        },
        {
          "name": "strategy.max_runup",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.equity](#var_strategy.equity)",
            "[strategy.max_drawdown](#var_strategy.max_drawdown)"
          ]
        },
        {
          "name": "strategy.grossloss_percent",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.grossloss](#var_strategy.grossloss)"
          ]
        },
        {
          "name": "strategy.max_runup_percent",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.max_runup](#var_strategy.max_runup)"
          ]
        },
        {
          "name": "strategy.netprofit_percent",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.netprofit](#var_strategy.netprofit)"
          ]
        },
        {
          "name": "strategy.openprofit_percent",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.openprofit](#var_strategy.openprofit)"
          ]
        },
        {
          "name": "strategy.grossprofit_percent",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.grossprofit](#var_strategy.grossprofit)"
          ]
        },
        {
          "name": "strategy.max_drawdown_percent",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.max_drawdown](#var_strategy.max_drawdown)"
          ]
        },
        {
          "name": "strategy.avg_trade",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.avg_trade_percent](#var_strategy.avg_trade_percent)"
          ]
        },
        {
          "name": "strategy.avg_trade_percent",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.avg_trade](#var_strategy.avg_trade)"
          ]
        },
        {
          "name": "strategy.avg_winning_trade",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.avg_winning_trade_percent](#var_strategy.avg_winning_trade_percent)"
          ]
        },
        {
          "name": "strategy.avg_winning_trade_percent",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.avg_winning_trade](#var_strategy.avg_winning_trade)"
          ]
        },
        {
          "name": "strategy.avg_losing_trade",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.avg_losing_trade_percent](#var_strategy.avg_losing_trade_percent)"
          ]
        },
        {
          "name": "strategy.avg_losing_trade_percent",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.avg_losing_trade](#var_strategy.avg_losing_trade)"
          ]
        },
        {
          "name": "strategy.max_contracts_held_all",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.max_contracts_held_long](#var_strategy.max_contracts_held_long)",
            "[strategy.max_contracts_held_short](#var_strategy.max_contracts_held_short)"
          ]
        },
        {
          "name": "strategy.max_contracts_held_long",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.max_contracts_held_all](#var_strategy.max_contracts_held_all)",
            "[strategy.max_contracts_held_short](#var_strategy.max_contracts_held_short)"
          ]
        },
        {
          "name": "strategy.max_contracts_held_short",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.max_contracts_held_all](#var_strategy.max_contracts_held_all)",
            "[strategy.max_contracts_held_long](#var_strategy.max_contracts_held_long)"
          ]
        },
        {
          "name": "strategy.opentrades",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)"
          ]
        },
        {
          "name": "strategy.opentrades.capital_held",
          "type": "series float",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nstrategy(\n   \"strategy.opentrades.capital_held example\", overlay=false, margin_long=50, margin_short=50,\n   default_qty_type = strategy.percent_of_equity, default_qty_value = 100\n )\n\n// Enter a short position on the first bar.\nif barstate.isfirst\n    strategy.entry(\"Short\", strategy.short)\n\n// Plot the capital held by the short position.\nplot(strategy.opentrades.capital_held, \"Capital held\")\n// Highlight the chart background if the position is completely closed by margin calls.\nbgcolor(bar_index > 0 and strategy.opentrades.capital_held == 0 ? color.new(color.red, 60) : na)"
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "strategy.closedtrades",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.opentrades](#var_strategy.opentrades)",
            "[strategy.wintrades](#var_strategy.wintrades)",
            "[strategy.losstrades](#var_strategy.losstrades)",
            "[strategy.eventrades](#var_strategy.eventrades)"
          ]
        },
        {
          "name": "strategy.wintrades",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.opentrades](#var_strategy.opentrades)",
            "[strategy.closedtrades](#var_strategy.closedtrades)",
            "[strategy.losstrades](#var_strategy.losstrades)",
            "[strategy.eventrades](#var_strategy.eventrades)"
          ]
        },
        {
          "name": "strategy.closedtrades.first_index",
          "type": "series int",
          "desc": [
            ""
          ],
          "args": [],
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.opentrades](#var_strategy.opentrades)",
            "[strategy.wintrades](#var_strategy.wintrades)",
            "[strategy.losstrades](#var_strategy.losstrades)",
            "[strategy.eventrades](#var_strategy.eventrades)"
          ]
        },
        {
          "name": "strategy.losstrades",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.opentrades](#var_strategy.opentrades)",
            "[strategy.closedtrades](#var_strategy.closedtrades)",
            "[strategy.wintrades](#var_strategy.wintrades)",
            "[strategy.eventrades](#var_strategy.eventrades)"
          ]
        },
        {
          "name": "strategy.eventrades",
          "type": "series int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.opentrades](#var_strategy.opentrades)",
            "[strategy.closedtrades](#var_strategy.closedtrades)",
            "[strategy.wintrades](#var_strategy.wintrades)",
            "[strategy.losstrades](#var_strategy.losstrades)"
          ]
        },
        {
          "name": "strategy.initial_capital",
          "type": "series float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "strategy.account_currency",
          "type": "simple string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)",
            "[strategy.convert_to_account()](#fun_strategy.convert_to_account)",
            "[strategy.convert_to_symbol()](#fun_strategy.convert_to_symbol)"
          ]
        },
        {
          "name": "strategy.margin_liquidation_price",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "examples": [
            "//@version=6\nstrategy(\"Margin call management\", overlay = true, margin_long = 25, margin_short = 25,\n  default_qty_type = strategy.percent_of_equity, default_qty_value = 395)\n\nfloat maFast = ta.sma(close, 14)\nfloat maSlow = ta.sma(close, 28)\n\nif ta.crossover(maFast, maSlow)\n    strategy.entry(\"Long\", strategy.long)\n\nif ta.crossunder(maFast, maSlow)\n    strategy.entry(\"Short\", strategy.short)\n\nchangePercent(v1, v2) =>\n    float result = (v1 - v2) * 100 / math.abs(v2)\n\n// exit when we're 10% away from a margin call, to prevent it.\nif math.abs(changePercent(close, strategy.margin_liquidation_price)) <= 10\n    strategy.close(\"Long\")\n    strategy.close(\"Short\")"
          ]
        },
        {
          "name": "barstate.isfirst",
          "type": "series bool",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isrealtime](#var_barstate.isrealtime)",
            "[barstate.isnew](#var_barstate.isnew)",
            "[barstate.isconfirmed](#var_barstate.isconfirmed)",
            "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
          ]
        },
        {
          "name": "barstate.islast",
          "type": "series bool",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isrealtime](#var_barstate.isrealtime)",
            "[barstate.isnew](#var_barstate.isnew)",
            "[barstate.isconfirmed](#var_barstate.isconfirmed)",
            "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
          ]
        },
        {
          "name": "barstate.ishistory",
          "type": "series bool",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.isrealtime](#var_barstate.isrealtime)",
            "[barstate.isnew](#var_barstate.isnew)",
            "[barstate.isconfirmed](#var_barstate.isconfirmed)",
            "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
          ]
        },
        {
          "name": "barstate.isrealtime",
          "type": "series bool",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isnew](#var_barstate.isnew)",
            "[barstate.isconfirmed](#var_barstate.isconfirmed)",
            "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
          ]
        },
        {
          "name": "barstate.isnew",
          "type": "series bool",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isrealtime](#var_barstate.isrealtime)",
            "[barstate.isconfirmed](#var_barstate.isconfirmed)",
            "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
          ]
        },
        {
          "name": "barstate.isconfirmed",
          "type": "series bool",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isrealtime](#var_barstate.isrealtime)",
            "[barstate.isnew](#var_barstate.isnew)",
            "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
          ]
        },
        {
          "name": "barstate.islastconfirmedhistory",
          "type": "series bool",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[barstate.isfirst](#var_barstate.isfirst)",
            "[barstate.islast](#var_barstate.islast)",
            "[barstate.ishistory](#var_barstate.ishistory)",
            "[barstate.isrealtime](#var_barstate.isrealtime)",
            "[barstate.isnew](#var_barstate.isnew)"
          ]
        },
        {
          "name": "session.ismarket",
          "type": "series bool",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[session.ispremarket](#var_session.ispremarket)",
            "[session.ispostmarket](#var_session.ispostmarket)"
          ]
        },
        {
          "name": "session.ispremarket",
          "type": "series bool",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[session.ismarket](#var_session.ismarket)",
            "[session.ispostmarket](#var_session.ispostmarket)"
          ]
        },
        {
          "name": "session.ispostmarket",
          "type": "series bool",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[session.ismarket](#var_session.ismarket)",
            "[session.ispremarket](#var_session.ispremarket)"
          ]
        },
        {
          "name": "label.all",
          "type": "array<label>",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"label.all\")\n//delete all labels\nlabel.new(bar_index, close)\na_allLabels = label.all\nif array.size(a_allLabels) > 0\n\tfor i = 0 to array.size(a_allLabels) - 1\n\t\tlabel.delete(array.get(a_allLabels, i))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[line.all](#var_line.all)",
            "[box.all](#var_box.all)",
            "[table.all](#var_table.all)"
          ]
        },
        {
          "name": "line.all",
          "type": "array<line>",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"line.all\")\n//delete all lines\nline.new(bar_index - 10, close, bar_index, close)\na_allLines = line.all\nif array.size(a_allLines) > 0\n\tfor i = 0 to array.size(a_allLines) - 1\n\t\tline.delete(array.get(a_allLines, i))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[label.all](#var_label.all)",
            "[box.all](#var_box.all)",
            "[table.all](#var_table.all)"
          ]
        },
        {
          "name": "linefill.all",
          "type": "array<linefill>",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "box.all",
          "type": "array<box>",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"box.all\")\n//delete all boxes\nbox.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)\na_allBoxes = box.all\nif array.size(a_allBoxes) > 0\n\tfor i = 0 to array.size(a_allBoxes) - 1\n\t\tbox.delete(array.get(a_allBoxes, i))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[line.all](#var_line.all)",
            "[label.all](#var_label.all)",
            "[table.all](#var_table.all)"
          ]
        },
        {
          "name": "table.all",
          "type": "array<table>",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"table.all\")\n//delete all tables\ntable.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)\na_allTables = table.all\nif array.size(a_allTables) > 0\n\tfor i = 0 to array.size(a_allTables) - 1\n\t\ttable.delete(array.get(a_allTables, i))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[line.all](#var_line.all)",
            "[label.all](#var_label.all)",
            "[box.all](#var_box.all)"
          ]
        },
        {
          "name": "chart.bg_color",
          "type": "input color",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[chart.fg_color](#var_chart.fg_color)"
          ]
        },
        {
          "name": "chart.fg_color",
          "type": "input color",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[chart.bg_color](#var_chart.bg_color)"
          ]
        },
        {
          "name": "chart.left_visible_bar_time",
          "type": "input int",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[chart.right_visible_bar_time](#var_chart.right_visible_bar_time)"
          ]
        },
        {
          "name": "chart.right_visible_bar_time",
          "type": "input int",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[chart.left_visible_bar_time](#var_chart.left_visible_bar_time)"
          ]
        },
        {
          "name": "chart.is_heikinashi",
          "type": "simple bool",
          "returns": [
            ""
          ],
          "seeAlso": [
            "[chart.is_renko](#var_chart.is_renko)",
            "[chart.is_linebreak](#var_chart.is_linebreak)",
            "[chart.is_kagi](#var_chart.is_kagi)",
            "[chart.is_pnf](#var_chart.is_pnf)",
            "[chart.is_range](#var_chart.is_range)"
          ]
        },
        {
          "name": "chart.is_renko",
          "type": "simple bool",
          "returns": [
            ""
          ],
          "seeAlso": [
            "[chart.is_heikinashi](#var_chart.is_heikinashi)",
            "[chart.is_linebreak](#var_chart.is_linebreak)",
            "[chart.is_kagi](#var_chart.is_kagi)",
            "[chart.is_pnf](#var_chart.is_pnf)",
            "[chart.is_range](#var_chart.is_range)"
          ]
        },
        {
          "name": "chart.is_linebreak",
          "type": "simple bool",
          "returns": [
            ""
          ],
          "seeAlso": [
            "[chart.is_renko](#var_chart.is_renko)",
            "[chart.is_heikinashi](#var_chart.is_heikinashi)",
            "[chart.is_kagi](#var_chart.is_kagi)",
            "[chart.is_pnf](#var_chart.is_pnf)",
            "[chart.is_range](#var_chart.is_range)"
          ]
        },
        {
          "name": "chart.is_kagi",
          "type": "simple bool",
          "returns": [
            ""
          ],
          "seeAlso": [
            "[chart.is_renko](#var_chart.is_renko)",
            "[chart.is_linebreak](#var_chart.is_linebreak)",
            "[chart.is_heikinashi](#var_chart.is_heikinashi)",
            "[chart.is_pnf](#var_chart.is_pnf)",
            "[chart.is_range](#var_chart.is_range)"
          ]
        },
        {
          "name": "chart.is_pnf",
          "type": "simple bool",
          "returns": [
            ""
          ],
          "seeAlso": [
            "[chart.is_renko](#var_chart.is_renko)",
            "[chart.is_linebreak](#var_chart.is_linebreak)",
            "[chart.is_kagi](#var_chart.is_kagi)",
            "[chart.is_heikinashi](#var_chart.is_heikinashi)",
            "[chart.is_range](#var_chart.is_range)"
          ]
        },
        {
          "name": "chart.is_range",
          "type": "simple bool",
          "returns": [
            ""
          ],
          "seeAlso": [
            "[chart.is_renko](#var_chart.is_renko)",
            "[chart.is_linebreak](#var_chart.is_linebreak)",
            "[chart.is_kagi](#var_chart.is_kagi)",
            "[chart.is_pnf](#var_chart.is_pnf)",
            "[chart.is_heikinashi](#var_chart.is_heikinashi)"
          ]
        },
        {
          "name": "chart.is_standard",
          "type": "simple bool",
          "returns": [
            ""
          ],
          "seeAlso": [
            "[chart.is_renko](#var_chart.is_renko)",
            "[chart.is_linebreak](#var_chart.is_linebreak)",
            "[chart.is_kagi](#var_chart.is_kagi)",
            "[chart.is_pnf](#var_chart.is_pnf)",
            "[chart.is_range](#var_chart.is_range)",
            "[chart.is_heikinashi](#var_chart.is_heikinashi)"
          ]
        },
        {
          "name": "earnings.future_time",
          "type": "series int",
          "desc": [
            ""
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[request.earnings()](#fun_request.earnings)"
          ]
        },
        {
          "name": "earnings.future_period_end_time",
          "type": "series int",
          "desc": [
            ""
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[request.earnings()](#fun_request.earnings)"
          ]
        },
        {
          "name": "earnings.future_eps",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[request.earnings()](#fun_request.earnings)"
          ]
        },
        {
          "name": "earnings.future_revenue",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[request.earnings()](#fun_request.earnings)"
          ]
        },
        {
          "name": "polyline.all",
          "type": "array<polyline>",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "dividends.future_amount",
          "type": "series float",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "dividends.future_ex_date",
          "type": "series int",
          "returns": [
            ""
          ],
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "dividends.future_pay_date",
          "type": "series int",
          "returns": [
            ""
          ],
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ]
        }
      ]
    }
  ],
  "constants": [
    {
      "title": "Built-in Constant",
      "docs": [
        {
          "name": "math.pi",
          "type": "const float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[math.e](#const_math.e)",
            "[math.phi](#const_math.phi)",
            "[math.rphi](#const_math.rphi)"
          ]
        },
        {
          "name": "math.phi",
          "type": "const float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[math.e](#const_math.e)",
            "[math.pi](#const_math.pi)",
            "[math.rphi](#const_math.rphi)"
          ]
        },
        {
          "name": "math.rphi",
          "type": "const float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[math.e](#const_math.e)",
            "[math.pi](#const_math.pi)",
            "[math.phi](#const_math.phi)"
          ]
        },
        {
          "name": "math.e",
          "type": "const float",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[math.phi](#const_math.phi)",
            "[math.pi](#const_math.pi)",
            "[math.rphi](#const_math.rphi)"
          ]
        },
        {
          "name": "session.regular",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[session.extended](#const_session.extended)",
            "[syminfo.session](#var_syminfo.session)"
          ]
        },
        {
          "name": "session.extended",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[session.regular](#const_session.regular)",
            "[syminfo.session](#var_syminfo.session)"
          ]
        },
        {
          "name": "adjustment.none",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[adjustment.splits](#const_adjustment.splits)",
            "[adjustment.dividends](#const_adjustment.dividends)",
            "[ticker.new()](#fun_ticker.new)"
          ]
        },
        {
          "name": "adjustment.splits",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[adjustment.none](#const_adjustment.none)",
            "[adjustment.dividends](#const_adjustment.dividends)",
            "[ticker.new()](#fun_ticker.new)"
          ]
        },
        {
          "name": "adjustment.dividends",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[adjustment.none](#const_adjustment.none)",
            "[adjustment.splits](#const_adjustment.splits)",
            "[ticker.new()](#fun_ticker.new)"
          ]
        },
        {
          "name": "hline.style_solid",
          "type": "const hline_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[hline.style_dotted](#const_hline.style_dotted)",
            "[hline.style_dashed](#const_hline.style_dashed)"
          ]
        },
        {
          "name": "hline.style_dotted",
          "type": "const hline_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[hline.style_solid](#const_hline.style_solid)",
            "[hline.style_dashed](#const_hline.style_dashed)"
          ]
        },
        {
          "name": "hline.style_dashed",
          "type": "const hline_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[hline.style_solid](#const_hline.style_solid)",
            "[hline.style_dotted](#const_hline.style_dotted)"
          ]
        },
        {
          "name": "position.top_left",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[table.cell()](#fun_table.cell)",
            "[table.set_position()](#fun_table.set_position)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ]
        },
        {
          "name": "position.top_center",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[table.cell()](#fun_table.cell)",
            "[table.set_position()](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ]
        },
        {
          "name": "position.top_right",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[table.cell()](#fun_table.cell)",
            "[table.set_position()](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ]
        },
        {
          "name": "position.middle_left",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[table.cell()](#fun_table.cell)",
            "[table.set_position()](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ]
        },
        {
          "name": "position.middle_center",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[table.cell()](#fun_table.cell)",
            "[table.set_position()](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ]
        },
        {
          "name": "position.middle_right",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[table.cell()](#fun_table.cell)",
            "[table.set_position()](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ]
        },
        {
          "name": "position.bottom_left",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[table.cell()](#fun_table.cell)",
            "[table.set_position()](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_center](#const_position.bottom_center)",
            "[position.bottom_right](#const_position.bottom_right)"
          ]
        },
        {
          "name": "position.bottom_center",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[table.cell()](#fun_table.cell)",
            "[table.set_position()](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_right](#const_position.bottom_right)"
          ]
        },
        {
          "name": "position.bottom_right",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[table.cell()](#fun_table.cell)",
            "[table.set_position()](#fun_table.set_position)",
            "[position.top_left](#const_position.top_left)",
            "[position.top_center](#const_position.top_center)",
            "[position.top_right](#const_position.top_right)",
            "[position.middle_left](#const_position.middle_left)",
            "[position.middle_center](#const_position.middle_center)",
            "[position.middle_right](#const_position.middle_right)",
            "[position.bottom_left](#const_position.bottom_left)",
            "[position.bottom_center](#const_position.bottom_center)"
          ]
        },
        {
          "name": "size.auto",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[label.set_size()](#fun_label.set_size)",
            "[size.tiny](#const_size.tiny)",
            "[size.small](#const_size.small)",
            "[size.normal](#const_size.normal)",
            "[size.large](#const_size.large)",
            "[size.huge](#const_size.huge)"
          ]
        },
        {
          "name": "size.tiny",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[label.set_size()](#fun_label.set_size)",
            "[size.auto](#const_size.auto)",
            "[size.small](#const_size.small)",
            "[size.normal](#const_size.normal)",
            "[size.large](#const_size.large)",
            "[size.huge](#const_size.huge)"
          ]
        },
        {
          "name": "size.small",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[label.set_size()](#fun_label.set_size)",
            "[size.auto](#const_size.auto)",
            "[size.tiny](#const_size.tiny)",
            "[size.normal](#const_size.normal)",
            "[size.large](#const_size.large)",
            "[size.huge](#const_size.huge)"
          ]
        },
        {
          "name": "size.normal",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[label.set_size()](#fun_label.set_size)",
            "[size.auto](#const_size.auto)",
            "[size.tiny](#const_size.tiny)",
            "[size.small](#const_size.small)",
            "[size.large](#const_size.large)",
            "[size.huge](#const_size.huge)"
          ]
        },
        {
          "name": "size.large",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[label.set_size()](#fun_label.set_size)",
            "[size.auto](#const_size.auto)",
            "[size.tiny](#const_size.tiny)",
            "[size.small](#const_size.small)",
            "[size.normal](#const_size.normal)",
            "[size.huge](#const_size.huge)"
          ]
        },
        {
          "name": "size.huge",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[label.set_size()](#fun_label.set_size)",
            "[size.auto](#const_size.auto)",
            "[size.tiny](#const_size.tiny)",
            "[size.small](#const_size.small)",
            "[size.normal](#const_size.normal)",
            "[size.large](#const_size.large)"
          ]
        },
        {
          "name": "plot.style_line",
          "type": "const plot_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)"
          ]
        },
        {
          "name": "plot.style_linebr",
          "type": "const plot_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)"
          ]
        },
        {
          "name": "plot.style_stepline",
          "type": "const plot_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)"
          ]
        },
        {
          "name": "plot.style_stepline_diamond",
          "type": "const plot_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)"
          ]
        },
        {
          "name": "plot.style_histogram",
          "type": "const plot_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)"
          ]
        },
        {
          "name": "plot.style_cross",
          "type": "const plot_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)"
          ]
        },
        {
          "name": "plot.style_area",
          "type": "const plot_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)"
          ]
        },
        {
          "name": "plot.style_areabr",
          "type": "const plot_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)"
          ]
        },
        {
          "name": "plot.style_columns",
          "type": "const plot_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_circles](#const_plot.style_circles)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)"
          ]
        },
        {
          "name": "plot.style_circles",
          "type": "const plot_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
            "[plot.style_steplinebr](#const_plot.style_steplinebr)"
          ]
        },
        {
          "name": "plot.style_steplinebr",
          "type": "const plot_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.style_line](#const_plot.style_line)",
            "[plot.style_linebr](#const_plot.style_linebr)",
            "[plot.style_histogram](#const_plot.style_histogram)",
            "[plot.style_cross](#const_plot.style_cross)",
            "[plot.style_area](#const_plot.style_area)",
            "[plot.style_areabr](#const_plot.style_areabr)",
            "[plot.style_columns](#const_plot.style_columns)",
            "[plot.style_circles](#const_plot.style_circles)",
            "[plot.style_stepline](#const_plot.style_stepline)",
            "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)"
          ]
        },
        {
          "name": "plot.linestyle_solid",
          "type": "const plot_line_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.linestyle_dashed](#const_plot.linestyle_dashed)",
            "[plot.linestyle_dotted](#const_plot.linestyle_dotted)"
          ]
        },
        {
          "name": "plot.linestyle_dashed",
          "type": "const plot_line_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.linestyle_solid](#const_plot.linestyle_solid)",
            "[plot.linestyle_dotted](#const_plot.linestyle_dotted)"
          ]
        },
        {
          "name": "plot.linestyle_dotted",
          "type": "const plot_line_style",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plot.linestyle_dashed](#const_plot.linestyle_dashed)",
            "[plot.linestyle_solid](#const_plot.linestyle_solid)"
          ]
        },
        {
          "name": "format.inherit",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[indicator()](#fun_indicator)",
            "[format.price](#const_format.price)",
            "[format.volume](#const_format.volume)",
            "[format.percent](#const_format.percent)"
          ]
        },
        {
          "name": "format.price",
          "type": "const string",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[indicator()](#fun_indicator)",
            "[format.inherit](#const_format.inherit)",
            "[format.volume](#const_format.volume)",
            "[format.percent](#const_format.percent)"
          ]
        },
        {
          "name": "format.volume",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[indicator()](#fun_indicator)",
            "[format.inherit](#const_format.inherit)",
            "[format.price](#const_format.price)",
            "[format.percent](#const_format.percent)"
          ]
        },
        {
          "name": "format.percent",
          "type": "const string",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[indicator()](#fun_indicator)",
            "[format.inherit](#const_format.inherit)",
            "[format.price](#const_format.price)",
            "[format.volume](#const_format.volume)"
          ]
        },
        {
          "name": "format.mintick",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[indicator()](#fun_indicator)",
            "[format.inherit](#const_format.inherit)",
            "[format.price](#const_format.price)",
            "[format.volume](#const_format.volume)"
          ]
        },
        {
          "name": "dayofweek.sunday",
          "type": "const int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[dayofweek.monday](#const_dayofweek.monday)",
            "[dayofweek.tuesday](#const_dayofweek.tuesday)",
            "[dayofweek.wednesday](#const_dayofweek.wednesday)",
            "[dayofweek.thursday](#const_dayofweek.thursday)",
            "[dayofweek.friday](#const_dayofweek.friday)",
            "[dayofweek.saturday](#const_dayofweek.saturday)"
          ]
        },
        {
          "name": "dayofweek.monday",
          "type": "const int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[dayofweek.sunday](#const_dayofweek.sunday)",
            "[dayofweek.tuesday](#const_dayofweek.tuesday)",
            "[dayofweek.wednesday](#const_dayofweek.wednesday)",
            "[dayofweek.thursday](#const_dayofweek.thursday)",
            "[dayofweek.friday](#const_dayofweek.friday)",
            "[dayofweek.saturday](#const_dayofweek.saturday)"
          ]
        },
        {
          "name": "dayofweek.tuesday",
          "type": "const int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[dayofweek.sunday](#const_dayofweek.sunday)",
            "[dayofweek.monday](#const_dayofweek.monday)",
            "[dayofweek.wednesday](#const_dayofweek.wednesday)",
            "[dayofweek.thursday](#const_dayofweek.thursday)",
            "[dayofweek.friday](#const_dayofweek.friday)",
            "[dayofweek.saturday](#const_dayofweek.saturday)"
          ]
        },
        {
          "name": "dayofweek.wednesday",
          "type": "const int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[dayofweek.sunday](#const_dayofweek.sunday)",
            "[dayofweek.monday](#const_dayofweek.monday)",
            "[dayofweek.tuesday](#const_dayofweek.tuesday)",
            "[dayofweek.thursday](#const_dayofweek.thursday)",
            "[dayofweek.friday](#const_dayofweek.friday)",
            "[dayofweek.saturday](#const_dayofweek.saturday)"
          ]
        },
        {
          "name": "dayofweek.thursday",
          "type": "const int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[dayofweek.sunday](#const_dayofweek.sunday)",
            "[dayofweek.monday](#const_dayofweek.monday)",
            "[dayofweek.tuesday](#const_dayofweek.tuesday)",
            "[dayofweek.wednesday](#const_dayofweek.wednesday)",
            "[dayofweek.friday](#const_dayofweek.friday)",
            "[dayofweek.saturday](#const_dayofweek.saturday)"
          ]
        },
        {
          "name": "dayofweek.friday",
          "type": "const int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[dayofweek.sunday](#const_dayofweek.sunday)",
            "[dayofweek.monday](#const_dayofweek.monday)",
            "[dayofweek.tuesday](#const_dayofweek.tuesday)",
            "[dayofweek.wednesday](#const_dayofweek.wednesday)",
            "[dayofweek.thursday](#const_dayofweek.thursday)",
            "[dayofweek.saturday](#const_dayofweek.saturday)"
          ]
        },
        {
          "name": "dayofweek.saturday",
          "type": "const int",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[dayofweek.sunday](#const_dayofweek.sunday)",
            "[dayofweek.monday](#const_dayofweek.monday)",
            "[dayofweek.tuesday](#const_dayofweek.tuesday)",
            "[dayofweek.wednesday](#const_dayofweek.wednesday)",
            "[dayofweek.thursday](#const_dayofweek.thursday)",
            "[dayofweek.friday](#const_dayofweek.friday)"
          ]
        },
        {
          "name": "shape.xcross",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)"
          ]
        },
        {
          "name": "shape.cross",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)"
          ]
        },
        {
          "name": "shape.circle",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)"
          ]
        },
        {
          "name": "shape.triangleup",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)"
          ]
        },
        {
          "name": "shape.triangledown",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)"
          ]
        },
        {
          "name": "shape.flag",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)"
          ]
        },
        {
          "name": "shape.arrowup",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)"
          ]
        },
        {
          "name": "shape.arrowdown",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)"
          ]
        },
        {
          "name": "shape.labelup",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)"
          ]
        },
        {
          "name": "shape.labeldown",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)"
          ]
        },
        {
          "name": "shape.square",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)"
          ]
        },
        {
          "name": "shape.diamond",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)"
          ]
        },
        {
          "name": "location.abovebar",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[location.belowbar](#const_location.belowbar)",
            "[location.top](#const_location.top)",
            "[location.bottom](#const_location.bottom)",
            "[location.absolute](#const_location.absolute)"
          ]
        },
        {
          "name": "location.belowbar",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[location.abovebar](#const_location.abovebar)",
            "[location.top](#const_location.top)",
            "[location.bottom](#const_location.bottom)",
            "[location.absolute](#const_location.absolute)"
          ]
        },
        {
          "name": "location.top",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[location.abovebar](#const_location.abovebar)",
            "[location.belowbar](#const_location.belowbar)",
            "[location.bottom](#const_location.bottom)",
            "[location.absolute](#const_location.absolute)"
          ]
        },
        {
          "name": "location.bottom",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[location.abovebar](#const_location.abovebar)",
            "[location.belowbar](#const_location.belowbar)",
            "[location.top](#const_location.top)",
            "[location.absolute](#const_location.absolute)"
          ]
        },
        {
          "name": "location.absolute",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[location.abovebar](#const_location.abovebar)",
            "[location.belowbar](#const_location.belowbar)",
            "[location.top](#const_location.top)",
            "[location.bottom](#const_location.bottom)"
          ]
        },
        {
          "name": "scale.right",
          "type": "const scale_type",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[indicator()](#fun_indicator)"
          ]
        },
        {
          "name": "scale.left",
          "type": "const scale_type",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[indicator()](#fun_indicator)"
          ]
        },
        {
          "name": "scale.none",
          "type": "const scale_type",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[indicator()](#fun_indicator)"
          ]
        },
        {
          "name": "strategy.oca.none",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.entry()](#fun_strategy.entry)",
            "[strategy.exit()](#fun_strategy.exit)",
            "[strategy.order()](#fun_strategy.order)"
          ]
        },
        {
          "name": "strategy.oca.cancel",
          "type": "const string",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[strategy.entry()](#fun_strategy.entry)",
            "[strategy.exit()](#fun_strategy.exit)",
            "[strategy.order()](#fun_strategy.order)"
          ]
        },
        {
          "name": "strategy.oca.reduce",
          "type": "const string",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[strategy.entry()](#fun_strategy.entry)",
            "[strategy.exit()](#fun_strategy.exit)",
            "[strategy.order()](#fun_strategy.order)"
          ]
        },
        {
          "name": "strategy.commission.percent",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "strategy.commission.cash_per_contract",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "strategy.commission.cash_per_order",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "strategy.fixed",
          "type": "const string",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nstrategy(\"strategy.fixed\", overlay = true, default_qty_value = 50, default_qty_type = strategy.fixed, initial_capital = 1000000)\n\nif bar_index == 0\n    // As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 contracts.\n    // qty = 50\n    strategy.entry(\"EN\", strategy.long)\nif bar_index == 2\n    strategy.close(\"EN\")"
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "strategy.cash",
          "type": "const string",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nstrategy(\"strategy.cash\", overlay = true, default_qty_value = 50, default_qty_type = strategy.cash, initial_capital = 1000000)\n\nif bar_index == 0\n    // As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 units of cash in the currency of `strategy.account_currency`.\n    // `qty` is calculated as (default_qty_value)/(close price). If current price is $5, then qty = 50/5 = 10.\n    strategy.entry(\"EN\", strategy.long)\nif bar_index == 2\n    strategy.close(\"EN\")"
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "strategy.percent_of_equity",
          "type": "const string",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nstrategy(\"strategy.percent_of_equity\", overlay = false, default_qty_value = 100, default_qty_type = strategy.percent_of_equity, initial_capital = 1000000)\n\n// As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 100% of available equity.\nif bar_index == 0\n    strategy.entry(\"EN\", strategy.long)\nif bar_index == 2\n    strategy.close(\"EN\")\nplot(strategy.equity)\n\n // The ‘qty’ parameter is set to 10. Entering position with fixed size of 10 contracts and entry market price = (10 * close).\nif bar_index == 4\n    strategy.entry(\"EN\", strategy.long, qty = 10)\nif bar_index == 6\n    strategy.close(\"EN\")"
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "strategy.direction.all",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.risk.allow_entry_in()](#fun_strategy.risk.allow_entry_in)"
          ]
        },
        {
          "name": "strategy.direction.long",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.risk.allow_entry_in()](#fun_strategy.risk.allow_entry_in)"
          ]
        },
        {
          "name": "strategy.direction.short",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.risk.allow_entry_in()](#fun_strategy.risk.allow_entry_in)"
          ]
        },
        {
          "name": "currency.NONE",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.USD",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.EUR",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.AUD",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.GBP",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.NZD",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.CAD",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.CHF",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.HKD",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.JPY",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.NOK",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.SEK",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.SGD",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.TRY",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.ZAR",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.RUB",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.BTC",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.ETH",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.MYR",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.KRW",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.USDT",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.INR",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.PLN",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.PKR",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.EGP",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.AED",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.COP",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.MXN",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.CLP",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.BRL",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.ARS",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.PEN",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.IDR",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.SAR",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.BDT",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.BHD",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.CNY",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.CZK",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.DKK",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.HUF",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.ILS",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.ISK",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.KES",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.KWD",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.LKR",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.MAD",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.NGN",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.PHP",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.QAR",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.RON",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.RSD",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.THB",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.TND",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.TWD",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.VES",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "currency.VND",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)"
          ]
        },
        {
          "name": "barmerge.lookahead_off",
          "type": "const barmerge_lookahead",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[request.security()](#fun_request.security)",
            "[barmerge.lookahead_on](#const_barmerge.lookahead_on)"
          ]
        },
        {
          "name": "barmerge.lookahead_on",
          "type": "const barmerge_lookahead",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[request.security()](#fun_request.security)",
            "[barmerge.lookahead_off](#const_barmerge.lookahead_off)"
          ]
        },
        {
          "name": "barmerge.gaps_off",
          "type": "const barmerge_gaps",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[request.security()](#fun_request.security)",
            "[barmerge.gaps_on](#const_barmerge.gaps_on)"
          ]
        },
        {
          "name": "barmerge.gaps_on",
          "type": "const barmerge_gaps",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[request.security()](#fun_request.security)",
            "[barmerge.gaps_off](#const_barmerge.gaps_off)"
          ]
        },
        {
          "name": "xloc.bar_index",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[xloc.bar_time](#const_xloc.bar_time)",
            "[line.new()](#fun_line.new)",
            "[label.new()](#fun_label.new)",
            "[box.new()](#fun_box.new)",
            "[polyline.new()](#fun_polyline.new)",
            "[line.set_xloc()](#fun_line.set_xloc)",
            "[label.set_xloc()](#fun_label.set_xloc)"
          ]
        },
        {
          "name": "xloc.bar_time",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[xloc.bar_index](#const_xloc.bar_index)",
            "[line.new()](#fun_line.new)",
            "[label.new()](#fun_label.new)",
            "[box.new()](#fun_box.new)",
            "[polyline.new()](#fun_polyline.new)",
            "[line.set_xloc()](#fun_line.set_xloc)",
            "[label.set_xloc()](#fun_label.set_xloc)",
            "[xloc.bar_index](#const_xloc.bar_index)"
          ]
        },
        {
          "name": "yloc.price",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_yloc()](#fun_label.set_yloc)",
            "[yloc.abovebar](#const_yloc.abovebar)",
            "[yloc.belowbar](#const_yloc.belowbar)"
          ]
        },
        {
          "name": "yloc.abovebar",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_yloc()](#fun_label.set_yloc)",
            "[yloc.price](#const_yloc.price)",
            "[yloc.belowbar](#const_yloc.belowbar)"
          ]
        },
        {
          "name": "yloc.belowbar",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_yloc()](#fun_label.set_yloc)",
            "[yloc.price](#const_yloc.price)",
            "[yloc.abovebar](#const_yloc.abovebar)"
          ]
        },
        {
          "name": "extend.none",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[line.set_extend()](#fun_line.set_extend)",
            "[extend.left](#const_extend.left)",
            "[extend.right](#const_extend.right)",
            "[extend.both](#const_extend.both)"
          ]
        },
        {
          "name": "extend.left",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[line.set_extend()](#fun_line.set_extend)",
            "[extend.none](#const_extend.none)",
            "[extend.right](#const_extend.right)",
            "[extend.both](#const_extend.both)"
          ]
        },
        {
          "name": "extend.right",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[line.set_extend()](#fun_line.set_extend)",
            "[extend.none](#const_extend.none)",
            "[extend.left](#const_extend.left)",
            "[extend.both](#const_extend.both)"
          ]
        },
        {
          "name": "extend.both",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[line.set_extend()](#fun_line.set_extend)",
            "[extend.none](#const_extend.none)",
            "[extend.left](#const_extend.left)",
            "[extend.right](#const_extend.right)"
          ]
        },
        {
          "name": "label.style_none",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_xcross",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_cross",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_triangleup",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_triangledown",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_flag",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_circle",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_arrowup",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_arrowdown",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_label_up",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_label_down",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_label_left",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_label_right",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_label_lower_left",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_label_lower_right",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_label_upper_left",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_label_upper_right",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_label_center",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_square",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "label.style_diamond",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)"
          ]
        },
        {
          "name": "label.style_text_outline",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.style_none](#const_label.style_none)",
            "[label.style_xcross](#const_label.style_xcross)",
            "[label.style_cross](#const_label.style_cross)",
            "[label.style_triangleup](#const_label.style_triangleup)",
            "[label.style_triangledown](#const_label.style_triangledown)",
            "[label.style_flag](#const_label.style_flag)",
            "[label.style_circle](#const_label.style_circle)",
            "[label.style_arrowup](#const_label.style_arrowup)",
            "[label.style_arrowdown](#const_label.style_arrowdown)",
            "[label.style_label_up](#const_label.style_label_up)",
            "[label.style_label_down](#const_label.style_label_down)",
            "[label.style_label_left](#const_label.style_label_left)",
            "[label.style_label_right](#const_label.style_label_right)",
            "[label.style_label_lower_left](#const_label.style_label_lower_left)",
            "[label.style_label_lower_right](#const_label.style_label_lower_right)",
            "[label.style_label_upper_left](#const_label.style_label_upper_left)",
            "[label.style_label_upper_right](#const_label.style_label_upper_right)",
            "[label.style_label_center](#const_label.style_label_center)",
            "[label.style_square](#const_label.style_square)",
            "[label.style_diamond](#const_label.style_diamond)"
          ]
        },
        {
          "name": "display.none",
          "type": "const plot_simple_display",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[plotarrow()](#fun_plotarrow)",
            "[plotbar()](#fun_plotbar)",
            "[plotcandle()](#fun_plotcandle)"
          ]
        },
        {
          "name": "display.pane",
          "type": "const plot_display",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[plotarrow()](#fun_plotarrow)",
            "[plotbar()](#fun_plotbar)",
            "[plotcandle()](#fun_plotcandle)"
          ]
        },
        {
          "name": "display.data_window",
          "type": "const plot_display",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[plotarrow()](#fun_plotarrow)",
            "[plotbar()](#fun_plotbar)",
            "[plotcandle()](#fun_plotcandle)"
          ]
        },
        {
          "name": "display.price_scale",
          "type": "const plot_display",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[plotarrow()](#fun_plotarrow)",
            "[plotbar()](#fun_plotbar)",
            "[plotcandle()](#fun_plotcandle)"
          ]
        },
        {
          "name": "display.status_line",
          "type": "const plot_display",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[plotarrow()](#fun_plotarrow)",
            "[plotbar()](#fun_plotbar)",
            "[plotcandle()](#fun_plotcandle)"
          ]
        },
        {
          "name": "display.pine_screener",
          "type": "const plot_display",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[plotarrow()](#fun_plotarrow)",
            "[plotbar()](#fun_plotbar)",
            "[plotcandle()](#fun_plotcandle)"
          ]
        },
        {
          "name": "display.all",
          "type": "const plot_simple_display",
          "desc": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[plotarrow()](#fun_plotarrow)",
            "[plotbar()](#fun_plotbar)",
            "[plotcandle()](#fun_plotcandle)"
          ]
        },
        {
          "name": "text.format_none",
          "type": "const text_format",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[box.new()](#fun_box.new)",
            "[table.cell()](#fun_table.cell)"
          ]
        },
        {
          "name": "text.format_bold",
          "type": "const text_format",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[box.new()](#fun_box.new)",
            "[table.cell()](#fun_table.cell)"
          ]
        },
        {
          "name": "text.format_italic",
          "type": "const text_format",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[box.new()](#fun_box.new)",
            "[table.cell()](#fun_table.cell)"
          ]
        },
        {
          "name": "line.style_solid",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[line.set_style()](#fun_line.set_style)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_right](#const_line.style_arrow_right)",
            "[line.style_arrow_both](#const_line.style_arrow_both)"
          ]
        },
        {
          "name": "line.style_dotted",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[line.set_style()](#fun_line.set_style)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_right](#const_line.style_arrow_right)",
            "[line.style_arrow_both](#const_line.style_arrow_both)"
          ]
        },
        {
          "name": "line.style_dashed",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[line.set_style()](#fun_line.set_style)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_right](#const_line.style_arrow_right)",
            "[line.style_arrow_both](#const_line.style_arrow_both)"
          ]
        },
        {
          "name": "line.style_arrow_left",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[line.set_style()](#fun_line.set_style)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_right](#const_line.style_arrow_right)",
            "[line.style_arrow_both](#const_line.style_arrow_both)"
          ]
        },
        {
          "name": "line.style_arrow_right",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[line.set_style()](#fun_line.set_style)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_both](#const_line.style_arrow_both)"
          ]
        },
        {
          "name": "line.style_arrow_both",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[line.set_style()](#fun_line.set_style)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_right](#const_line.style_arrow_right)"
          ]
        },
        {
          "name": "text.align_center",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[text.align_left](#const_text.align_left)",
            "[text.align_right](#const_text.align_right)"
          ]
        },
        {
          "name": "text.align_left",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[text.align_center](#const_text.align_center)",
            "[text.align_right](#const_text.align_right)"
          ]
        },
        {
          "name": "text.align_right",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_style()](#fun_label.set_style)",
            "[text.align_center](#const_text.align_center)",
            "[text.align_left](#const_text.align_left)"
          ]
        },
        {
          "name": "text.align_top",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[table.cell()](#fun_table.cell)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[text.align_center](#const_text.align_center)",
            "[text.align_left](#const_text.align_left)",
            "[text.align_right](#const_text.align_right)"
          ]
        },
        {
          "name": "text.align_bottom",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[table.cell()](#fun_table.cell)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[text.align_center](#const_text.align_center)",
            "[text.align_left](#const_text.align_left)",
            "[text.align_right](#const_text.align_right)"
          ]
        },
        {
          "name": "font.family_default",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.set_text_font_family()](#fun_box.set_text_font_family)",
            "[label.new()](#fun_label.new)",
            "[label.set_text_font_family()](#fun_label.set_text_font_family)",
            "[table.cell()](#fun_table.cell)",
            "[table.cell_set_text_font_family()](#fun_table.cell_set_text_font_family)",
            "[font.family_monospace](#const_font.family_monospace)"
          ]
        },
        {
          "name": "font.family_monospace",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.set_text_font_family()](#fun_box.set_text_font_family)",
            "[label.new()](#fun_label.new)",
            "[label.set_text_font_family()](#fun_label.set_text_font_family)",
            "[table.cell()](#fun_table.cell)",
            "[table.cell_set_text_font_family()](#fun_table.cell_set_text_font_family)",
            "[font.family_default](#const_font.family_default)"
          ]
        },
        {
          "name": "text.wrap_auto",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_wrap()](#fun_box.set_text_wrap)"
          ]
        },
        {
          "name": "text.wrap_none",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_wrap()](#fun_box.set_text_wrap)"
          ]
        },
        {
          "name": "order.ascending",
          "type": "const sort_order",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.sort()](#fun_array.sort)"
          ]
        },
        {
          "name": "order.descending",
          "type": "const sort_order",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.sort()](#fun_array.sort)"
          ]
        },
        {
          "name": "alert.freq_all",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[alert()](#fun_alert)"
          ]
        },
        {
          "name": "alert.freq_once_per_bar",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[alert()](#fun_alert)"
          ]
        },
        {
          "name": "alert.freq_once_per_bar_close",
          "type": "const string",
          "desc": [
            "",
            ""
          ],
          "seeAlso": [
            "[alert()](#fun_alert)"
          ]
        },
        {
          "name": "earnings.actual",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[request.earnings()](#fun_request.earnings)"
          ]
        },
        {
          "name": "earnings.estimate",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[request.earnings()](#fun_request.earnings)"
          ]
        },
        {
          "name": "earnings.standardized",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[request.earnings()](#fun_request.earnings)"
          ]
        },
        {
          "name": "dividends.net",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[request.dividends()](#fun_request.dividends)"
          ]
        },
        {
          "name": "dividends.gross",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[request.dividends()](#fun_request.dividends)"
          ]
        },
        {
          "name": "splits.denominator",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[request.splits()](#fun_request.splits)"
          ]
        },
        {
          "name": "splits.numerator",
          "type": "const string",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[request.splits()](#fun_request.splits)"
          ]
        },
        {
          "name": "true",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[bool](#type_bool)"
          ]
        },
        {
          "name": "false",
          "desc": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[bool](#type_bool)"
          ]
        },
        {
          "name": "strategy.long",
          "type": "const strategy_direction",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.entry()](#fun_strategy.entry)",
            "[strategy.exit()](#fun_strategy.exit)",
            "[strategy.order()](#fun_strategy.order)"
          ]
        },
        {
          "name": "strategy.short",
          "type": "const strategy_direction",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[strategy.entry()](#fun_strategy.entry)",
            "[strategy.exit()](#fun_strategy.exit)",
            "[strategy.order()](#fun_strategy.order)"
          ]
        },
        {
          "name": "settlement_as_close.inherit",
          "type": "const settlement",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[ticker.new()](#fun_ticker.new)",
            "[ticker.modify()](#fun_ticker.modify)",
            "[settlement_as_close.on](#const_settlement_as_close.on)",
            "[settlement_as_close.off](#const_settlement_as_close.off)"
          ]
        },
        {
          "name": "settlement_as_close.on",
          "type": "const settlement",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[ticker.new()](#fun_ticker.new)",
            "[ticker.modify()](#fun_ticker.modify)",
            "[settlement_as_close.inherit](#const_settlement_as_close.inherit)",
            "[settlement_as_close.off](#const_settlement_as_close.off)"
          ]
        },
        {
          "name": "settlement_as_close.off",
          "type": "const settlement",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[ticker.new()](#fun_ticker.new)",
            "[ticker.modify()](#fun_ticker.modify)",
            "[settlement_as_close.on](#const_settlement_as_close.on)",
            "[settlement_as_close.inherit](#const_settlement_as_close.inherit)"
          ]
        },
        {
          "name": "backadjustment.inherit",
          "type": "const backadjustment",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[ticker.new()](#fun_ticker.new)",
            "[ticker.modify()](#fun_ticker.modify)",
            "[backadjustment.on](#const_backadjustment.on)",
            "[backadjustment.off](#const_backadjustment.off)"
          ]
        },
        {
          "name": "backadjustment.on",
          "type": "const backadjustment",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[ticker.new()](#fun_ticker.new)",
            "[ticker.modify()](#fun_ticker.modify)",
            "[backadjustment.inherit](#const_backadjustment.inherit)",
            "[backadjustment.off](#const_backadjustment.off)"
          ]
        },
        {
          "name": "backadjustment.off",
          "type": "const backadjustment",
          "desc": [
            ""
          ],
          "seeAlso": [
            "[ticker.new()](#fun_ticker.new)",
            "[ticker.modify()](#fun_ticker.modify)",
            "[backadjustment.on](#const_backadjustment.on)",
            "[backadjustment.inherit](#const_backadjustment.inherit)"
          ]
        },
        {
          "name": "color.black",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#363A45",
          "seeAlso": [
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.silver",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#B2B5BE",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.gray",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#787B86",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.white",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#FFFFFF",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.maroon",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#880E4F",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.red",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#F23645",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.purple",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#9C27B0",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.fuchsia",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#E040FB",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.green",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#4CAF50",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.lime",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#00E676",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.olive",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#808000",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.yellow",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#FDD835",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.navy",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#311B92",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.blue",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#2962ff",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.teal",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#089981",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.aqua](#const_color.aqua)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.aqua",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#00BCD4",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.orange](#const_color.orange)"
          ]
        },
        {
          "name": "color.orange",
          "type": "const color",
          "desc": [
            ""
          ],
          "color": "#FF9800",
          "seeAlso": [
            "[color.black](#const_color.black)",
            "[color.silver](#const_color.silver)",
            "[color.gray](#const_color.gray)",
            "[color.white](#const_color.white)",
            "[color.maroon](#const_color.maroon)",
            "[color.red](#const_color.red)",
            "[color.purple](#const_color.purple)",
            "[color.fuchsia](#const_color.fuchsia)",
            "[color.green](#const_color.green)",
            "[color.lime](#const_color.lime)",
            "[color.olive](#const_color.olive)",
            "[color.yellow](#const_color.yellow)",
            "[color.navy](#const_color.navy)",
            "[color.blue](#const_color.blue)",
            "[color.teal](#const_color.teal)",
            "[color.aqua](#const_color.aqua)"
          ]
        }
      ]
    }
  ],
  "functions": [
    {
      "title": "Built-in Function",
      "docs": [
        {
          "name": "indicator",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "title",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "shorttitle",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "format",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "precision",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "scale",
              "desc": "",
              "allowedTypeIDs": [
                "const scale_type"
              ],
              "displayType": "const scale_type"
            },
            {
              "name": "max_bars_back",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "timeframe",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "timeframe_gaps",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "explicit_plot_zorder",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "max_lines_count",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "max_labels_count",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "max_boxes_count",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "calc_bars_count",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "max_polylines_count",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "dynamic_requests",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "behind_chart",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"My script\", shorttitle=\"Script\")\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)",
            "[library()](#fun_library)"
          ],
          "syntax": [
            "indicator(title, shorttitle, overlay, format, precision, scale, max_bars_back, timeframe, timeframe_gaps, explicit_plot_zorder, max_lines_count, max_labels_count, max_boxes_count, calc_bars_count, max_polylines_count, dynamic_requests, behind_chart) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "plot",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "series",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "linewidth",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "style",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_style",
                "const plot_style"
              ],
              "displayType": "input plot_style"
            },
            {
              "name": "trackprice",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "histbase",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            },
            {
              "name": "offset",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "join",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "editable",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "show_last",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_display",
                "const plot_display",
                "input plot_simple_display",
                "const plot_simple_display"
              ],
              "displayType": "input plot_display"
            },
            {
              "name": "format",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "precision",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "linestyle",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_line_style",
                "const plot_line_style"
              ],
              "displayType": "input plot_line_style"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"plot\")\nplot(high+low, title='Title', color=color.new(#00ffaa, 70), linewidth=2, style=plot.style_area, offset=15, trackprice=true)\n\n// You may fill the background between any two plots with a fill() function:\np1 = plot(open)\np2 = plot(close)\nfill(p1, p2, color=color.new(color.green, 90))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[plotarrow()](#fun_plotarrow)",
            "[barcolor()](#fun_barcolor)",
            "[bgcolor()](#fun_bgcolor)",
            "[fill()](#fun_fill)"
          ],
          "syntax": [
            "plot(series, title, color, linewidth, style, trackprice, histbase, offset, join, editable, show_last, display, format, precision, force_overlay, linestyle) → plot"
          ],
          "returnedTypes": [
            "plot"
          ]
        },
        {
          "name": "plotshape",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "series",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series int/float/bool"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "style",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "location",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "offset",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "text",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "textcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "editable",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "show_last",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_display",
                "const plot_display",
                "input plot_simple_display",
                "const plot_simple_display"
              ],
              "displayType": "input plot_display"
            },
            {
              "name": "format",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "precision",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"plotshape example 1\", overlay=true)\ndata = close >= open\nplotshape(data, style=shape.xcross)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plotchar()](#fun_plotchar)",
            "[plotarrow()](#fun_plotarrow)",
            "[barcolor()](#fun_barcolor)",
            "[bgcolor()](#fun_bgcolor)"
          ],
          "syntax": [
            "plotshape(series, title, style, location, color, offset, text, textcolor, editable, size, show_last, display, format, precision, force_overlay) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "plotchar",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "series",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series int/float/bool"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "char",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "location",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "offset",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "text",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "textcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "editable",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "show_last",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_display",
                "const plot_display",
                "input plot_simple_display",
                "const plot_simple_display"
              ],
              "displayType": "input plot_display"
            },
            {
              "name": "format",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "precision",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"plotchar example\", overlay=true)\ndata = close >= open\nplotchar(data, char='❄')"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plotshape()](#fun_plotshape)",
            "[plotarrow()](#fun_plotarrow)",
            "[barcolor()](#fun_barcolor)",
            "[bgcolor()](#fun_bgcolor)"
          ],
          "syntax": [
            "plotchar(series, title, char, location, color, offset, text, textcolor, editable, size, show_last, display, format, precision, force_overlay) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "plotarrow",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "series",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "colorup",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "colordown",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "offset",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "minheight",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "maxheight",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "editable",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "show_last",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_display",
                "const plot_display",
                "input plot_simple_display",
                "const plot_simple_display"
              ],
              "displayType": "input plot_display"
            },
            {
              "name": "format",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "precision",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"plotarrow example\", overlay=true)\ncodiff = close - open\nplotarrow(codiff, colorup=color.new(color.teal,40), colordown=color.new(color.orange, 40))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[plotshape()](#fun_plotshape)",
            "[plotchar()](#fun_plotchar)",
            "[barcolor()](#fun_barcolor)",
            "[bgcolor()](#fun_bgcolor)"
          ],
          "syntax": [
            "plotarrow(series, title, colorup, colordown, offset, minheight, maxheight, editable, show_last, display, format, precision, force_overlay) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "plotbar",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "open",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "high",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "low",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "close",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "editable",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "show_last",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_display",
                "const plot_display",
                "input plot_simple_display",
                "const plot_simple_display"
              ],
              "displayType": "input plot_display"
            },
            {
              "name": "format",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "precision",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"plotbar example\", overlay=true)\nplotbar(open, high, low, close, title='Title', color = open < close ? color.green : color.red)"
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[plotcandle()](#fun_plotcandle)"
          ],
          "syntax": [
            "plotbar(open, high, low, close, title, color, editable, show_last, display, format, precision, force_overlay) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "plotcandle",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "open",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "high",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "low",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "close",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "wickcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "editable",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "show_last",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "bordercolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_display",
                "const plot_display",
                "input plot_simple_display",
                "const plot_simple_display"
              ],
              "displayType": "input plot_display"
            },
            {
              "name": "format",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "precision",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"plotcandle example\", overlay=true)\nplotcandle(open, high, low, close, title='Title', color = open < close ? color.green : color.red, wickcolor=color.black)"
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[plotbar()](#fun_plotbar)"
          ],
          "syntax": [
            "plotcandle(open, high, low, close, title, color, wickcolor, editable, show_last, bordercolor, display, format, precision, force_overlay) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "barcolor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "offset",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "editable",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "show_last",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_simple_display",
                "const plot_simple_display"
              ],
              "displayType": "input plot_simple_display"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"barcolor example\", overlay=true)\nbarcolor(close < open ? color.black : color.white)"
          ],
          "seeAlso": [
            "[bgcolor()](#fun_bgcolor)",
            "[plot()](#fun_plot)",
            "[fill()](#fun_fill)"
          ],
          "syntax": [
            "barcolor(color, offset, editable, show_last, title, display) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "bgcolor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "offset",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "editable",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "show_last",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_simple_display",
                "const plot_simple_display"
              ],
              "displayType": "input plot_simple_display"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"bgcolor example\", overlay=true)\nbgcolor(close < open ? color.new(color.red,70) : color.new(color.green, 70))"
          ],
          "seeAlso": [
            "[barcolor()](#fun_barcolor)",
            "[plot()](#fun_plot)",
            "[fill()](#fun_fill)"
          ],
          "syntax": [
            "bgcolor(color, offset, editable, show_last, title, display, force_overlay) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "color.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const color"
              ],
              "displayType": "const color"
            },
            {
              "name": "transp",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.new\", overlay=true)\nplot(close, color=color.new(color.red, 50))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "color.new(color, transp) → const color"
          ],
          "returnedTypes": [
            "const color"
          ]
        },
        {
          "name": "color.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "transp",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.new\", overlay=true)\nplot(close, color=color.new(color.red, 50))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "color.new(color, transp) → series color"
          ],
          "returnedTypes": [
            "series color"
          ]
        },
        {
          "name": "color.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input color",
                "const color"
              ],
              "displayType": "input color"
            },
            {
              "name": "transp",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.new\", overlay=true)\nplot(close, color=color.new(color.red, 50))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "color.new(color, transp) → input color"
          ],
          "returnedTypes": [
            "input color"
          ]
        },
        {
          "name": "color.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "simple color"
            },
            {
              "name": "transp",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.new\", overlay=true)\nplot(close, color=color.new(color.red, 50))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "color.new(color, transp) → simple color"
          ],
          "returnedTypes": [
            "simple color"
          ]
        },
        {
          "name": "color.rgb",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "red",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "green",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "blue",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "transp",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.rgb\", overlay=true)\nplot(close, color=color.rgb(255, 0, 0, 50))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "color.rgb(red, green, blue, transp) → series color"
          ],
          "returnedTypes": [
            "series color"
          ]
        },
        {
          "name": "color.rgb",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "red",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "green",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "blue",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "transp",
              "desc": "",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.rgb\", overlay=true)\nplot(close, color=color.rgb(255, 0, 0, 50))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "color.rgb(red, green, blue, transp) → const color"
          ],
          "returnedTypes": [
            "const color"
          ]
        },
        {
          "name": "color.rgb",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "red",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            },
            {
              "name": "green",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            },
            {
              "name": "blue",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            },
            {
              "name": "transp",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.rgb\", overlay=true)\nplot(close, color=color.rgb(255, 0, 0, 50))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "color.rgb(red, green, blue, transp) → input color"
          ],
          "returnedTypes": [
            "input color"
          ]
        },
        {
          "name": "color.rgb",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "red",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "green",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "blue",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "transp",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.rgb\", overlay=true)\nplot(close, color=color.rgb(255, 0, 0, 50))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "color.rgb(red, green, blue, transp) → simple color"
          ],
          "returnedTypes": [
            "simple color"
          ]
        },
        {
          "name": "color.r",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.r\", overlay=true)\nplot(color.r(color.red))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.r(color) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "color.r",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const color"
              ],
              "displayType": "const color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.r\", overlay=true)\nplot(color.r(color.red))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.r(color) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "color.r",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input color",
                "const color"
              ],
              "displayType": "input color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.r\", overlay=true)\nplot(color.r(color.red))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.r(color) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "color.r",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "simple color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.r\", overlay=true)\nplot(color.r(color.red))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.r(color) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "color.g",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.g\", overlay=true)\nplot(color.g(color.green))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.g(color) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "color.g",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const color"
              ],
              "displayType": "const color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.g\", overlay=true)\nplot(color.g(color.green))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.g(color) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "color.g",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input color",
                "const color"
              ],
              "displayType": "input color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.g\", overlay=true)\nplot(color.g(color.green))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.g(color) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "color.g",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "simple color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.g\", overlay=true)\nplot(color.g(color.green))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.g(color) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "color.b",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.b\", overlay=true)\nplot(color.b(color.blue))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.b(color) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "color.b",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const color"
              ],
              "displayType": "const color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.b\", overlay=true)\nplot(color.b(color.blue))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.b(color) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "color.b",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input color",
                "const color"
              ],
              "displayType": "input color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.b\", overlay=true)\nplot(color.b(color.blue))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.b(color) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "color.b",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "simple color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.b\", overlay=true)\nplot(color.b(color.blue))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.b(color) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "color.t",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.t\", overlay=true)\nplot(color.t(color.new(color.red, 50)))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.t(color) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "color.t",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const color"
              ],
              "displayType": "const color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.t\", overlay=true)\nplot(color.t(color.new(color.red, 50)))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.t(color) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "color.t",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input color",
                "const color"
              ],
              "displayType": "input color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.t\", overlay=true)\nplot(color.t(color.new(color.red, 50)))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.t(color) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "color.t",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "simple color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.t\", overlay=true)\nplot(color.t(color.new(color.red, 50)))"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "color.t(color) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "color.from_gradient",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "bottom_value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "top_value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "bottom_color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "top_color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"color.from_gradient\", overlay=true)\ncolor1 = color.from_gradient(close, low, high, color.yellow, color.lime)\ncolor2 = color.from_gradient(ta.rsi(close, 7), 0, 100, color.rgb(255, 0, 0), color.rgb(0, 255, 0, 50))\nplot(close, color=color1)\nplot(ta.rsi(close,7), color=color2)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "color.from_gradient(value, bottom_value, top_value, bottom_color, top_color) → series color"
          ],
          "returnedTypes": [
            "series color"
          ]
        },
        {
          "name": "alertcondition",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "condition",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "message",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"alertcondition\", overlay=true)\nalertcondition(close >= open, title='Alert on Green Bar', message='Green Bar!')"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[alert()](#fun_alert)"
          ],
          "syntax": [
            "alertcondition(condition, title, message) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "input",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "displayType": "const int/float/bool/string/color or source-type built-ins",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const bool"
              ]
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input\", overlay=true)\ni_switch = input(true, \"On/Off\")\nplot(i_switch ? open : na)\n\ni_len = input(7, \"Length\")\ni_src = input(close, \"Source\")\nplot(ta.sma(i_src, i_len))\n\ni_border = input(142.50, \"Price Border\")\nhline(i_border)\nbgcolor(close > i_border ? color.green : color.red)\n\ni_col = input(color.red, \"Plot Color\")\nplot(close, color=i_col)\n\ni_text = input(\"Hello!\", \"Message\")\nl = label.new(bar_index, high, text=i_text)\nlabel.delete(l[1])"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.color()](#fun_input.color)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.time()](#fun_input.time)"
          ],
          "syntax": [
            "input(defval, title, tooltip, inline, group, display, active) → input bool"
          ],
          "returnedTypes": [
            "input bool"
          ]
        },
        {
          "name": "input",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "displayType": "const int/float/bool/string/color or source-type built-ins",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const color"
              ]
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input\", overlay=true)\ni_switch = input(true, \"On/Off\")\nplot(i_switch ? open : na)\n\ni_len = input(7, \"Length\")\ni_src = input(close, \"Source\")\nplot(ta.sma(i_src, i_len))\n\ni_border = input(142.50, \"Price Border\")\nhline(i_border)\nbgcolor(close > i_border ? color.green : color.red)\n\ni_col = input(color.red, \"Plot Color\")\nplot(close, color=i_col)\n\ni_text = input(\"Hello!\", \"Message\")\nl = label.new(bar_index, high, text=i_text)\nlabel.delete(l[1])"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.color()](#fun_input.color)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.time()](#fun_input.time)"
          ],
          "syntax": [
            "input(defval, title, tooltip, inline, group, display, active) → input color"
          ],
          "returnedTypes": [
            "input color"
          ]
        },
        {
          "name": "input",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "displayType": "const int/float/bool/string/color or source-type built-ins",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int"
              ]
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input\", overlay=true)\ni_switch = input(true, \"On/Off\")\nplot(i_switch ? open : na)\n\ni_len = input(7, \"Length\")\ni_src = input(close, \"Source\")\nplot(ta.sma(i_src, i_len))\n\ni_border = input(142.50, \"Price Border\")\nhline(i_border)\nbgcolor(close > i_border ? color.green : color.red)\n\ni_col = input(color.red, \"Plot Color\")\nplot(close, color=i_col)\n\ni_text = input(\"Hello!\", \"Message\")\nl = label.new(bar_index, high, text=i_text)\nlabel.delete(l[1])"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.color()](#fun_input.color)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.time()](#fun_input.time)"
          ],
          "syntax": [
            "input(defval, title, tooltip, inline, group, display, active) → input int"
          ],
          "returnedTypes": [
            "input int"
          ]
        },
        {
          "name": "input",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "displayType": "const int/float/bool/string/color or source-type built-ins",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ]
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input\", overlay=true)\ni_switch = input(true, \"On/Off\")\nplot(i_switch ? open : na)\n\ni_len = input(7, \"Length\")\ni_src = input(close, \"Source\")\nplot(ta.sma(i_src, i_len))\n\ni_border = input(142.50, \"Price Border\")\nhline(i_border)\nbgcolor(close > i_border ? color.green : color.red)\n\ni_col = input(color.red, \"Plot Color\")\nplot(close, color=i_col)\n\ni_text = input(\"Hello!\", \"Message\")\nl = label.new(bar_index, high, text=i_text)\nlabel.delete(l[1])"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.color()](#fun_input.color)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.time()](#fun_input.time)"
          ],
          "syntax": [
            "input(defval, title, tooltip, inline, group, display, active) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "input",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "displayType": "const int/float/bool/string/color or source-type built-ins",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ]
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input\", overlay=true)\ni_switch = input(true, \"On/Off\")\nplot(i_switch ? open : na)\n\ni_len = input(7, \"Length\")\ni_src = input(close, \"Source\")\nplot(ta.sma(i_src, i_len))\n\ni_border = input(142.50, \"Price Border\")\nhline(i_border)\nbgcolor(close > i_border ? color.green : color.red)\n\ni_col = input(color.red, \"Plot Color\")\nplot(close, color=i_col)\n\ni_text = input(\"Hello!\", \"Message\")\nl = label.new(bar_index, high, text=i_text)\nlabel.delete(l[1])"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.color()](#fun_input.color)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.time()](#fun_input.time)"
          ],
          "syntax": [
            "input(defval, title, tooltip, inline, group, display, active) → input string"
          ],
          "returnedTypes": [
            "input string"
          ]
        },
        {
          "name": "input",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "displayType": "const int/float/bool/string/color or source-type built-ins",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ]
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input\", overlay=true)\ni_switch = input(true, \"On/Off\")\nplot(i_switch ? open : na)\n\ni_len = input(7, \"Length\")\ni_src = input(close, \"Source\")\nplot(ta.sma(i_src, i_len))\n\ni_border = input(142.50, \"Price Border\")\nhline(i_border)\nbgcolor(close > i_border ? color.green : color.red)\n\ni_col = input(color.red, \"Plot Color\")\nplot(close, color=i_col)\n\ni_text = input(\"Hello!\", \"Message\")\nl = label.new(bar_index, high, text=i_text)\nlabel.delete(l[1])"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.color()](#fun_input.color)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.time()](#fun_input.time)"
          ],
          "syntax": [
            "input(defval, title, inline, group, tooltip, display, active) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "input.bool",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.bool\", overlay=true)\ni_switch = input.bool(true, \"On/Off\")\nplot(i_switch ? open : na)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.bool(defval, title, tooltip, inline, group, confirm, display, active) → input bool"
          ],
          "returnedTypes": [
            "input bool"
          ]
        },
        {
          "name": "input.int",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "minval",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "maxval",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "step",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.int\", overlay=true)\ni_len1 = input.int(10, \"Length 1\", minval=5, maxval=21, step=1)\nplot(ta.sma(close, i_len1))\n\ni_len2 = input.int(10, \"Length 2\", options=[5, 10, 21])\nplot(ta.sma(close, i_len2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.int(defval, title, minval, maxval, step, tooltip, inline, group, confirm, display, active) → input int"
          ],
          "returnedTypes": [
            "input int"
          ]
        },
        {
          "name": "input.int",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "options",
              "displayType": "tuple of const int values: [val1, val2, ...]",
              "desc": "",
              "allowedTypeIDs": [
                "[const int...]"
              ]
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.int\", overlay=true)\ni_len1 = input.int(10, \"Length 1\", minval=5, maxval=21, step=1)\nplot(ta.sma(close, i_len1))\n\ni_len2 = input.int(10, \"Length 2\", options=[5, 10, 21])\nplot(ta.sma(close, i_len2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.int(defval, title, options, tooltip, inline, group, confirm, display, active) → input int"
          ],
          "returnedTypes": [
            "input int"
          ]
        },
        {
          "name": "input.float",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "minval",
              "desc": "",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "maxval",
              "desc": "",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "step",
              "desc": "",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.float\", overlay=true)\ni_angle1 = input.float(0.5, \"Sin Angle\", minval=-3.14, maxval=3.14, step=0.02)\nplot(math.sin(i_angle1) > 0 ? close : open, \"sin\", color=color.green)\n\ni_angle2 = input.float(0, \"Cos Angle\", options=[-3.14, -1.57, 0, 1.57, 3.14])\nplot(math.cos(i_angle2) > 0 ? close : open, \"cos\", color=color.red)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.int()](#fun_input.int)",
            "[input.string()](#fun_input.string)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.float(defval, title, minval, maxval, step, tooltip, inline, group, confirm, display, active) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "input.float",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "options",
              "displayType": "tuple of const int/float values: [val1, val2, ...]",
              "desc": "",
              "allowedTypeIDs": [
                "[const float...]"
              ]
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.float\", overlay=true)\ni_angle1 = input.float(0.5, \"Sin Angle\", minval=-3.14, maxval=3.14, step=0.02)\nplot(math.sin(i_angle1) > 0 ? close : open, \"sin\", color=color.green)\n\ni_angle2 = input.float(0, \"Cos Angle\", options=[-3.14, -1.57, 0, 1.57, 3.14])\nplot(math.cos(i_angle2) > 0 ? close : open, \"cos\", color=color.red)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.int()](#fun_input.int)",
            "[input.string()](#fun_input.string)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.float(defval, title, options, tooltip, inline, group, confirm, display, active) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "input.string",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "options",
              "displayType": "tuple of const string values: [val1, val2, ...]",
              "desc": "",
              "allowedTypeIDs": [
                "[const string...]"
              ]
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.string\", overlay=true)\ni_text = input.string(\"Hello!\", \"Message\")\nl = label.new(bar_index, high, i_text)\nlabel.delete(l[1])"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.text_area()](#fun_input.text_area)",
            "[input.bool()](#fun_input.bool)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.string(defval, title, options, tooltip, inline, group, confirm, display, active) → input string"
          ],
          "returnedTypes": [
            "input string"
          ]
        },
        {
          "name": "input.text_area",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.text_area\")\ni_text = input.text_area(defval = \"Hello \\nWorld!\", title = \"Message\")\nplot(close)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.string()](#fun_input.string)",
            "[input.bool()](#fun_input.bool)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.text_area(defval, title, tooltip, group, confirm, display, active) → input string"
          ],
          "returnedTypes": [
            "input string"
          ]
        },
        {
          "name": "input.symbol",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.symbol\", overlay=true)\ni_sym = input.symbol(\"DELL\", \"Symbol\")\ns = request.security(i_sym, 'D', close)\nplot(s)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.symbol(defval, title, tooltip, inline, group, confirm, display, active) → input string"
          ],
          "returnedTypes": [
            "input string"
          ]
        },
        {
          "name": "input.timeframe",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "options",
              "displayType": "tuple of const string values: [val1, val2, ...]",
              "desc": "",
              "allowedTypeIDs": [
                "[const string...]"
              ]
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.timeframe\", overlay=true)\ni_res = input.timeframe('D', \"Resolution\", options=['D', 'W', 'M'])\ns = request.security(\"AAPL\", i_res, close)\nplot(s)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.timeframe(defval, title, options, tooltip, inline, group, confirm, display, active) → input string"
          ],
          "returnedTypes": [
            "input string"
          ]
        },
        {
          "name": "input.session",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "options",
              "displayType": "tuple of const string values: [val1, val2, ...]",
              "desc": "",
              "allowedTypeIDs": [
                "[const string...]"
              ]
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.session\", overlay=true)\ni_sess = input.session(\"1300-1700\", \"Session\", options=[\"0930-1600\", \"1300-1700\", \"1700-2100\"])\nt = time(timeframe.period, i_sess)\nbgcolor(time == t ? color.green : na)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.session(defval, title, options, tooltip, inline, group, confirm, display, active) → input string"
          ],
          "returnedTypes": [
            "input string"
          ]
        },
        {
          "name": "input.source",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "displayType": "open/high/low/close/hl2/hlc3/ohlc4/hlcc4",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ]
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.source\", overlay=true)\ni_src = input.source(close, \"Source\")\nplot(i_src)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.session()](#fun_input.session)",
            "[input.color()](#fun_input.color)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.source(defval, title, tooltip, inline, group, display, active, confirm) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "input.color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const color"
              ],
              "displayType": "const color"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.color\", overlay=true)\ni_col = input.color(color.red, \"Plot Color\")\nplot(close, color=i_col)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.color(defval, title, tooltip, inline, group, confirm, display, active) → input color"
          ],
          "returnedTypes": [
            "input color"
          ]
        },
        {
          "name": "input.time",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.time\", overlay=true)\ni_date = input.time(timestamp(\"20 Jul 2021 00:00 +0300\"), \"Date\")\nl = label.new(i_date, high, \"Date\", xloc=xloc.bar_time)\nlabel.delete(l[1])"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.time(defval, title, tooltip, inline, group, confirm, display, active) → input int"
          ],
          "returnedTypes": [
            "input int"
          ]
        },
        {
          "name": "input.price",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.price\", overlay=true)\nprice1 = input.price(title=\"Date\", defval=42)\nplot(price1)\n\nprice2 = input.price(54, title=\"Date\")\nplot(price2)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[input.bool()](#fun_input.bool)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.string()](#fun_input.string)",
            "[input.text_area()](#fun_input.text_area)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.resolution()](#fun_input.resolution)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.price(defval, title, tooltip, inline, group, confirm, display, active) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "input.enum",
          "desc": [
            "",
            ""
          ],
          "args": [
            {
              "name": "defval",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "const enum"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "options",
              "desc": "",
              "displayType": "tuple of enum fields: [enumName.field1, enumName.field2, ...]",
              "allowedTypeIDs": [
                "[const enum...]"
              ]
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "inline",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "group",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "confirm",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "const plot_display",
                "const plot_simple_display"
              ],
              "displayType": "const plot_display"
            },
            {
              "name": "active",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Session highlight\", overlay = true)\n\n//@enum        Contains fields with popular timezones as titles.\n//@field exch  Has an empty string as the title to represent the chart timezone.\nenum tz\n\tutc  = \"UTC\"\n\texch = \"\"\n\tny   = \"America/New_York\"\n\tchi  = \"America/Chicago\"\n\tlon  = \"Europe/London\"\n\ttok  = \"Asia/Tokyo\"\n\n//@variable The session string.\nselectedSession = input.session(\"1200-1500\", \"Session\")\n//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.\nselectedTimezone = input.enum(tz.utc, \"Session Timezone\")\n\n//@variable Is `true` if the current bar's time is in the specified session.\nbool inSession = false\nif not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))\n\tinSession := true\n\n// Highlight the background when `inSession` is `true`.\nbgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.text_area()](#fun_input.text_area)",
            "[input.bool()](#fun_input.bool)",
            "[input.int()](#fun_input.int)",
            "[input.float()](#fun_input.float)",
            "[input.symbol()](#fun_input.symbol)",
            "[input.timeframe()](#fun_input.timeframe)",
            "[input.session()](#fun_input.session)",
            "[input.source()](#fun_input.source)",
            "[input.color()](#fun_input.color)",
            "[input.time()](#fun_input.time)",
            "[input()](#fun_input)"
          ],
          "syntax": [
            "input.enum(defval, title, options, tooltip, inline, group, confirm, display, active) → input enum"
          ],
          "returnedTypes": []
        },
        {
          "name": "hline",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "price",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "color",
              "desc": "",
              "allowedTypeIDs": [
                "input color",
                "const color"
              ],
              "displayType": "input color"
            },
            {
              "name": "linestyle",
              "desc": "",
              "allowedTypeIDs": [
                "input hline_style",
                "const hline_style"
              ],
              "displayType": "input hline_style"
            },
            {
              "name": "linewidth",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "editable",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_simple_display",
                "const plot_simple_display"
              ],
              "displayType": "input plot_simple_display"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"input.hline\", overlay=true)\nhline(3.14, title='Pi', color=color.blue, linestyle=hline.style_dotted, linewidth=2)\n\n// You may fill the background between any two hlines with a fill() function:\nh1 = hline(20)\nh2 = hline(10)\nfill(h1, h2, color=color.new(color.green, 90))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[fill()](#fun_fill)"
          ],
          "syntax": [
            "hline(price, title, color, linestyle, linewidth, editable, display) → hline"
          ],
          "returnedTypes": [
            "hline"
          ]
        },
        {
          "name": "fill",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "plot1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "plot"
              ],
              "displayType": "plot"
            },
            {
              "name": "plot2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "plot"
              ],
              "displayType": "plot"
            },
            {
              "name": "top_value",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "bottom_value",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "top_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "bottom_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_simple_display",
                "const plot_simple_display"
              ],
              "displayType": "input plot_simple_display"
            },
            {
              "name": "fillgaps",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "editable",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Fill between hlines\", overlay = false)\nh1 = hline(20)\nh2 = hline(10)\nfill(h1, h2, color = color.new(color.blue, 90))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Fill between plots\", overlay = true)\np1 = plot(open)\np2 = plot(close)\nfill(p1, p2, color = color.new(color.green, 90))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Gradient Fill between hlines\", overlay = false)\ntopVal = input.int(100)\nbotVal = input.int(0)\ntopCol = input.color(color.red)\nbotCol = input.color(color.blue)\ntopLine = hline(100, color = topCol, linestyle = hline.style_solid)\nbotLine = hline(0,   color = botCol, linestyle = hline.style_solid)\nfill(topLine, botLine, topVal, botVal, topCol, botCol)"
              ]
            }
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[barcolor()](#fun_barcolor)",
            "[bgcolor()](#fun_bgcolor)",
            "[hline()](#fun_hline)",
            "[color.new()](#fun_color.new)"
          ],
          "syntax": [
            "fill(plot1, plot2, top_value, bottom_value, top_color, bottom_color, title, display, fillgaps, editable) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "fill",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "hline1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "hline"
              ],
              "displayType": "hline"
            },
            {
              "name": "hline2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "hline"
              ],
              "displayType": "hline"
            },
            {
              "name": "color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "editable",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "fillgaps",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_simple_display",
                "const plot_simple_display"
              ],
              "displayType": "input plot_simple_display"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Fill between hlines\", overlay = false)\nh1 = hline(20)\nh2 = hline(10)\nfill(h1, h2, color = color.new(color.blue, 90))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Fill between plots\", overlay = true)\np1 = plot(open)\np2 = plot(close)\nfill(p1, p2, color = color.new(color.green, 90))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Gradient Fill between hlines\", overlay = false)\ntopVal = input.int(100)\nbotVal = input.int(0)\ntopCol = input.color(color.red)\nbotCol = input.color(color.blue)\ntopLine = hline(100, color = topCol, linestyle = hline.style_solid)\nbotLine = hline(0,   color = botCol, linestyle = hline.style_solid)\nfill(topLine, botLine, topVal, botVal, topCol, botCol)"
              ]
            }
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[barcolor()](#fun_barcolor)",
            "[bgcolor()](#fun_bgcolor)",
            "[hline()](#fun_hline)",
            "[color.new()](#fun_color.new)"
          ],
          "syntax": [
            "fill(hline1, hline2, color, title, editable, fillgaps, display) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "fill",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "plot1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "plot"
              ],
              "displayType": "plot"
            },
            {
              "name": "plot2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "plot"
              ],
              "displayType": "plot"
            },
            {
              "name": "color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "title",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "editable",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "show_last",
              "desc": "",
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "fillgaps",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "display",
              "desc": "",
              "allowedTypeIDs": [
                "input plot_simple_display",
                "const plot_simple_display"
              ],
              "displayType": "input plot_simple_display"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Fill between hlines\", overlay = false)\nh1 = hline(20)\nh2 = hline(10)\nfill(h1, h2, color = color.new(color.blue, 90))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Fill between plots\", overlay = true)\np1 = plot(open)\np2 = plot(close)\nfill(p1, p2, color = color.new(color.green, 90))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Gradient Fill between hlines\", overlay = false)\ntopVal = input.int(100)\nbotVal = input.int(0)\ntopCol = input.color(color.red)\nbotCol = input.color(color.blue)\ntopLine = hline(100, color = topCol, linestyle = hline.style_solid)\nbotLine = hline(0,   color = botCol, linestyle = hline.style_solid)\nfill(topLine, botLine, topVal, botVal, topCol, botCol)"
              ]
            }
          ],
          "seeAlso": [
            "[plot()](#fun_plot)",
            "[barcolor()](#fun_barcolor)",
            "[bgcolor()](#fun_bgcolor)",
            "[hline()](#fun_hline)",
            "[color.new()](#fun_color.new)"
          ],
          "syntax": [
            "fill(plot1, plot2, color, title, editable, show_last, fillgaps, display) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "nz",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "replacement",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"nz\", overlay=true)\nplot(nz(ta.sma(close, 100)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[na](#var_na)",
            "[na()](#fun_na)",
            "[fixnan()](#fun_fixnan)"
          ],
          "syntax": [
            "nz(source, replacement) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "nz",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "replacement",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"nz\", overlay=true)\nplot(nz(ta.sma(close, 100)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[na](#var_na)",
            "[na()](#fun_na)",
            "[fixnan()](#fun_fixnan)"
          ],
          "syntax": [
            "nz(source, replacement) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "nz",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "simple color"
            },
            {
              "name": "replacement",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "simple color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"nz\", overlay=true)\nplot(nz(ta.sma(close, 100)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[na](#var_na)",
            "[na()](#fun_na)",
            "[fixnan()](#fun_fixnan)"
          ],
          "syntax": [
            "nz(source, replacement) → simple color"
          ],
          "returnedTypes": [
            "simple color"
          ]
        },
        {
          "name": "nz",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "replacement",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"nz\", overlay=true)\nplot(nz(ta.sma(close, 100)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[na](#var_na)",
            "[na()](#fun_na)",
            "[fixnan()](#fun_fixnan)"
          ],
          "syntax": [
            "nz(source, replacement) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "nz",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "replacement",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"nz\", overlay=true)\nplot(nz(ta.sma(close, 100)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[na](#var_na)",
            "[na()](#fun_na)",
            "[fixnan()](#fun_fixnan)"
          ],
          "syntax": [
            "nz(source, replacement) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "nz",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "replacement",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"nz\", overlay=true)\nplot(nz(ta.sma(close, 100)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[na](#var_na)",
            "[na()](#fun_na)",
            "[fixnan()](#fun_fixnan)"
          ],
          "syntax": [
            "nz(source, replacement) → series color"
          ],
          "returnedTypes": [
            "series color"
          ]
        },
        {
          "name": "na",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"na\")\n// Use the `na()` function to test for `na`.\nplot(na(close[1]) ? close : close[1])\n// ALTERNATIVE\n// `nz()` also tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.\nplot(nz(close[1], close))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[na](#var_na)",
            "[fixnan()](#fun_fixnan)",
            "[nz()](#fun_nz)"
          ],
          "syntax": [
            "na(x) → simple bool"
          ],
          "returnedTypes": [
            "simple bool"
          ]
        },
        {
          "name": "na",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series color",
                "simple color",
                "input color",
                "const color",
                "series string",
                "simple string",
                "input string",
                "const string",
                "series label",
                "series line",
                "series box",
                "series table",
                "series linefill",
                "series polyline",
                "array<>",
                "matrix<>"
              ],
              "displayType": "series int/float/color/string/label/line/box/table/linefill/polyline/array<>/matrix<>/map<>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"na\")\n// Use the `na()` function to test for `na`.\nplot(na(close[1]) ? close : close[1])\n// ALTERNATIVE\n// `nz()` also tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.\nplot(nz(close[1], close))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[na](#var_na)",
            "[fixnan()](#fun_fixnan)",
            "[nz()](#fun_nz)"
          ],
          "syntax": [
            "na(x) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "ta.tr",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "handle_na",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "simple bool"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.tr](#var_ta.tr)",
            "[ta.atr()](#fun_ta.atr)"
          ],
          "syntax": [
            "ta.tr(handle_na) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.pow",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "base",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "exponent",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.pow\", overlay=true)\nplot(math.pow(close, 2))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.sqrt()](#fun_math.sqrt)",
            "[math.exp()](#fun_math.exp)"
          ],
          "syntax": [
            "math.pow(base, exponent) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.pow",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "base",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            },
            {
              "name": "exponent",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.pow\", overlay=true)\nplot(math.pow(close, 2))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.sqrt()](#fun_math.sqrt)",
            "[math.exp()](#fun_math.exp)"
          ],
          "syntax": [
            "math.pow(base, exponent) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.pow",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "base",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "exponent",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.pow\", overlay=true)\nplot(math.pow(close, 2))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.sqrt()](#fun_math.sqrt)",
            "[math.exp()](#fun_math.exp)"
          ],
          "syntax": [
            "math.pow(base, exponent) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.pow",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "base",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "exponent",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.pow\", overlay=true)\nplot(math.pow(close, 2))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.sqrt()](#fun_math.sqrt)",
            "[math.exp()](#fun_math.exp)"
          ],
          "syntax": [
            "math.pow(base, exponent) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.min\", overlay=true)\nplot(math.min(close, open))\nplot(math.min(close, math.min(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.max()](#fun_math.max)"
          ],
          "syntax": [
            "math.min(number0, number1, ...) → const int"
          ],
          "returnedTypes": [
            "const int"
          ]
        },
        {
          "name": "math.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.min\", overlay=true)\nplot(math.min(close, open))\nplot(math.min(close, math.min(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.max()](#fun_math.max)"
          ],
          "syntax": [
            "math.min(number0, number1, ...) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.min\", overlay=true)\nplot(math.min(close, open))\nplot(math.min(close, math.min(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.max()](#fun_math.max)"
          ],
          "syntax": [
            "math.min(number0, number1, ...) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "math.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.min\", overlay=true)\nplot(math.min(close, open))\nplot(math.min(close, math.min(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.max()](#fun_math.max)"
          ],
          "syntax": [
            "math.min(number0, number1, ...) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.min\", overlay=true)\nplot(math.min(close, open))\nplot(math.min(close, math.min(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.max()](#fun_math.max)"
          ],
          "syntax": [
            "math.min(number0, number1, ...) → input int"
          ],
          "returnedTypes": [
            "input int"
          ]
        },
        {
          "name": "math.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.min\", overlay=true)\nplot(math.min(close, open))\nplot(math.min(close, math.min(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.max()](#fun_math.max)"
          ],
          "syntax": [
            "math.min(number0, number1, ...) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.min\", overlay=true)\nplot(math.min(close, open))\nplot(math.min(close, math.min(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.max()](#fun_math.max)"
          ],
          "syntax": [
            "math.min(number0, number1, ...) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "math.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.min\", overlay=true)\nplot(math.min(close, open))\nplot(math.min(close, math.min(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.max()](#fun_math.max)"
          ],
          "syntax": [
            "math.min(number0, number1, ...) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.max\", overlay=true)\nplot(math.max(close, open))\nplot(math.max(close, math.max(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.min()](#fun_math.min)"
          ],
          "syntax": [
            "math.max(number0, number1, ...) → const int"
          ],
          "returnedTypes": [
            "const int"
          ]
        },
        {
          "name": "math.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.max\", overlay=true)\nplot(math.max(close, open))\nplot(math.max(close, math.max(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.min()](#fun_math.min)"
          ],
          "syntax": [
            "math.max(number0, number1, ...) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.max\", overlay=true)\nplot(math.max(close, open))\nplot(math.max(close, math.max(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.min()](#fun_math.min)"
          ],
          "syntax": [
            "math.max(number0, number1, ...) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "math.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.max\", overlay=true)\nplot(math.max(close, open))\nplot(math.max(close, math.max(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.min()](#fun_math.min)"
          ],
          "syntax": [
            "math.max(number0, number1, ...) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.max\", overlay=true)\nplot(math.max(close, open))\nplot(math.max(close, math.max(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.min()](#fun_math.min)"
          ],
          "syntax": [
            "math.max(number0, number1, ...) → input int"
          ],
          "returnedTypes": [
            "input int"
          ]
        },
        {
          "name": "math.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.max\", overlay=true)\nplot(math.max(close, open))\nplot(math.max(close, math.max(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.min()](#fun_math.min)"
          ],
          "syntax": [
            "math.max(number0, number1, ...) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.max\", overlay=true)\nplot(math.max(close, open))\nplot(math.max(close, math.max(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.min()](#fun_math.min)"
          ],
          "syntax": [
            "math.max(number0, number1, ...) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "math.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"math.max\", overlay=true)\nplot(math.max(close, open))\nplot(math.max(close, math.max(open, 42)))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.min()](#fun_math.min)"
          ],
          "syntax": [
            "math.max(number0, number1, ...) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "str.format",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "formatString",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float",
                "simple bool",
                "input bool",
                "const bool",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple int/float/bool/string"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Simple `str.format()` demo\")\n\n//@variable A formatted string that includes representations of the current `bar_index` and `close` values.\n//          The placeholder `{0}` refers to the first argument after the formatting string (`bar_index`), and \n//          `{1}` refers to the second (`close`).\nstring labelText = str.format(\"Current bar index: {0}\\nCurrent bar close: {1}\", bar_index, close)\n\n// Draw a label to display the `labelText` string at the current bar's `high` price. \nlabel.new(bar_index, high, labelText)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Extensive `str.format()` demo\", overlay=true)\n// The format specifier inside the curly braces accepts certain modifiers:\n// - Specify the number of decimals to display:\ns1 = str.format(\"{0,number,#.#}\", 1.34) // returns: 1.3\nlabel.new(bar_index, close, text=s1)\n// - Round a float value to an integer:\ns2 = str.format(\"{0,number,integer}\", 1.34) // returns: 1\nlabel.new(bar_index - 1, close, text=s2)\n// - Display a number in currency:\ns3 = str.format(\"{0,number,currency}\", 1.34) // returns: $1.34\nlabel.new(bar_index - 2, close, text=s3)\n// - Display a number as a percentage:\ns4 = str.format(\"{0,number,percent}\", 0.5) // returns: 50%\nlabel.new(bar_index - 3, close, text=s4)\n// EXAMPLES WITH SEVERAL ARGUMENTS\n// returns: Number 1 is not equal to 4\ns5 = str.format(\"Number {0} is not {1} to {2}\", 1, \"equal\", 4)\nlabel.new(bar_index - 4, close, text=s5)\n// returns: 1.34 != 1.3\ns6 = str.format(\"{0} != {0, number, #.#}\", 1.34)\nlabel.new(bar_index - 5, close, text=s6)\n// returns: 1 is equal to 1, but 2 is equal to 2\ns7 = str.format(\"{0, number, integer} is equal to 1, but {1, number, integer} is equal to 2\", 1.34, 1.52)\nlabel.new(bar_index - 6, close, text=s7)\n// returns: The cash turnover amounted to $1,340,000.00\ns8 = str.format(\"The cash turnover amounted to {0, number, currency}\", 1340000)\nlabel.new(bar_index - 7, close, text=s8)\n// returns: Expected return is 10% - 20%\ns9 = str.format(\"Expected return is {0, number, percent} - {1, number, percent}\", 0.1, 0.2)\nlabel.new(bar_index - 8, close, text=s9)"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "str.format(formatString, arg0, arg1, ...) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "str.format",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "formatString",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series string",
                "simple string",
                "input string",
                "const string",
                "array<int>",
                "array<float>",
                "array<bool>",
                "array<string>"
              ],
              "displayType": "series int/float/bool/string/array<int/float/bool/string>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Simple `str.format()` demo\")\n\n//@variable A formatted string that includes representations of the current `bar_index` and `close` values.\n//          The placeholder `{0}` refers to the first argument after the formatting string (`bar_index`), and \n//          `{1}` refers to the second (`close`).\nstring labelText = str.format(\"Current bar index: {0}\\nCurrent bar close: {1}\", bar_index, close)\n\n// Draw a label to display the `labelText` string at the current bar's `high` price. \nlabel.new(bar_index, high, labelText)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Extensive `str.format()` demo\", overlay=true)\n// The format specifier inside the curly braces accepts certain modifiers:\n// - Specify the number of decimals to display:\ns1 = str.format(\"{0,number,#.#}\", 1.34) // returns: 1.3\nlabel.new(bar_index, close, text=s1)\n// - Round a float value to an integer:\ns2 = str.format(\"{0,number,integer}\", 1.34) // returns: 1\nlabel.new(bar_index - 1, close, text=s2)\n// - Display a number in currency:\ns3 = str.format(\"{0,number,currency}\", 1.34) // returns: $1.34\nlabel.new(bar_index - 2, close, text=s3)\n// - Display a number as a percentage:\ns4 = str.format(\"{0,number,percent}\", 0.5) // returns: 50%\nlabel.new(bar_index - 3, close, text=s4)\n// EXAMPLES WITH SEVERAL ARGUMENTS\n// returns: Number 1 is not equal to 4\ns5 = str.format(\"Number {0} is not {1} to {2}\", 1, \"equal\", 4)\nlabel.new(bar_index - 4, close, text=s5)\n// returns: 1.34 != 1.3\ns6 = str.format(\"{0} != {0, number, #.#}\", 1.34)\nlabel.new(bar_index - 5, close, text=s6)\n// returns: 1 is equal to 1, but 2 is equal to 2\ns7 = str.format(\"{0, number, integer} is equal to 1, but {1, number, integer} is equal to 2\", 1.34, 1.52)\nlabel.new(bar_index - 6, close, text=s7)\n// returns: The cash turnover amounted to $1,340,000.00\ns8 = str.format(\"The cash turnover amounted to {0, number, currency}\", 1340000)\nlabel.new(bar_index - 7, close, text=s8)\n// returns: Expected return is 10% - 20%\ns9 = str.format(\"Expected return is {0, number, percent} - {1, number, percent}\", 0.1, 0.2)\nlabel.new(bar_index - 8, close, text=s9)"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "str.format(formatString, arg0, arg1, ...) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "str.format_time",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "time",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "format",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "timezone",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.format_time\")\nif timeframe.change(\"1D\")\n\tformattedTime = str.format_time(time, \"yyyy-MM-dd HH:mm\", syminfo.timezone)\n\tlabel.new(bar_index, high, formattedTime)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "str.format_time(time, format, timezone) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "math.abs",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.abs(number) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "math.abs",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.abs(number) → input int"
          ],
          "returnedTypes": [
            "input int"
          ]
        },
        {
          "name": "math.abs",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.abs(number) → const int"
          ],
          "returnedTypes": [
            "const int"
          ]
        },
        {
          "name": "math.abs",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.abs(number) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "math.abs",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.abs(number) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.abs",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.abs(number) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.abs",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.abs(number) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.abs",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.abs(number) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.log",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.log10()](#fun_math.log10)"
          ],
          "syntax": [
            "math.log(number) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.log",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.log10()](#fun_math.log10)"
          ],
          "syntax": [
            "math.log(number) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.log",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.log10()](#fun_math.log10)"
          ],
          "syntax": [
            "math.log(number) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.log",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.log10()](#fun_math.log10)"
          ],
          "syntax": [
            "math.log(number) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.log10",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.log()](#fun_math.log)"
          ],
          "syntax": [
            "math.log10(number) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.log10",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.log()](#fun_math.log)"
          ],
          "syntax": [
            "math.log10(number) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.log10",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.log()](#fun_math.log)"
          ],
          "syntax": [
            "math.log10(number) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.log10",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.log()](#fun_math.log)"
          ],
          "syntax": [
            "math.log10(number) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.sqrt",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.pow()](#fun_math.pow)"
          ],
          "syntax": [
            "math.sqrt(number) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.sqrt",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.pow()](#fun_math.pow)"
          ],
          "syntax": [
            "math.sqrt(number) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.sqrt",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.pow()](#fun_math.pow)"
          ],
          "syntax": [
            "math.sqrt(number) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.sqrt",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.pow()](#fun_math.pow)"
          ],
          "syntax": [
            "math.sqrt(number) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.sign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.sign(number) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.sign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.sign(number) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.sign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.sign(number) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.sign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.sign(number) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.exp",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.pow()](#fun_math.pow)"
          ],
          "syntax": [
            "math.exp(number) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.exp",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.pow()](#fun_math.pow)"
          ],
          "syntax": [
            "math.exp(number) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.exp",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.pow()](#fun_math.pow)"
          ],
          "syntax": [
            "math.exp(number) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.exp",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.pow()](#fun_math.pow)"
          ],
          "syntax": [
            "math.exp(number) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.sin",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.sin(angle) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.sin",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.sin(angle) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.sin",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.sin(angle) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.sin",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.sin(angle) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.cos",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.cos(angle) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.cos",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.cos(angle) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.cos",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.cos(angle) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.cos",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.cos(angle) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.tan",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.tan(angle) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.tan",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.tan(angle) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.tan",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.tan(angle) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.tan",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.tan(angle) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.asin",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.asin(angle) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.asin",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.asin(angle) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.asin",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.asin(angle) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.asin",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.asin(angle) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.acos",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.acos(angle) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.acos",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.acos(angle) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.acos",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.acos(angle) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.acos",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.acos(angle) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.atan",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.atan(angle) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.atan",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.atan(angle) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.atan",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.atan(angle) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.atan",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "angle",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.atan(angle) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.ceil",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.floor()](#fun_math.floor)",
            "[math.round()](#fun_math.round)"
          ],
          "syntax": [
            "math.ceil(number) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "math.ceil",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.floor()](#fun_math.floor)",
            "[math.round()](#fun_math.round)"
          ],
          "syntax": [
            "math.ceil(number) → input int"
          ],
          "returnedTypes": [
            "input int"
          ]
        },
        {
          "name": "math.ceil",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.floor()](#fun_math.floor)",
            "[math.round()](#fun_math.round)"
          ],
          "syntax": [
            "math.ceil(number) → const int"
          ],
          "returnedTypes": [
            "const int"
          ]
        },
        {
          "name": "math.ceil",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.floor()](#fun_math.floor)",
            "[math.round()](#fun_math.round)"
          ],
          "syntax": [
            "math.ceil(number) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "math.floor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.round()](#fun_math.round)"
          ],
          "syntax": [
            "math.floor(number) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "math.floor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.round()](#fun_math.round)"
          ],
          "syntax": [
            "math.floor(number) → input int"
          ],
          "returnedTypes": [
            "input int"
          ]
        },
        {
          "name": "math.floor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.round()](#fun_math.round)"
          ],
          "syntax": [
            "math.floor(number) → const int"
          ],
          "returnedTypes": [
            "const int"
          ]
        },
        {
          "name": "math.floor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.round()](#fun_math.round)"
          ],
          "syntax": [
            "math.floor(number) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "math.round",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.floor()](#fun_math.floor)"
          ],
          "syntax": [
            "math.round(number) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "math.round",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.floor()](#fun_math.floor)"
          ],
          "syntax": [
            "math.round(number) → input int"
          ],
          "returnedTypes": [
            "input int"
          ]
        },
        {
          "name": "math.round",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.floor()](#fun_math.floor)"
          ],
          "syntax": [
            "math.round(number) → const int"
          ],
          "returnedTypes": [
            "const int"
          ]
        },
        {
          "name": "math.round",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.floor()](#fun_math.floor)"
          ],
          "syntax": [
            "math.round(number) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "math.round",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "precision",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.floor()](#fun_math.floor)"
          ],
          "syntax": [
            "math.round(number, precision) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.round",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            },
            {
              "name": "precision",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.floor()](#fun_math.floor)"
          ],
          "syntax": [
            "math.round(number, precision) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "math.round",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "precision",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.floor()](#fun_math.floor)"
          ],
          "syntax": [
            "math.round(number, precision) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "math.round",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "precision",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.floor()](#fun_math.floor)"
          ],
          "syntax": [
            "math.round(number, precision) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.round_to_mintick",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.floor()](#fun_math.floor)"
          ],
          "syntax": [
            "math.round_to_mintick(number) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.round_to_mintick",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[math.ceil()](#fun_math.ceil)",
            "[math.floor()](#fun_math.floor)"
          ],
          "syntax": [
            "math.round_to_mintick(number) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.median",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.median(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.median",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.median(source, length) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "ta.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.max(source) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.min(source) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.mode",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.mode(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.mode",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.mode(source, length) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "ta.range",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.range(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.range",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.range(source, length) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "math.todegrees",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "radians",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.todegrees(radians) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.toradians",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "degrees",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.toradians(degrees) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.random",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "min",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "max",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "seed",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "math.random(min, max, seed) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "math.sum",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.cum()](#fun_ta.cum)",
            "[for](#kw_for)"
          ],
          "syntax": [
            "math.sum(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.sma",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.sma\")\nplot(ta.sma(close, 15))\n\n// same on pine, but much less efficient\npine_sma(x, y) =>\n    sum = 0.0\n    for i = 0 to y - 1\n        sum := sum + x[i] / y\n    sum\nplot(pine_sma(close, 15))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.ema()](#fun_ta.ema)",
            "[ta.rma()](#fun_ta.rma)",
            "[ta.wma()](#fun_ta.wma)",
            "[ta.vwma()](#fun_ta.vwma)",
            "[ta.swma()](#fun_ta.swma)",
            "[ta.alma()](#fun_ta.alma)"
          ],
          "syntax": [
            "ta.sma(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.hma",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Hull Moving Average\")\nsrc = input(defval=close, title=\"Source\")\nlength = input(defval=9, title=\"Length\")\nhmaBuildIn = ta.hma(src, length)\nplot(hmaBuildIn, title=\"Hull MA\", color=#674EA7)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.ema()](#fun_ta.ema)",
            "[ta.rma()](#fun_ta.rma)",
            "[ta.wma()](#fun_ta.wma)",
            "[ta.vwma()](#fun_ta.vwma)",
            "[ta.sma()](#fun_ta.sma)"
          ],
          "syntax": [
            "ta.hma(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.ema",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.ema\")\nplot(ta.ema(close, 15))\n\n//the same on pine\npine_ema(src, length) =>\n    alpha = 2 / (length + 1)\n    sum = 0.0\n    sum := na(sum[1]) ? src : alpha * src + (1 - alpha) * nz(sum[1])\nplot(pine_ema(close,15))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[ta.sma()](#fun_ta.sma)",
            "[ta.rma()](#fun_ta.rma)",
            "[ta.wma()](#fun_ta.wma)",
            "[ta.vwma()](#fun_ta.vwma)",
            "[ta.swma()](#fun_ta.swma)",
            "[ta.alma()](#fun_ta.alma)"
          ],
          "syntax": [
            "ta.ema(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.wma",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.wma\")\nplot(ta.wma(close, 15))\n\n// same on pine, but much less efficient\npine_wma(x, y) =>\n    norm = 0.0\n    sum = 0.0\n    for i = 0 to y - 1\n        weight = (y - i) * y\n        norm := norm + weight\n        sum := sum + x[i] * weight\n    sum / norm\nplot(pine_wma(close, 15))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.sma()](#fun_ta.sma)",
            "[ta.ema()](#fun_ta.ema)",
            "[ta.rma()](#fun_ta.rma)",
            "[ta.vwma()](#fun_ta.vwma)",
            "[ta.swma()](#fun_ta.swma)",
            "[ta.alma()](#fun_ta.alma)"
          ],
          "syntax": [
            "ta.wma(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.vwma",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.vwma\")\nplot(ta.vwma(close, 15))\n\n// same on pine, but less efficient\npine_vwma(x, y) =>\n    ta.sma(x * volume, y) / ta.sma(volume, y)\nplot(pine_vwma(close, 15))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.sma()](#fun_ta.sma)",
            "[ta.ema()](#fun_ta.ema)",
            "[ta.rma()](#fun_ta.rma)",
            "[ta.wma()](#fun_ta.wma)",
            "[ta.swma()](#fun_ta.swma)",
            "[ta.alma()](#fun_ta.alma)"
          ],
          "syntax": [
            "ta.vwma(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.supertrend",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "factor",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "atrPeriod",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Pine Script® Supertrend\")\n\n[supertrend, direction] = ta.supertrend(3, 10)\nplot(direction < 0 ? supertrend : na, \"Up direction\", color = color.green, style=plot.style_linebr)\nplot(direction > 0 ? supertrend : na, \"Down direction\", color = color.red, style=plot.style_linebr)\n\n// The same on Pine Script®\npine_supertrend(factor, atrPeriod) =>\n\tsrc = hl2\n\tatr = ta.atr(atrPeriod)\n\tupperBand = src + factor * atr\n\tlowerBand = src - factor * atr\n\tprevLowerBand = nz(lowerBand[1])\n\tprevUpperBand = nz(upperBand[1])\n\n\tlowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand\n\tupperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand\n\tint _direction = na\n\tfloat superTrend = na\n\tprevSuperTrend = superTrend[1]\n\tif na(atr[1])\n\t\t_direction := 1\n\telse if prevSuperTrend == prevUpperBand\n\t\t_direction := close > upperBand ? -1 : 1\n\telse\n\t\t_direction := close < lowerBand ? 1 : -1\n\tsuperTrend := _direction == -1 ? lowerBand : upperBand\n\t[superTrend, _direction]\n\n[Pine_Supertrend, pineDirection] = pine_supertrend(3, 10)\nplot(pineDirection < 0 ? Pine_Supertrend : na, \"Up direction\", color = color.green, style=plot.style_linebr)\nplot(pineDirection > 0 ? Pine_Supertrend : na, \"Down direction\", color = color.red, style=plot.style_linebr)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[ta.macd()](#fun_ta.macd)"
          ],
          "syntax": [
            "ta.supertrend(factor, atrPeriod) → [series float, series float]"
          ],
          "returnedTypes": [
            "[series float, series float]"
          ]
        },
        {
          "name": "ta.macd",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "fastlen",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "slowlen",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "siglen",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"MACD\")\n[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)\nplot(macdLine, color=color.blue)\nplot(signalLine, color=color.orange)\nplot(histLine, color=color.red, style=plot.style_histogram)"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"MACD\")\n[_, signalLine, _] = ta.macd(close, 12, 26, 9)\nplot(signalLine, color=color.orange)"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.sma()](#fun_ta.sma)",
            "[ta.ema()](#fun_ta.ema)"
          ],
          "syntax": [
            "ta.macd(source, fastlen, slowlen, siglen) → [series float, series float, series float]"
          ],
          "returnedTypes": [
            "[series float, series float, series float]"
          ]
        },
        {
          "name": "ta.lowest",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[ta.highest()](#fun_ta.highest)",
            "[ta.lowestbars()](#fun_ta.lowestbars)",
            "[ta.highestbars()](#fun_ta.highestbars)",
            "[ta.valuewhen()](#fun_ta.valuewhen)",
            "[ta.barssince()](#fun_ta.barssince)"
          ],
          "syntax": [
            "ta.lowest(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.highest",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[ta.lowest()](#fun_ta.lowest)",
            "[ta.lowestbars()](#fun_ta.lowestbars)",
            "[ta.highestbars()](#fun_ta.highestbars)",
            "[ta.valuewhen()](#fun_ta.valuewhen)",
            "[ta.barssince()](#fun_ta.barssince)"
          ],
          "syntax": [
            "ta.highest(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.lowestbars",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[ta.lowest()](#fun_ta.lowest)",
            "[ta.highest()](#fun_ta.highest)",
            "[ta.highestbars()](#fun_ta.highestbars)",
            "[ta.barssince()](#fun_ta.barssince)",
            "[ta.valuewhen()](#fun_ta.valuewhen)"
          ],
          "syntax": [
            "ta.lowestbars(source, length) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "ta.highestbars",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[ta.lowest()](#fun_ta.lowest)",
            "[ta.highest()](#fun_ta.highest)",
            "[ta.lowestbars()](#fun_ta.lowestbars)",
            "[ta.barssince()](#fun_ta.barssince)",
            "[ta.valuewhen()](#fun_ta.valuewhen)"
          ],
          "syntax": [
            "ta.highestbars(source, length) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "ta.barssince",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "condition",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.barssince\")\n// get number of bars since last color.green bar\nplot(ta.barssince(close >= open))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[ta.lowestbars()](#fun_ta.lowestbars)",
            "[ta.highestbars()](#fun_ta.highestbars)",
            "[ta.valuewhen()](#fun_ta.valuewhen)",
            "[ta.highest()](#fun_ta.highest)",
            "[ta.lowest()](#fun_ta.lowest)"
          ],
          "syntax": [
            "ta.barssince(condition) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "ta.valuewhen",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "condition",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "occurrence",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.valuewhen\")\nslow = ta.sma(close, 7)\nfast = ta.sma(close, 14)\n// Get value of `close` on second most recent cross\nplot(ta.valuewhen(ta.cross(slow, fast), close, 1))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.lowestbars()](#fun_ta.lowestbars)",
            "[ta.highestbars()](#fun_ta.highestbars)",
            "[ta.barssince()](#fun_ta.barssince)",
            "[ta.highest()](#fun_ta.highest)",
            "[ta.lowest()](#fun_ta.lowest)"
          ],
          "syntax": [
            "ta.valuewhen(condition, source, occurrence) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.valuewhen",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "condition",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "occurrence",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.valuewhen\")\nslow = ta.sma(close, 7)\nfast = ta.sma(close, 14)\n// Get value of `close` on second most recent cross\nplot(ta.valuewhen(ta.cross(slow, fast), close, 1))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.lowestbars()](#fun_ta.lowestbars)",
            "[ta.highestbars()](#fun_ta.highestbars)",
            "[ta.barssince()](#fun_ta.barssince)",
            "[ta.highest()](#fun_ta.highest)",
            "[ta.lowest()](#fun_ta.lowest)"
          ],
          "syntax": [
            "ta.valuewhen(condition, source, occurrence) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "ta.valuewhen",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "condition",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "occurrence",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.valuewhen\")\nslow = ta.sma(close, 7)\nfast = ta.sma(close, 14)\n// Get value of `close` on second most recent cross\nplot(ta.valuewhen(ta.cross(slow, fast), close, 1))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.lowestbars()](#fun_ta.lowestbars)",
            "[ta.highestbars()](#fun_ta.highestbars)",
            "[ta.barssince()](#fun_ta.barssince)",
            "[ta.highest()](#fun_ta.highest)",
            "[ta.lowest()](#fun_ta.lowest)"
          ],
          "syntax": [
            "ta.valuewhen(condition, source, occurrence) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "ta.valuewhen",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "condition",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "occurrence",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.valuewhen\")\nslow = ta.sma(close, 7)\nfast = ta.sma(close, 14)\n// Get value of `close` on second most recent cross\nplot(ta.valuewhen(ta.cross(slow, fast), close, 1))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.lowestbars()](#fun_ta.lowestbars)",
            "[ta.highestbars()](#fun_ta.highestbars)",
            "[ta.barssince()](#fun_ta.barssince)",
            "[ta.highest()](#fun_ta.highest)",
            "[ta.lowest()](#fun_ta.lowest)"
          ],
          "syntax": [
            "ta.valuewhen(condition, source, occurrence) → series color"
          ],
          "returnedTypes": [
            "series color"
          ]
        },
        {
          "name": "ta.falling",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.rising()](#fun_ta.rising)"
          ],
          "syntax": [
            "ta.falling(source, length) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "ta.rising",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.falling()](#fun_ta.falling)"
          ],
          "syntax": [
            "ta.rising(source, length) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "ta.roc",
          "desc": [
            "",
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.roc(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.cci",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.cci(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.variance",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "biased",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[ta.dev()](#fun_ta.dev)",
            "[ta.stdev()](#fun_ta.stdev)"
          ],
          "syntax": [
            "ta.variance(source, length, biased) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.dev",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.dev\")\nplot(ta.dev(close, 10))\n\n// the same on pine\npine_dev(source, length) =>\n    mean = ta.sma(source, length)\n    sum = 0.0\n    for i = 0 to length - 1\n        val = source[i]\n        sum := sum + math.abs(val - mean)\n    dev = sum/length\nplot(pine_dev(close, 10))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.variance()](#fun_ta.variance)",
            "[ta.stdev()](#fun_ta.stdev)"
          ],
          "syntax": [
            "ta.dev(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.stdev",
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "biased",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.stdev\")\nplot(ta.stdev(close, 5))\n\n//the same on pine\nisZero(val, eps) => math.abs(val) <= eps\n\nSUM(fst, snd) =>\n    EPS = 1e-10\n    res = fst + snd\n    if isZero(res, EPS)\n        res := 0\n    else\n        if not isZero(res, 1e-4)\n            res := res\n        else\n            15\n\npine_stdev(src, length) =>\n    avg = ta.sma(src, length)\n    sumOfSquareDeviations = 0.0\n    for i = 0 to length - 1\n        sum = SUM(src[i], -avg)\n        sumOfSquareDeviations := sumOfSquareDeviations + sum * sum\n\n    stdev = math.sqrt(sumOfSquareDeviations / length)\nplot(pine_stdev(close, 5))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[ta.dev()](#fun_ta.dev)",
            "[ta.variance()](#fun_ta.variance)"
          ],
          "syntax": [
            "ta.stdev(source, length, biased) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.percentrank",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.percentrank(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.rma",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.rma\")\nplot(ta.rma(close, 15))\n\n//the same on pine\npine_rma(src, length) =>\n\talpha = 1/length\n\tsum = 0.0\n\tsum := na(sum[1]) ? ta.sma(src, length) : alpha * src + (1 - alpha) * nz(sum[1])\nplot(pine_rma(close, 15))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.sma()](#fun_ta.sma)",
            "[ta.ema()](#fun_ta.ema)",
            "[ta.wma()](#fun_ta.wma)",
            "[ta.vwma()](#fun_ta.vwma)",
            "[ta.swma()](#fun_ta.swma)",
            "[ta.alma()](#fun_ta.alma)",
            "[ta.rsi()](#fun_ta.rsi)"
          ],
          "syntax": [
            "ta.rma(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.rsi",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.rsi\")\nplot(ta.rsi(close, 7))\n\n// same on pine, but less efficient\npine_rsi(x, y) =>\n    u = math.max(x - x[1], 0) // upward ta.change\n    d = math.max(x[1] - x, 0) // downward ta.change\n    rs = ta.rma(u, y) / ta.rma(d, y)\n    res = 100 - 100 / (1 + rs)\n    res\n\nplot(pine_rsi(close, 7))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.rma()](#fun_ta.rma)"
          ],
          "syntax": [
            "ta.rsi(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.rci",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [],
          "syntax": [
            "ta.rci(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "timeframe.in_seconds",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "timeframe",
              "desc": "",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`timeframe_in_seconds()`\"),\n\n// Get a user-selected timeframe.\ntfInput = input.timeframe(\"1D\")\n\n// Convert it into an \"int\" number of seconds.\nsecondsInTf = timeframe.in_seconds(tfInput)\n\nplot(secondsInTf)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.timeframe()](#fun_input.timeframe)",
            "[timeframe.period](#var_timeframe.period)",
            "[timeframe.from_seconds()](#fun_timeframe.from_seconds)"
          ],
          "syntax": [
            "timeframe.in_seconds(timeframe) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "timeframe.in_seconds",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "timeframe",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`timeframe_in_seconds()`\"),\n\n// Get a user-selected timeframe.\ntfInput = input.timeframe(\"1D\")\n\n// Convert it into an \"int\" number of seconds.\nsecondsInTf = timeframe.in_seconds(tfInput)\n\nplot(secondsInTf)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[input.timeframe()](#fun_input.timeframe)",
            "[timeframe.period](#var_timeframe.period)",
            "[timeframe.from_seconds()](#fun_timeframe.from_seconds)"
          ],
          "syntax": [
            "timeframe.in_seconds(timeframe) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "timeframe.from_seconds",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "seconds",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"HTF Close\", \"\", true)\nint chartTf = timeframe.in_seconds()\nstring tfTimes5 = timeframe.from_seconds(chartTf * 5)\nfloat htfClose = request.security(syminfo.tickerid, tfTimes5, close)\nplot(htfClose)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[timeframe.in_seconds()](#fun_timeframe.in_seconds)",
            "[request.security](#var_request.security)",
            "[request.security_lower_tf](#var_request.security_lower_tf)"
          ],
          "syntax": [
            "timeframe.from_seconds(seconds) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "timeframe.from_seconds",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "seconds",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"HTF Close\", \"\", true)\nint chartTf = timeframe.in_seconds()\nstring tfTimes5 = timeframe.from_seconds(chartTf * 5)\nfloat htfClose = request.security(syminfo.tickerid, tfTimes5, close)\nplot(htfClose)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[timeframe.in_seconds()](#fun_timeframe.in_seconds)",
            "[request.security](#var_request.security)",
            "[request.security_lower_tf](#var_request.security_lower_tf)"
          ],
          "syntax": [
            "timeframe.from_seconds(seconds) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "ta.dmi",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "diLength",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "adxSmoothing",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(title=\"Directional Movement Index\", shorttitle=\"DMI\", format=format.price, precision=4)\nlen = input.int(17, minval=1, title=\"DI Length\")\nlensig = input.int(14, title=\"ADX Smoothing\", minval=1)\n[diplus, diminus, adx] = ta.dmi(len, lensig)\nplot(adx, color=color.red, title=\"ADX\")\nplot(diplus, color=color.blue, title=\"+DI\")\nplot(diminus, color=color.orange, title=\"-DI\")"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[ta.rsi()](#fun_ta.rsi)",
            "[ta.tsi()](#fun_ta.tsi)",
            "[ta.mfi()](#fun_ta.mfi)"
          ],
          "syntax": [
            "ta.dmi(diLength, adxSmoothing) → [series float, series float, series float]"
          ],
          "returnedTypes": [
            "[series float, series float, series float]"
          ]
        },
        {
          "name": "ta.correlation",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "source2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[request.security()](#fun_request.security)"
          ],
          "syntax": [
            "ta.correlation(source1, source2, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.tsi",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "short_length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "long_length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.tsi(source, short_length, long_length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.linreg",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "offset",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.linreg(source, length, offset) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.stoch",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "high",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "low",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.cog()](#fun_ta.cog)"
          ],
          "syntax": [
            "ta.stoch(source, high, low, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.atr",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.atr\")\nplot(ta.atr(14))\n\n//the same on pine\npine_atr(length) =>\n    trueRange = na(high[1])? high-low : math.max(math.max(high - low, math.abs(high - close[1])), math.abs(low - close[1]))\n    //true range can be also calculated with ta.tr(true)\n    ta.rma(trueRange, length)\n\nplot(pine_atr(14))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.tr()](#fun_ta.tr)",
            "[ta.rma()](#fun_ta.rma)"
          ],
          "syntax": [
            "ta.atr(length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "fixnan",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[na()](#fun_na)",
            "[na](#var_na)",
            "[nz()](#fun_nz)"
          ],
          "syntax": [
            "fixnan(source) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "fixnan",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[na()](#fun_na)",
            "[na](#var_na)",
            "[nz()](#fun_nz)"
          ],
          "syntax": [
            "fixnan(source) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "fixnan",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[na()](#fun_na)",
            "[na](#var_na)",
            "[nz()](#fun_nz)"
          ],
          "syntax": [
            "fixnan(source) → series color"
          ],
          "returnedTypes": [
            "series color"
          ]
        },
        {
          "name": "ta.cum",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.sum()](#fun_math.sum)"
          ],
          "syntax": [
            "ta.cum(source) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.change",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator('Day and Direction Change', overlay = true)\ndailyBarTime = time('1D')\nisNewDay = ta.change(dailyBarTime) != 0\nbgcolor(isNewDay ? color.new(color.green, 80) : na)\n\nisGreenBar = close >= open\ncolorChange = ta.change(isGreenBar)\nplotshape(colorChange, 'Direction Change')"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.mom()](#fun_ta.mom)",
            "[ta.cross()](#fun_ta.cross)"
          ],
          "syntax": [
            "ta.change(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.change",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator('Day and Direction Change', overlay = true)\ndailyBarTime = time('1D')\nisNewDay = ta.change(dailyBarTime) != 0\nbgcolor(isNewDay ? color.new(color.green, 80) : na)\n\nisGreenBar = close >= open\ncolorChange = ta.change(isGreenBar)\nplotshape(colorChange, 'Direction Change')"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.mom()](#fun_ta.mom)",
            "[ta.cross()](#fun_ta.cross)"
          ],
          "syntax": [
            "ta.change(source, length) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "ta.change",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator('Day and Direction Change', overlay = true)\ndailyBarTime = time('1D')\nisNewDay = ta.change(dailyBarTime) != 0\nbgcolor(isNewDay ? color.new(color.green, 80) : na)\n\nisGreenBar = close >= open\ncolorChange = ta.change(isGreenBar)\nplotshape(colorChange, 'Direction Change')"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.mom()](#fun_ta.mom)",
            "[ta.cross()](#fun_ta.cross)"
          ],
          "syntax": [
            "ta.change(source, length) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "ta.mom",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.change()](#fun_ta.change)"
          ],
          "syntax": [
            "ta.mom(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.pivot_point_levels",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "type",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "anchor",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "developing",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Weekly Pivots\", max_lines_count=500, overlay=true)\ntimeframe = \"1W\"\ntypeInput = input.string(\"Traditional\", \"Type\", options=[\"Traditional\", \"Fibonacci\", \"Woodie\", \"Classic\", \"DM\", \"Camarilla\"])\nweekChange = timeframe.change(timeframe)\npivotPointsArray = ta.pivot_point_levels(typeInput, weekChange)\nif weekChange\n    for pivotLevel in pivotPointsArray\n        line.new(time, pivotLevel, time + timeframe.in_seconds(timeframe) * 1000, pivotLevel, xloc=xloc.bar_time)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.pivot_point_levels(type, anchor, developing) → array<float>"
          ],
          "returnedTypes": [
            "array<float>"
          ]
        },
        {
          "name": "ta.vwap",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "anchor",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Simple VWAP\")\nvwap = ta.vwap(open)\nplot(vwap)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Advanced VWAP\")\nvwapAnchorInput = input.string(\"Daily\", \"Anchor\", options = [\"Daily\", \"Weekly\", \"Monthly\"])\nstdevMultiplierInput = input.float(1.0, \"Standard Deviation Multiplier\")\nanchorTimeframe = switch vwapAnchorInput\n\t\"Daily\"   => \"1D\"\n\t\"Weekly\"  => \"1W\"\n\t\"Monthly\" => \"1M\"\nanchor = timeframe.change(anchorTimeframe)\n[vwap, upper, lower] = ta.vwap(open, anchor, stdevMultiplierInput)\nplot(vwap)\nplot(upper, color = color.green)\nplot(lower, color = color.green)"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.vwap](#var_ta.vwap)"
          ],
          "syntax": [
            "ta.vwap(source, anchor) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.vwap",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "anchor",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "stdev_mult",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Simple VWAP\")\nvwap = ta.vwap(open)\nplot(vwap)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Advanced VWAP\")\nvwapAnchorInput = input.string(\"Daily\", \"Anchor\", options = [\"Daily\", \"Weekly\", \"Monthly\"])\nstdevMultiplierInput = input.float(1.0, \"Standard Deviation Multiplier\")\nanchorTimeframe = switch vwapAnchorInput\n\t\"Daily\"   => \"1D\"\n\t\"Weekly\"  => \"1W\"\n\t\"Monthly\" => \"1M\"\nanchor = timeframe.change(anchorTimeframe)\n[vwap, upper, lower] = ta.vwap(open, anchor, stdevMultiplierInput)\nplot(vwap)\nplot(upper, color = color.green)\nplot(lower, color = color.green)"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.vwap](#var_ta.vwap)"
          ],
          "syntax": [
            "ta.vwap(source, anchor, stdev_mult) → [series float, series float, series float]"
          ],
          "returnedTypes": [
            "[series float, series float, series float]"
          ]
        },
        {
          "name": "ta.swma",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.swma\")\nplot(ta.swma(close))\n\n// same on pine, but less efficient\npine_swma(x) =>\n    x[3] * 1 / 6 + x[2] * 2 / 6 + x[1] * 2 / 6 + x[0] * 1 / 6\nplot(pine_swma(close))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.sma()](#fun_ta.sma)",
            "[ta.ema()](#fun_ta.ema)",
            "[ta.rma()](#fun_ta.rma)",
            "[ta.wma()](#fun_ta.wma)",
            "[ta.vwma()](#fun_ta.vwma)",
            "[ta.alma()](#fun_ta.alma)"
          ],
          "syntax": [
            "ta.swma(source) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.sar",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "start",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "inc",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "max",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.sar\")\nplot(ta.sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)\n\n// The same on Pine Script®\npine_sar(start, inc, max) =>\n\tvar float result = na\n\tvar float maxMin = na\n\tvar float acceleration = na\n\tvar bool isBelow = false\n\tbool isFirstTrendBar = false\n\n\tif bar_index == 1\n\t\tif close > close[1]\n\t\t\tisBelow := true\n\t\t\tmaxMin := high\n\t\t\tresult := low[1]\n\t\telse\n\t\t\tisBelow := false\n\t\t\tmaxMin := low\n\t\t\tresult := high[1]\n\t\tisFirstTrendBar := true\n\t\tacceleration := start\n\n\tresult := result + acceleration * (maxMin - result)\n\n\tif isBelow\n\t\tif result > low\n\t\t\tisFirstTrendBar := true\n\t\t\tisBelow := false\n\t\t\tresult := math.max(high, maxMin)\n\t\t\tmaxMin := low\n\t\t\tacceleration := start\n\telse\n\t\tif result < high\n\t\t\tisFirstTrendBar := true\n\t\t\tisBelow := true\n\t\t\tresult := math.min(low, maxMin)\n\t\t\tmaxMin := high\n\t\t\tacceleration := start\n\t\t\t\n\tif not isFirstTrendBar\n\t\tif isBelow\n\t\t\tif high > maxMin\n\t\t\t\tmaxMin := high\n\t\t\t\tacceleration := math.min(acceleration + inc, max)\n\t\telse\n\t\t\tif low < maxMin\n\t\t\t\tmaxMin := low\n\t\t\t\tacceleration := math.min(acceleration + inc, max)\n\n\tif isBelow\n\t\tresult := math.min(result, low[1])\n\t\tif bar_index > 1\n\t\t\tresult := math.min(result, low[2])\n\t\t\n\telse\n\t\tresult := math.max(result, high[1])\n\t\tif bar_index > 1\n\t\t\tresult := math.max(result, high[2])\n\n\tresult\n\nplot(pine_sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "ta.sar(start, inc, max) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "timeframe.change",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "timeframe",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\n// Run this script on an intraday chart.\nindicator(\"New day started\", overlay = true)\n// Highlights the first bar of the new day.\nisNewDay = timeframe.change(\"1D\")\nbgcolor(isNewDay ? color.new(color.green, 80) : na)"
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "timeframe.change(timeframe) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "math.avg",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.sum()](#fun_math.sum)",
            "[ta.cum()](#fun_ta.cum)",
            "[ta.sma()](#fun_ta.sma)"
          ],
          "syntax": [
            "math.avg(number0, number1, ...) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "math.avg",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "number0, number1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.sum()](#fun_math.sum)",
            "[ta.cum()](#fun_ta.cum)",
            "[ta.sma()](#fun_ta.sma)"
          ],
          "syntax": [
            "math.avg(number0, number1, ...) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "request.currency_rate",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "from",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "to",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "ignore_invalid_currency",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Close in British Pounds\")\nrate = request.currency_rate(syminfo.currency, \"GBP\")\nplot(close * rate)"
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "request.currency_rate(from, to, ignore_invalid_currency) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "request.security",
          "desc": [
            ""
          ],
          "syntax": [
            "request.security(symbol, timeframe, expression, gaps, lookahead, ignore_invalid_symbol, currency, calc_bars_count) → series <type>"
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "timeframe",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "expression",
              "desc": "",
              "displayType": "variable, function, object, array, matrix, or map of series int/float/bool/string/color/enum, or a tuple of these",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series color",
                "simple color",
                "input color",
                "const color",
                "series string",
                "simple string",
                "input string",
                "const string"
              ]
            },
            {
              "name": "gaps",
              "desc": "",
              "allowedTypeIDs": [
                "simple barmerge_gaps",
                "input barmerge_gaps",
                "const barmerge_gaps"
              ],
              "displayType": "simple barmerge_gaps"
            },
            {
              "name": "lookahead",
              "desc": "",
              "allowedTypeIDs": [
                "simple barmerge_lookahead",
                "input barmerge_lookahead",
                "const barmerge_lookahead"
              ],
              "displayType": "simple barmerge_lookahead"
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "currency",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "calc_bars_count",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Simple `request.security()` calls\")\n// Returns 1D close of the current symbol.\ndailyClose = request.security(syminfo.tickerid, \"1D\", close)\nplot(dailyClose)\n\n// Returns the close of \"AAPL\" from the same timeframe as currently open on the chart.\naaplClose = request.security(\"AAPL\", timeframe.period, close)\nplot(aaplClose)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Advanced `request.security()` calls\")\n// This calculates a 10-period moving average on the active chart.\nsma = ta.sma(close, 10)\n// This sends the `sma` calculation for execution in the context of the \"AAPL\" symbol at a \"240\" (4 hours) timeframe.\naaplSma = request.security(\"AAPL\", \"240\", sma)\nplot(aaplSma)\n\n// To avoid differences on historical and realtime bars, you can use this technique, which only returns a value from the higher timeframe on the bar after it completes:\nindexHighTF = barstate.isrealtime ? 1 : 0\nindexCurrTF = barstate.isrealtime ? 0 : 1\nnonRepaintingClose = request.security(syminfo.tickerid, \"1D\", close[indexHighTF])[indexCurrTF]\nplot(nonRepaintingClose, \"Non-repainting close\")\n\n// Returns the 1H close of \"AAPL\", extended session included. The value is dividend-adjusted.\nextendedTicker = ticker.modify(\"NASDAQ:AAPL\", session = session.extended, adjustment = adjustment.dividends)\naaplExtAdj = request.security(extendedTicker, \"60\", close)\nplot(aaplExtAdj)\n\n// Returns the result of a user-defined function.\n// The `max` variable is mutable, but we can pass it to `request.security()` because it is wrapped in a function.\nallTimeHigh(source) =>\n\tvar max = source\n\tmax := math.max(max, source)\nallTimeHigh1D = request.security(syminfo.tickerid, \"1D\", allTimeHigh(high))\n\n// By using a tuple `expression`, we obtain several values with only one `request.security()` call.\n[open1D, high1D, low1D, close1D, ema1D] = request.security(syminfo.tickerid, \"1D\", [open, high, low, close, ta.ema(close, 10)])\nplotcandle(open1D, high1D, low1D, close1D)\nplot(ema1D)\n\n// Returns an array containing the OHLC values of the chart's symbol from the 1D timeframe.\nohlcArray = request.security(syminfo.tickerid, \"1D\", array.from(open, high, low, close))\nplotcandle(array.get(ohlcArray, 0), array.get(ohlcArray, 1), array.get(ohlcArray, 2), array.get(ohlcArray, 3))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[timeframe.period](#var_timeframe.period)",
            "[ticker.new()](#fun_ticker.new)",
            "[ticker.modify()](#fun_ticker.modify)",
            "[request.security_lower_tf()](#fun_request.security_lower_tf)",
            "[request.dividends()](#fun_request.dividends)",
            "[request.earnings()](#fun_request.earnings)",
            "[request.splits()](#fun_request.splits)",
            "[request.financial()](#fun_request.financial)"
          ]
        },
        {
          "name": "request.security_lower_tf",
          "desc": [
            ""
          ],
          "syntax": [
            "request.security_lower_tf(symbol, timeframe, expression, ignore_invalid_symbol, currency, ignore_invalid_timeframe, calc_bars_count) → array<type>"
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "timeframe",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "expression",
              "desc": "",
              "displayType": "variable, object or function of series int/float/bool/string/color/enum, or a tuple of these",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series color",
                "simple color",
                "input color",
                "const color"
              ]
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "currency",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "ignore_invalid_timeframe",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "calc_bars_count",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`request.security_lower_tf()` Example\", overlay = true)\n\n// If the current chart timeframe is set to 120 minutes, then the `arrayClose` array will contain two 'close' values from the 60 minute timeframe for each bar.\narrClose = request.security_lower_tf(syminfo.tickerid, \"60\", close)\n\nif bar_index == last_bar_index - 1\n    label.new(bar_index, high, str.tostring(arrClose))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[request.security()](#fun_request.security)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[timeframe.period](#var_timeframe.period)",
            "[ticker.new()](#fun_ticker.new)",
            "[request.dividends()](#fun_request.dividends)",
            "[request.earnings()](#fun_request.earnings)",
            "[request.splits()](#fun_request.splits)",
            "[request.financial()](#fun_request.financial)"
          ]
        },
        {
          "name": "request.financial",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "financial_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "period",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "gaps",
              "desc": "",
              "allowedTypeIDs": [
                "simple barmerge_gaps",
                "input barmerge_gaps",
                "const barmerge_gaps"
              ],
              "displayType": "simple barmerge_gaps"
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "currency",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"request.financial\")\nf = request.financial(\"NASDAQ:MSFT\", \"ACCOUNTS_PAYABLE\", \"FY\")\nplot(f)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[request.security()](#fun_request.security)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ],
          "syntax": [
            "request.financial(symbol, financial_id, period, gaps, ignore_invalid_symbol, currency) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "request.quandl",
          "desc": [
            "",
            "",
            ""
          ],
          "args": [
            {
              "name": "ticker",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "gaps",
              "desc": "",
              "allowedTypeIDs": [
                "simple barmerge_gaps",
                "input barmerge_gaps",
                "const barmerge_gaps"
              ],
              "displayType": "simple barmerge_gaps"
            },
            {
              "name": "index",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"request.quandl\")\nf = request.quandl(\"CFTC/SB_FO_ALL\", barmerge.gaps_off, 0)\nplot(f)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[request.security()](#fun_request.security)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ],
          "syntax": [
            "request.quandl(ticker, gaps, index, ignore_invalid_symbol) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ticker.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "prefix",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "ticker",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "session",
              "desc": "",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "adjustment",
              "desc": "",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "backadjustment",
              "desc": "",
              "allowedTypeIDs": [
                "simple backadjustment",
                "input backadjustment",
                "const backadjustment"
              ],
              "displayType": "simple backadjustment"
            },
            {
              "name": "settlement_as_close",
              "desc": "",
              "allowedTypeIDs": [
                "simple settlement",
                "input settlement",
                "const settlement"
              ],
              "displayType": "simple settlement"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.new\", overlay=true)\nt = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)\nt2 = ticker.heikinashi(t)\nc = request.security(t2, timeframe.period, low, barmerge.gaps_on)\nplot(c, style=plot.style_linebr)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.session](#var_syminfo.session)",
            "[session.extended](#const_session.extended)",
            "[session.regular](#const_session.regular)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[adjustment.none](#var_adjustment.none)",
            "[adjustment.splits](#var_adjustment.splits)",
            "[adjustment.dividends](#var_adjustment.dividends)",
            "[backadjustment.inherit](#const_backadjustment.inherit)",
            "[backadjustment.on](#const_backadjustment.on)",
            "[backadjustment.off](#const_backadjustment.off)",
            "[settlement_as_close.inherit](#const_settlement_as_close.inherit)",
            "[settlement_as_close.on](#const_settlement_as_close.on)",
            "[settlement_as_close.off](#const_settlement_as_close.off)"
          ],
          "syntax": [
            "ticker.new(prefix, ticker, session, adjustment, backadjustment, settlement_as_close) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "ticker.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "prefix",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "ticker",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "session",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "adjustment",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "backadjustment",
              "desc": "",
              "allowedTypeIDs": [
                "simple backadjustment",
                "input backadjustment",
                "const backadjustment"
              ],
              "displayType": "simple backadjustment"
            },
            {
              "name": "settlement_as_close",
              "desc": "",
              "allowedTypeIDs": [
                "simple settlement",
                "input settlement",
                "const settlement"
              ],
              "displayType": "simple settlement"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.new\", overlay=true)\nt = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)\nt2 = ticker.heikinashi(t)\nc = request.security(t2, timeframe.period, low, barmerge.gaps_on)\nplot(c, style=plot.style_linebr)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.session](#var_syminfo.session)",
            "[session.extended](#const_session.extended)",
            "[session.regular](#const_session.regular)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[adjustment.none](#var_adjustment.none)",
            "[adjustment.splits](#var_adjustment.splits)",
            "[adjustment.dividends](#var_adjustment.dividends)",
            "[backadjustment.inherit](#const_backadjustment.inherit)",
            "[backadjustment.on](#const_backadjustment.on)",
            "[backadjustment.off](#const_backadjustment.off)",
            "[settlement_as_close.inherit](#const_settlement_as_close.inherit)",
            "[settlement_as_close.on](#const_settlement_as_close.on)",
            "[settlement_as_close.off](#const_settlement_as_close.off)"
          ],
          "syntax": [
            "ticker.new(prefix, ticker, session, adjustment, backadjustment, settlement_as_close) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "ticker.standard",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.standard\", overlay = true)\n// This script should be run on a non-standard chart such as HA, Renko...\n\n// Requests data from the chart type the script is running on.\nchartTypeValue = request.security(syminfo.tickerid, \"1D\", close)\n\n// Request data from the standard chart type, regardless of the chart type the script is running on.\nstandardChartValue = request.security(ticker.standard(syminfo.tickerid), \"1D\", close)\n\n// This will not use a standard ticker ID because the `symbol` argument contains only the ticker — not the prefix (exchange).\nstandardChartValue2 = request.security(ticker.standard(syminfo.ticker), \"1D\", close)\n\nplot(chartTypeValue)\nplot(standardChartValue, color = color.green)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[request.security()](#fun_request.security)"
          ],
          "syntax": [
            "ticker.standard(symbol) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "ticker.standard",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.standard\", overlay = true)\n// This script should be run on a non-standard chart such as HA, Renko...\n\n// Requests data from the chart type the script is running on.\nchartTypeValue = request.security(syminfo.tickerid, \"1D\", close)\n\n// Request data from the standard chart type, regardless of the chart type the script is running on.\nstandardChartValue = request.security(ticker.standard(syminfo.tickerid), \"1D\", close)\n\n// This will not use a standard ticker ID because the `symbol` argument contains only the ticker — not the prefix (exchange).\nstandardChartValue2 = request.security(ticker.standard(syminfo.ticker), \"1D\", close)\n\nplot(chartTypeValue)\nplot(standardChartValue, color = color.green)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[request.security()](#fun_request.security)"
          ],
          "syntax": [
            "ticker.standard(symbol) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "syminfo.prefix",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo.prefix fun\", overlay=true)\ni_sym = input.symbol(\"NASDAQ:AAPL\")\npref = syminfo.prefix(i_sym)\ntick = syminfo.ticker(i_sym)\nt = ticker.new(pref, tick, session.extended)\ns = request.security(t, \"1D\", close)\nplot(s)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.prefix](#var_syminfo.prefix)",
            "[syminfo.ticker()](#fun_syminfo.ticker)",
            "[ticker.new()](#fun_ticker.new)"
          ],
          "syntax": [
            "syminfo.prefix(symbol) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "syminfo.prefix",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo.prefix fun\", overlay=true)\ni_sym = input.symbol(\"NASDAQ:AAPL\")\npref = syminfo.prefix(i_sym)\ntick = syminfo.ticker(i_sym)\nt = ticker.new(pref, tick, session.extended)\ns = request.security(t, \"1D\", close)\nplot(s)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.prefix](#var_syminfo.prefix)",
            "[syminfo.ticker()](#fun_syminfo.ticker)",
            "[ticker.new()](#fun_ticker.new)"
          ],
          "syntax": [
            "syminfo.prefix(symbol) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "syminfo.ticker",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo.ticker fun\", overlay=true)\ni_sym = input.symbol(\"NASDAQ:AAPL\")\npref = syminfo.prefix(i_sym)\ntick = syminfo.ticker(i_sym)\nt = ticker.new(pref, tick, session.extended)\ns = request.security(t, \"1D\", close)\nplot(s)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.prefix](#var_syminfo.prefix)",
            "[syminfo.prefix()](#fun_syminfo.prefix)",
            "[ticker.new()](#fun_ticker.new)"
          ],
          "syntax": [
            "syminfo.ticker(symbol) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "syminfo.ticker",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"syminfo.ticker fun\", overlay=true)\ni_sym = input.symbol(\"NASDAQ:AAPL\")\npref = syminfo.prefix(i_sym)\ntick = syminfo.ticker(i_sym)\nt = ticker.new(pref, tick, session.extended)\ns = request.security(t, \"1D\", close)\nplot(s)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.prefix](#var_syminfo.prefix)",
            "[syminfo.prefix()](#fun_syminfo.prefix)",
            "[ticker.new()](#fun_ticker.new)"
          ],
          "syntax": [
            "syminfo.ticker(symbol) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "ticker.modify",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "tickerid",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "session",
              "desc": "",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "adjustment",
              "desc": "",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "backadjustment",
              "desc": "",
              "allowedTypeIDs": [
                "simple backadjustment",
                "input backadjustment",
                "const backadjustment"
              ],
              "displayType": "simple backadjustment"
            },
            {
              "name": "settlement_as_close",
              "desc": "",
              "allowedTypeIDs": [
                "simple settlement",
                "input settlement",
                "const settlement"
              ],
              "displayType": "simple settlement"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker_modify\", overlay=true)\nt1 = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)\nc1 = request.security(t1, \"D\", close)\nt2 = ticker.modify(t1, session.extended)\nc2 = request.security(t2, \"2D\", close)\nplot(c1)\nplot(c2)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.session](#var_syminfo.session)",
            "[session.extended](#const_session.extended)",
            "[session.regular](#const_session.regular)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[adjustment.none](#const_adjustment.none)",
            "[adjustment.splits](#const_adjustment.splits)",
            "[adjustment.dividends](#const_adjustment.dividends)",
            "[backadjustment.inherit](#const_backadjustment.inherit)",
            "[backadjustment.on](#const_backadjustment.on)",
            "[backadjustment.off](#const_backadjustment.off)",
            "[settlement_as_close.inherit](#const_settlement_as_close.inherit)",
            "[settlement_as_close.on](#const_settlement_as_close.on)",
            "[settlement_as_close.off](#const_settlement_as_close.off)"
          ],
          "syntax": [
            "ticker.modify(tickerid, session, adjustment, backadjustment, settlement_as_close) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "ticker.modify",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "tickerid",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "session",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "adjustment",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "backadjustment",
              "desc": "",
              "allowedTypeIDs": [
                "simple backadjustment",
                "input backadjustment",
                "const backadjustment"
              ],
              "displayType": "simple backadjustment"
            },
            {
              "name": "settlement_as_close",
              "desc": "",
              "allowedTypeIDs": [
                "simple settlement",
                "input settlement",
                "const settlement"
              ],
              "displayType": "simple settlement"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker_modify\", overlay=true)\nt1 = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)\nc1 = request.security(t1, \"D\", close)\nt2 = ticker.modify(t1, session.extended)\nc2 = request.security(t2, \"2D\", close)\nplot(c1)\nplot(c2)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[syminfo.session](#var_syminfo.session)",
            "[session.extended](#const_session.extended)",
            "[session.regular](#const_session.regular)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[adjustment.none](#const_adjustment.none)",
            "[adjustment.splits](#const_adjustment.splits)",
            "[adjustment.dividends](#const_adjustment.dividends)",
            "[backadjustment.inherit](#const_backadjustment.inherit)",
            "[backadjustment.on](#const_backadjustment.on)",
            "[backadjustment.off](#const_backadjustment.off)",
            "[settlement_as_close.inherit](#const_settlement_as_close.inherit)",
            "[settlement_as_close.on](#const_settlement_as_close.on)",
            "[settlement_as_close.off](#const_settlement_as_close.off)"
          ],
          "syntax": [
            "ticker.modify(tickerid, session, adjustment, backadjustment, settlement_as_close) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "ticker.inherit",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "from_tickerid",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.inherit\")\n\n//@variable A \"NASDAQ:AAPL\" ticker ID with Extender Hours enabled.\ntickerExtHours = ticker.new(\"NASDAQ\", \"AAPL\", session.extended)\n//@variable A Heikin Ashi ticker ID for \"NASDAQ:AAPL\" with Extended Hours enabled.\nHAtickerExtHours = ticker.heikinashi(tickerExtHours)\n//@variable The \"NASDAQ:MSFT\" symbol with no modifiers.\ntestSymbol = \"NASDAQ:MSFT\"\n//@variable A ticker ID for \"NASDAQ:MSFT\" with inherited Heikin Ashi and Extended Hours modifiers.\ntestSymbolHAtickerExtHours = ticker.inherit(HAtickerExtHours, testSymbol)\n\n//@variable The `close` price requested using \"NASDAQ:MSFT\" with inherited modifiers.\nsecData = request.security(testSymbolHAtickerExtHours, \"60\", close, ignore_invalid_symbol = true)\n//@variable The `close` price requested using \"NASDAQ:MSFT\" without modifiers.\ncompareData = request.security(testSymbol, \"60\", close, ignore_invalid_symbol = true)\n\nplot(secData, color = color.green)\nplot(compareData)"
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ticker.inherit(from_tickerid, symbol) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "ticker.inherit",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "from_tickerid",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.inherit\")\n\n//@variable A \"NASDAQ:AAPL\" ticker ID with Extender Hours enabled.\ntickerExtHours = ticker.new(\"NASDAQ\", \"AAPL\", session.extended)\n//@variable A Heikin Ashi ticker ID for \"NASDAQ:AAPL\" with Extended Hours enabled.\nHAtickerExtHours = ticker.heikinashi(tickerExtHours)\n//@variable The \"NASDAQ:MSFT\" symbol with no modifiers.\ntestSymbol = \"NASDAQ:MSFT\"\n//@variable A ticker ID for \"NASDAQ:MSFT\" with inherited Heikin Ashi and Extended Hours modifiers.\ntestSymbolHAtickerExtHours = ticker.inherit(HAtickerExtHours, testSymbol)\n\n//@variable The `close` price requested using \"NASDAQ:MSFT\" with inherited modifiers.\nsecData = request.security(testSymbolHAtickerExtHours, \"60\", close, ignore_invalid_symbol = true)\n//@variable The `close` price requested using \"NASDAQ:MSFT\" without modifiers.\ncompareData = request.security(testSymbol, \"60\", close, ignore_invalid_symbol = true)\n\nplot(secData, color = color.green)\nplot(compareData)"
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ticker.inherit(from_tickerid, symbol) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "ticker.heikinashi",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.heikinashi\", overlay=true)\nheikinashi_close = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)\n\nheikinashi_aapl_60_close = request.security(ticker.heikinashi(\"AAPL\"), \"60\", close)\nplot(heikinashi_close)\nplot(heikinashi_aapl_60_close)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security()](#fun_request.security)",
            "[ticker.renko()](#fun_ticker.renko)",
            "[ticker.linebreak()](#fun_ticker.linebreak)",
            "[ticker.kagi()](#fun_ticker.kagi)",
            "[ticker.pointfigure()](#fun_ticker.pointfigure)"
          ],
          "syntax": [
            "ticker.heikinashi(symbol) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "ticker.heikinashi",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.heikinashi\", overlay=true)\nheikinashi_close = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)\n\nheikinashi_aapl_60_close = request.security(ticker.heikinashi(\"AAPL\"), \"60\", close)\nplot(heikinashi_close)\nplot(heikinashi_aapl_60_close)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security()](#fun_request.security)",
            "[ticker.renko()](#fun_ticker.renko)",
            "[ticker.linebreak()](#fun_ticker.linebreak)",
            "[ticker.kagi()](#fun_ticker.kagi)",
            "[ticker.pointfigure()](#fun_ticker.pointfigure)"
          ],
          "syntax": [
            "ticker.heikinashi(symbol) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "ticker.renko",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "style",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "param",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "request_wicks",
              "desc": "",
              "allowedTypeIDs": [
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "simple bool"
            },
            {
              "name": "source",
              "desc": "",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.renko\", overlay=true)\nrenko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)\nrenko_close = request.security(renko_tickerid, timeframe.period, close)\nplot(renko_close)"
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Renko candles\", overlay=false)\nrenko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)\n[renko_open, renko_high, renko_low, renko_close] = request.security(renko_tickerid, timeframe.period, [open, high, low, close])\nplotcandle(renko_open, renko_high, renko_low, renko_close, color = renko_close > renko_open ? color.green : color.red)"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security()](#fun_request.security)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[ticker.linebreak()](#fun_ticker.linebreak)",
            "[ticker.kagi()](#fun_ticker.kagi)",
            "[ticker.pointfigure()](#fun_ticker.pointfigure)"
          ],
          "syntax": [
            "ticker.renko(symbol, style, param, request_wicks, source) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "ticker.renko",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "style",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "param",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "request_wicks",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "source",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.renko\", overlay=true)\nrenko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)\nrenko_close = request.security(renko_tickerid, timeframe.period, close)\nplot(renko_close)"
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Renko candles\", overlay=false)\nrenko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)\n[renko_open, renko_high, renko_low, renko_close] = request.security(renko_tickerid, timeframe.period, [open, high, low, close])\nplotcandle(renko_open, renko_high, renko_low, renko_close, color = renko_close > renko_open ? color.green : color.red)"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security()](#fun_request.security)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[ticker.linebreak()](#fun_ticker.linebreak)",
            "[ticker.kagi()](#fun_ticker.kagi)",
            "[ticker.pointfigure()](#fun_ticker.pointfigure)"
          ],
          "syntax": [
            "ticker.renko(symbol, style, param, request_wicks, source) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "ticker.linebreak",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "number_of_lines",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.linebreak\", overlay=true)\nlinebreak_tickerid = ticker.linebreak(syminfo.tickerid, 3)\nlinebreak_close = request.security(linebreak_tickerid, timeframe.period, close)\nplot(linebreak_close)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security()](#fun_request.security)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[ticker.renko()](#fun_ticker.renko)",
            "[ticker.kagi()](#fun_ticker.kagi)",
            "[ticker.pointfigure()](#fun_ticker.pointfigure)"
          ],
          "syntax": [
            "ticker.linebreak(symbol, number_of_lines) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "ticker.linebreak",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "number_of_lines",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.linebreak\", overlay=true)\nlinebreak_tickerid = ticker.linebreak(syminfo.tickerid, 3)\nlinebreak_close = request.security(linebreak_tickerid, timeframe.period, close)\nplot(linebreak_close)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security()](#fun_request.security)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[ticker.renko()](#fun_ticker.renko)",
            "[ticker.kagi()](#fun_ticker.kagi)",
            "[ticker.pointfigure()](#fun_ticker.pointfigure)"
          ],
          "syntax": [
            "ticker.linebreak(symbol, number_of_lines) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "ticker.kagi",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "reversal",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.kagi\", overlay=true)\nkagi_tickerid = ticker.kagi(syminfo.tickerid, 3)\nkagi_close = request.security(kagi_tickerid, timeframe.period, close)\nplot(kagi_close)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security()](#fun_request.security)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[ticker.renko()](#fun_ticker.renko)",
            "[ticker.linebreak()](#fun_ticker.linebreak)",
            "[ticker.pointfigure()](#fun_ticker.pointfigure)"
          ],
          "syntax": [
            "ticker.kagi(symbol, reversal) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "ticker.kagi",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "reversal",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.kagi\", overlay=true)\nkagi_tickerid = ticker.kagi(syminfo.tickerid, 3)\nkagi_close = request.security(kagi_tickerid, timeframe.period, close)\nplot(kagi_close)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security()](#fun_request.security)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[ticker.renko()](#fun_ticker.renko)",
            "[ticker.linebreak()](#fun_ticker.linebreak)",
            "[ticker.pointfigure()](#fun_ticker.pointfigure)"
          ],
          "syntax": [
            "ticker.kagi(symbol, reversal) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "ticker.kagi",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "param",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "style",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.kagi\", overlay=true)\nkagi_tickerid = ticker.kagi(syminfo.tickerid, 3)\nkagi_close = request.security(kagi_tickerid, timeframe.period, close)\nplot(kagi_close)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security()](#fun_request.security)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[ticker.renko()](#fun_ticker.renko)",
            "[ticker.linebreak()](#fun_ticker.linebreak)",
            "[ticker.pointfigure()](#fun_ticker.pointfigure)"
          ],
          "syntax": [
            "ticker.kagi(symbol, param, style) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "ticker.kagi",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "param",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "style",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.kagi\", overlay=true)\nkagi_tickerid = ticker.kagi(syminfo.tickerid, 3)\nkagi_close = request.security(kagi_tickerid, timeframe.period, close)\nplot(kagi_close)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security()](#fun_request.security)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[ticker.renko()](#fun_ticker.renko)",
            "[ticker.linebreak()](#fun_ticker.linebreak)",
            "[ticker.pointfigure()](#fun_ticker.pointfigure)"
          ],
          "syntax": [
            "ticker.kagi(symbol, param, style) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "ticker.pointfigure",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "style",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "param",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "reversal",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.pointfigure\", overlay=true)\npnf_tickerid = ticker.pointfigure(syminfo.tickerid, \"hl\", \"Traditional\", 1, 3)\npnf_close = request.security(pnf_tickerid, timeframe.period, close)\nplot(pnf_close)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security()](#fun_request.security)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[ticker.renko()](#fun_ticker.renko)",
            "[ticker.linebreak()](#fun_ticker.linebreak)",
            "[ticker.kagi()](#fun_ticker.kagi)"
          ],
          "syntax": [
            "ticker.pointfigure(symbol, source, style, param, reversal) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "ticker.pointfigure",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "style",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "param",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "reversal",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ticker.pointfigure\", overlay=true)\npnf_tickerid = ticker.pointfigure(syminfo.tickerid, \"hl\", \"Traditional\", 1, 3)\npnf_close = request.security(pnf_tickerid, timeframe.period, close)\nplot(pnf_close)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[syminfo.tickerid](#var_syminfo.tickerid)",
            "[syminfo.ticker](#var_syminfo.ticker)",
            "[request.security()](#fun_request.security)",
            "[ticker.heikinashi()](#fun_ticker.heikinashi)",
            "[ticker.renko()](#fun_ticker.renko)",
            "[ticker.linebreak()](#fun_ticker.linebreak)",
            "[ticker.kagi()](#fun_ticker.kagi)"
          ],
          "syntax": [
            "ticker.pointfigure(symbol, source, style, param, reversal) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "time",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "timeframe",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "session",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "bars_back",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "timeframe_bars_back",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Time\", overlay=true)\n// Try this on chart AAPL,1\ntimeinrange(res, sess) => not na(time(res, sess, \"America/New_York\")) ? 1 : 0\nplot(timeinrange(\"1\", \"1300-1400\"), color=color.red)\n\n// This plots 1.0 at every start of 10 minute bar on a 1 minute chart:\nnewbar(res) => ta.change(time(res)) == 0 ? 0 : 1\nplot(newbar(\"10\"))"
              ]
            },
            {
              "desc": [
                "",
                "",
                "",
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Time\", overlay=true)\nt1 = time(timeframe.period, \"0000-0000:23456\")\nbgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Time\", overlay=true)\nt1 = time(timeframe.period, \"1000-1100,1400-1500:23456\")\nbgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[time](#var_time)"
          ],
          "syntax": [
            "time(timeframe, session, bars_back, timeframe_bars_back) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "time",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "timeframe",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "session",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "timezone",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "bars_back",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "timeframe_bars_back",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Time\", overlay=true)\n// Try this on chart AAPL,1\ntimeinrange(res, sess) => not na(time(res, sess, \"America/New_York\")) ? 1 : 0\nplot(timeinrange(\"1\", \"1300-1400\"), color=color.red)\n\n// This plots 1.0 at every start of 10 minute bar on a 1 minute chart:\nnewbar(res) => ta.change(time(res)) == 0 ? 0 : 1\nplot(newbar(\"10\"))"
              ]
            },
            {
              "desc": [
                "",
                "",
                "",
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Time\", overlay=true)\nt1 = time(timeframe.period, \"0000-0000:23456\")\nbgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"Time\", overlay=true)\nt1 = time(timeframe.period, \"1000-1100,1400-1500:23456\")\nbgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[time](#var_time)"
          ],
          "syntax": [
            "time(timeframe, session, timezone, bars_back, timeframe_bars_back) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "time_close",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "timeframe",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "session",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "bars_back",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "timeframe_bars_back",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Time\", overlay=true)\nt1 = time_close(timeframe.period, \"1200-1300\", \"America/New_York\")\nbgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[time_close](#var_time_close)"
          ],
          "syntax": [
            "time_close(timeframe, session, bars_back, timeframe_bars_back) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "time_close",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "timeframe",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "session",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "timezone",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "bars_back",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "timeframe_bars_back",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "returns": [
            ""
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Time\", overlay=true)\nt1 = time_close(timeframe.period, \"1200-1300\", \"America/New_York\")\nbgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[time_close](#var_time_close)"
          ],
          "syntax": [
            "time_close(timeframe, session, timezone, bars_back, timeframe_bars_back) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "timestamp",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "dateString",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"timestamp\")\nplot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)\nplot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)\nplot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)\nplot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))\nplot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)\nplot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)\nplot(timestamp(\"Feb 01 2020 22:10:05\"))\nplot(timestamp(\"2011-10-10T14:48:00\"))\nplot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[time()](#fun_time)",
            "[time](#var_time)",
            "[timenow](#var_timenow)",
            "[syminfo.timezone](#var_syminfo.timezone)"
          ],
          "syntax": [
            "timestamp(dateString) → const int"
          ],
          "returnedTypes": [
            "const int"
          ]
        },
        {
          "name": "timestamp",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "dateString",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"timestamp\")\nplot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)\nplot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)\nplot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)\nplot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))\nplot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)\nplot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)\nplot(timestamp(\"Feb 01 2020 22:10:05\"))\nplot(timestamp(\"2011-10-10T14:48:00\"))\nplot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[time()](#fun_time)",
            "[time](#var_time)",
            "[timenow](#var_timenow)",
            "[syminfo.timezone](#var_syminfo.timezone)"
          ],
          "syntax": [
            "timestamp(dateString) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "timestamp",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "year",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "month",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "day",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "hour",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "minute",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "second",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"timestamp\")\nplot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)\nplot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)\nplot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)\nplot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))\nplot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)\nplot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)\nplot(timestamp(\"Feb 01 2020 22:10:05\"))\nplot(timestamp(\"2011-10-10T14:48:00\"))\nplot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[time()](#fun_time)",
            "[time](#var_time)",
            "[timenow](#var_timenow)",
            "[syminfo.timezone](#var_syminfo.timezone)"
          ],
          "syntax": [
            "timestamp(year, month, day, hour, minute, second) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "timestamp",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "year",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "month",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "day",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "hour",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "minute",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "second",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"timestamp\")\nplot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)\nplot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)\nplot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)\nplot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))\nplot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)\nplot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)\nplot(timestamp(\"Feb 01 2020 22:10:05\"))\nplot(timestamp(\"2011-10-10T14:48:00\"))\nplot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[time()](#fun_time)",
            "[time](#var_time)",
            "[timenow](#var_timenow)",
            "[syminfo.timezone](#var_syminfo.timezone)"
          ],
          "syntax": [
            "timestamp(year, month, day, hour, minute, second) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "timestamp",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "timezone",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "year",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "month",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "day",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "hour",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "minute",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "second",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"timestamp\")\nplot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)\nplot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)\nplot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)\nplot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))\nplot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)\nplot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)\nplot(timestamp(\"Feb 01 2020 22:10:05\"))\nplot(timestamp(\"2011-10-10T14:48:00\"))\nplot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[time()](#fun_time)",
            "[time](#var_time)",
            "[timenow](#var_timenow)",
            "[syminfo.timezone](#var_syminfo.timezone)"
          ],
          "syntax": [
            "timestamp(timezone, year, month, day, hour, minute, second) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "timestamp",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "timezone",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "year",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "month",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "day",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "hour",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "minute",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "second",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"timestamp\")\nplot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)\nplot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)\nplot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)\nplot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))\nplot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)\nplot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)\nplot(timestamp(\"Feb 01 2020 22:10:05\"))\nplot(timestamp(\"2011-10-10T14:48:00\"))\nplot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[time()](#fun_time)",
            "[time](#var_time)",
            "[timenow](#var_timenow)",
            "[syminfo.timezone](#var_syminfo.timezone)"
          ],
          "syntax": [
            "timestamp(timezone, year, month, day, hour, minute, second) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "year",
          "args": [
            {
              "name": "time",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "timezone",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[year](#var_year)",
            "[time()](#fun_time)",
            "[month()](#fun_month)",
            "[dayofmonth()](#fun_dayofmonth)",
            "[dayofweek()](#fun_dayofweek)",
            "[hour()](#fun_hour)",
            "[minute()](#fun_minute)",
            "[second()](#fun_second)"
          ],
          "syntax": [
            "year(time, timezone) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "month",
          "args": [
            {
              "name": "time",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "timezone",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[month](#var_month)",
            "[time()](#fun_time)",
            "[year()](#fun_year)",
            "[dayofmonth()](#fun_dayofmonth)",
            "[dayofweek()](#fun_dayofweek)",
            "[hour()](#fun_hour)",
            "[minute()](#fun_minute)",
            "[second()](#fun_second)"
          ],
          "syntax": [
            "month(time, timezone) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "weekofyear",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "time",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "timezone",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[weekofyear](#var_weekofyear)",
            "[dayofmonth()](#fun_dayofmonth)",
            "[dayofweek()](#fun_dayofweek)",
            "[time()](#fun_time)",
            "[year()](#fun_year)",
            "[month()](#fun_month)",
            "[hour()](#fun_hour)",
            "[minute()](#fun_minute)",
            "[second()](#fun_second)"
          ],
          "syntax": [
            "weekofyear(time, timezone) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "dayofmonth",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "time",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "timezone",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[dayofmonth](#var_dayofmonth)",
            "[dayofweek()](#fun_dayofweek)",
            "[weekofyear()](#fun_weekofyear)",
            "[time()](#fun_time)",
            "[year()](#fun_year)",
            "[month()](#fun_month)",
            "[hour()](#fun_hour)",
            "[minute()](#fun_minute)",
            "[second()](#fun_second)"
          ],
          "syntax": [
            "dayofmonth(time, timezone) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "dayofweek",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "time",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "timezone",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[dayofweek](#var_dayofweek)",
            "[dayofmonth()](#fun_dayofmonth)",
            "[weekofyear()](#fun_weekofyear)",
            "[time()](#fun_time)",
            "[year()](#fun_year)",
            "[month()](#fun_month)",
            "[hour()](#fun_hour)",
            "[minute()](#fun_minute)",
            "[second()](#fun_second)"
          ],
          "syntax": [
            "dayofweek(time, timezone) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "hour",
          "args": [
            {
              "name": "time",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "timezone",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[hour](#var_hour)",
            "[time()](#fun_time)",
            "[year()](#fun_year)",
            "[month()](#fun_month)",
            "[dayofmonth()](#fun_dayofmonth)",
            "[dayofweek()](#fun_dayofweek)",
            "[minute()](#fun_minute)",
            "[second()](#fun_second)"
          ],
          "syntax": [
            "hour(time, timezone) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "minute",
          "args": [
            {
              "name": "time",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "timezone",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[minute](#var_minute)",
            "[time()](#fun_time)",
            "[year()](#fun_year)",
            "[month()](#fun_month)",
            "[dayofmonth()](#fun_dayofmonth)",
            "[dayofweek()](#fun_dayofweek)",
            "[hour()](#fun_hour)",
            "[second()](#fun_second)"
          ],
          "syntax": [
            "minute(time, timezone) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "second",
          "args": [
            {
              "name": "time",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "timezone",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[second](#var_second)",
            "[time()](#fun_time)",
            "[year()](#fun_year)",
            "[month()](#fun_month)",
            "[dayofmonth()](#fun_dayofmonth)",
            "[dayofweek()](#fun_dayofweek)",
            "[hour()](#fun_hour)",
            "[minute()](#fun_minute)"
          ],
          "syntax": [
            "second(time, timezone) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "ta.cross",
          "args": [
            {
              "name": "source1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "source2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[ta.change()](#fun_ta.change)"
          ],
          "syntax": [
            "ta.cross(source1, source2) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "ta.cog",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.cog\", overlay=true)\nplot(ta.cog(close, 10))\n\n// the same on pine\npine_cog(source, length) =>\n    sum = math.sum(source, length)\n    num = 0.0\n    for i = 0 to length - 1\n        price = source[i]\n        num := num + price * (i + 1)\n    -num / sum\n\nplot(pine_cog(close, 10))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.stoch()](#fun_ta.stoch)"
          ],
          "syntax": [
            "ta.cog(source, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.alma",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "series",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "offset",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "sigma",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "floor",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "simple bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.alma\", overlay=true)\nplot(ta.alma(close, 9, 0.85, 6))\n\n// same on pine, but much less efficient\npine_alma(series, windowsize, offset, sigma) =>\n    m = offset * (windowsize - 1)\n    //m = math.floor(offset * (windowsize - 1)) // Used as m when math.floor=true\n    s = windowsize / sigma\n    norm = 0.0\n    sum = 0.0\n    for i = 0 to windowsize - 1\n        weight = math.exp(-1 * math.pow(i - m, 2) / (2 * math.pow(s, 2)))\n        norm := norm + weight\n        sum := sum + series[windowsize - i - 1] * weight\n    sum / norm\nplot(pine_alma(close, 9, 0.85, 6))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.sma()](#fun_ta.sma)",
            "[ta.ema()](#fun_ta.ema)",
            "[ta.rma()](#fun_ta.rma)",
            "[ta.wma()](#fun_ta.wma)",
            "[ta.vwma()](#fun_ta.vwma)",
            "[ta.swma()](#fun_ta.swma)"
          ],
          "syntax": [
            "ta.alma(series, length, offset, sigma, floor) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.cmo",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "series",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.cmo\")\nplot(ta.cmo(close, 5), color=color.yellow)\n\n// the same on pine\nf_cmo(src, length) =>\n    float mom = ta.change(src)\n    float sm1 = math.sum((mom >= 0) ? mom : 0.0, length)\n    float sm2 = math.sum((mom >= 0) ? 0.0 : -mom, length)\n    100 * (sm1 - sm2) / (sm1 + sm2)\n\nplot(f_cmo(close, 5))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.rsi()](#fun_ta.rsi)",
            "[ta.stoch()](#fun_ta.stoch)",
            "[math.sum()](#fun_math.sum)"
          ],
          "syntax": [
            "ta.cmo(series, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.mfi",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "series",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Money Flow Index\")\n\nplot(ta.mfi(hlc3, 14), color=color.yellow)\n\n// the same on pine\npine_mfi(src, length) =>\n    float upper = math.sum(volume * (ta.change(src) <= 0.0 ? 0.0 : src), length)\n    float lower = math.sum(volume * (ta.change(src) >= 0.0 ? 0.0 : src), length)\n    mfi = 100.0 - (100.0 / (1.0 + upper / lower))\n    mfi\n\nplot(pine_mfi(hlc3, 14))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.rsi()](#fun_ta.rsi)",
            "[math.sum()](#fun_math.sum)"
          ],
          "syntax": [
            "ta.mfi(series, length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.wpr",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Williams %R\", shorttitle=\"%R\", format=format.price, precision=2)\nplot(ta.wpr(14), title=\"%R\", color=color.new(#ff6d00, 0))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.mfi()](#fun_ta.mfi)",
            "[ta.cmo()](#fun_ta.cmo)"
          ],
          "syntax": [
            "ta.wpr(length) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.bb",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "series",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "mult",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.bb\")\n\n[middle, upper, lower] = ta.bb(close, 5, 4)\nplot(middle, color=color.yellow)\nplot(upper, color=color.yellow)\nplot(lower, color=color.yellow)\n\n// the same on pine\nf_bb(src, length, mult) =>\n    float basis = ta.sma(src, length)\n    float dev = mult * ta.stdev(src, length)\n    [basis, basis + dev, basis - dev]\n\n[pineMiddle, pineUpper, pineLower] = f_bb(close, 5, 4)\n\nplot(pineMiddle)\nplot(pineUpper)\nplot(pineLower)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.sma()](#fun_ta.sma)",
            "[ta.stdev()](#fun_ta.stdev)",
            "[ta.kc()](#fun_ta.kc)"
          ],
          "syntax": [
            "ta.bb(series, length, mult) → [series float, series float, series float]"
          ],
          "returnedTypes": [
            "[series float, series float, series float]"
          ]
        },
        {
          "name": "ta.bbw",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "series",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "mult",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.bbw\")\n\nplot(ta.bbw(close, 5, 4), color=color.yellow)\n\n// the same on pine\nf_bbw(src, length, mult) =>\n    float basis = ta.sma(src, length)\n    float dev = mult * ta.stdev(src, length)\n    (((basis + dev) - (basis - dev)) / basis) * 100\n\nplot(f_bbw(close, 5, 4))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.bb()](#fun_ta.bb)",
            "[ta.sma()](#fun_ta.sma)",
            "[ta.stdev()](#fun_ta.stdev)"
          ],
          "syntax": [
            "ta.bbw(series, length, mult) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.kc",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "series",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "mult",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "useTrueRange",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "simple bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.kc\")\n\n[middle, upper, lower] = ta.kc(close, 5, 4)\nplot(middle, color=color.yellow)\nplot(upper, color=color.yellow)\nplot(lower, color=color.yellow)\n\n\n// the same on pine\nf_kc(src, length, mult, useTrueRange) =>\n    float basis = ta.ema(src, length)\n    float span = (useTrueRange) ? ta.tr : (high - low)\n    float rangeEma = ta.ema(span, length)\n    [basis, basis + rangeEma * mult, basis - rangeEma * mult]\n\n[pineMiddle, pineUpper, pineLower] = f_kc(close, 5, 4, true)\n\nplot(pineMiddle)\nplot(pineUpper)\nplot(pineLower)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.ema()](#fun_ta.ema)",
            "[ta.atr()](#fun_ta.atr)",
            "[ta.bb()](#fun_ta.bb)"
          ],
          "syntax": [
            "ta.kc(series, length, mult, useTrueRange) → [series float, series float, series float]"
          ],
          "returnedTypes": [
            "[series float, series float, series float]"
          ]
        },
        {
          "name": "ta.kcw",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "series",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "mult",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "useTrueRange",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "simple bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"ta.kcw\")\n\nplot(ta.kcw(close, 5, 4), color=color.yellow)\n\n// the same on pine\nf_kcw(src, length, mult, useTrueRange) =>\n    float basis = ta.ema(src, length)\n    float span = (useTrueRange) ? ta.tr : (high - low)\n    float rangeEma = ta.ema(span, length)\n\n    ((basis + rangeEma * mult) - (basis - rangeEma * mult)) / basis\n\nplot(f_kcw(close, 5, 4, true))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[ta.kc()](#fun_ta.kc)",
            "[ta.ema()](#fun_ta.ema)",
            "[ta.atr()](#fun_ta.atr)",
            "[ta.bb()](#fun_ta.bb)"
          ],
          "syntax": [
            "ta.kcw(series, length, mult, useTrueRange) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "float",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "float(x) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "float",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "float(x) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "float",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "float(x) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "float",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "float(x) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "int",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "int(x) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "int",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int",
                "input float",
                "const float"
              ],
              "displayType": "input int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "int(x) → input int"
          ],
          "returnedTypes": [
            "input int"
          ]
        },
        {
          "name": "int",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "int(x) → const int"
          ],
          "returnedTypes": [
            "const int"
          ]
        },
        {
          "name": "int",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "int(x) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "bool",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float",
                "const bool"
              ],
              "displayType": "simple int/float/bool"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "bool(x) → const bool"
          ],
          "returnedTypes": [
            "const bool"
          ]
        },
        {
          "name": "bool",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "bool(x) → input bool"
          ],
          "returnedTypes": [
            "input bool"
          ]
        },
        {
          "name": "bool",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "simple bool"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "bool(x) → simple bool"
          ],
          "returnedTypes": [
            "simple bool"
          ]
        },
        {
          "name": "bool",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series int/float/bool"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "bool(x) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const color"
              ],
              "displayType": "const color"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "color(x) → const color"
          ],
          "returnedTypes": [
            "const color"
          ]
        },
        {
          "name": "color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input color",
                "const color"
              ],
              "displayType": "input color"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "color(x) → input color"
          ],
          "returnedTypes": [
            "input color"
          ]
        },
        {
          "name": "color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "simple color"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "color(x) → simple color"
          ],
          "returnedTypes": [
            "simple color"
          ]
        },
        {
          "name": "color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "color(x) → series color"
          ],
          "returnedTypes": [
            "series color"
          ]
        },
        {
          "name": "string",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "string(x) → const string"
          ],
          "returnedTypes": [
            "const string"
          ]
        },
        {
          "name": "string",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "string(x) → input string"
          ],
          "returnedTypes": [
            "input string"
          ]
        },
        {
          "name": "string",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "string(x) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "string",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "string(x) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "line",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "line(x) → series line"
          ],
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "name": "label",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)"
          ],
          "syntax": [
            "label(x) → series label"
          ],
          "returnedTypes": [
            "series label"
          ]
        },
        {
          "name": "table",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "table(x) → series table"
          ],
          "returnedTypes": [
            "series table"
          ]
        },
        {
          "name": "box",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "box(x) → series box"
          ],
          "returnedTypes": [
            "series box"
          ]
        },
        {
          "name": "linefill",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series linefill"
              ],
              "displayType": "series linefill"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[float()](#fun_float)",
            "[int()](#fun_int)",
            "[bool()](#fun_bool)",
            "[color()](#fun_color)",
            "[string()](#fun_string)",
            "[line()](#fun_line)",
            "[label()](#fun_label)"
          ],
          "syntax": [
            "linefill(x) → series linefill"
          ],
          "returnedTypes": [
            "series linefill"
          ]
        },
        {
          "name": "str.tostring",
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series string",
                "simple string",
                "input string",
                "const string",
                "series enum",
                "array<int>",
                "array<float>",
                "array<bool>",
                "array<string>",
                "matrix<int>",
                "matrix<float>",
                "matrix<bool>",
                "matrix<string>"
              ],
              "displayType": "series int/float/bool/string/enum/array<int/float/bool/string>/matrix<int/float/bool/string>"
            }
          ],
          "returns": [
            "",
            "",
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "str.tostring(value) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "str.tostring",
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float",
                "simple bool",
                "input bool",
                "const bool",
                "simple string",
                "input string",
                "const string",
                "simple enum"
              ],
              "displayType": "simple int/float/bool/string/enum"
            }
          ],
          "returns": [
            "",
            "",
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "str.tostring(value) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "str.tostring",
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const enum"
              ],
              "displayType": "const enum"
            }
          ],
          "returns": [
            "",
            "",
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "str.tostring(value) → const string"
          ],
          "returnedTypes": [
            "const string"
          ]
        },
        {
          "name": "str.tostring",
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "array<int>",
                "array<float>",
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "series int/float/array<int/float>/matrix<int/float>"
            },
            {
              "name": "format",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            "",
            "",
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "str.tostring(value, format) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "str.tostring",
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "format",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "returns": [
            "",
            "",
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "str.tostring(value, format) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "str.tonumber",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "string",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "str.tonumber(string) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "str.tonumber",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "string",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "str.tonumber(string) → const float"
          ],
          "returnedTypes": [
            "const float"
          ]
        },
        {
          "name": "str.tonumber",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "string",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "str.tonumber(string) → input float"
          ],
          "returnedTypes": [
            "input float"
          ]
        },
        {
          "name": "str.tonumber",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "string",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "str.tonumber(string) → simple float"
          ],
          "returnedTypes": [
            "simple float"
          ]
        },
        {
          "name": "str.trim",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.trim\")\ntrim = str.trim(\"    abc    \") // Returns \"abc\"\nlabel.new(bar_index,close,trim)"
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "str.trim(source) → const string"
          ],
          "returnedTypes": [
            "const string"
          ]
        },
        {
          "name": "str.trim",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.trim\")\ntrim = str.trim(\"    abc    \") // Returns \"abc\"\nlabel.new(bar_index,close,trim)"
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "str.trim(source) → input string"
          ],
          "returnedTypes": [
            "input string"
          ]
        },
        {
          "name": "str.trim",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.trim\")\ntrim = str.trim(\"    abc    \") // Returns \"abc\"\nlabel.new(bar_index,close,trim)"
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "str.trim(source) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "str.trim",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.trim\")\ntrim = str.trim(\"    abc    \") // Returns \"abc\"\nlabel.new(bar_index,close,trim)"
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "str.trim(source) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "str.repeat",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "repeat",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "separator",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.repeat\")\nrepeat = str.repeat(\"?\", 3, \",\") // Returns \"?,?,?\"\nlabel.new(bar_index,close,repeat)"
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "str.repeat(source, repeat, separator) → const string"
          ],
          "returnedTypes": [
            "const string"
          ]
        },
        {
          "name": "str.repeat",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "repeat",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "input int",
                "const int"
              ],
              "displayType": "input int"
            },
            {
              "name": "separator",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.repeat\")\nrepeat = str.repeat(\"?\", 3, \",\") // Returns \"?,?,?\"\nlabel.new(bar_index,close,repeat)"
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "str.repeat(source, repeat, separator) → input string"
          ],
          "returnedTypes": [
            "input string"
          ]
        },
        {
          "name": "str.repeat",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "repeat",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "separator",
              "desc": "",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.repeat\")\nrepeat = str.repeat(\"?\", 3, \",\") // Returns \"?,?,?\"\nlabel.new(bar_index,close,repeat)"
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "str.repeat(source, repeat, separator) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "str.repeat",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "repeat",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "separator",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.repeat\")\nrepeat = str.repeat(\"?\", 3, \",\") // Returns \"?,?,?\"\nlabel.new(bar_index,close,repeat)"
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "str.repeat(source, repeat, separator) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "str.replace_all",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "target",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "replacement",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "str.replace_all(source, target, replacement) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "str.replace_all",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "target",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "replacement",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "str.replace_all(source, target, replacement) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "str.contains",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "str",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.contains\")\n// If the current chart is a continuous futures chart, e.g “BTC1!”, then the function will return true, false otherwise.\nvar isFutures = str.contains(syminfo.tickerid, \"!\")\nplot(isFutures ? 1 : 0)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.pos()](#fun_str.pos)",
            "[str.match()](#fun_str.match)"
          ],
          "syntax": [
            "str.contains(source, str) → const bool"
          ],
          "returnedTypes": [
            "const bool"
          ]
        },
        {
          "name": "str.contains",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "str",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.contains\")\n// If the current chart is a continuous futures chart, e.g “BTC1!”, then the function will return true, false otherwise.\nvar isFutures = str.contains(syminfo.tickerid, \"!\")\nplot(isFutures ? 1 : 0)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.pos()](#fun_str.pos)",
            "[str.match()](#fun_str.match)"
          ],
          "syntax": [
            "str.contains(source, str) → simple bool"
          ],
          "returnedTypes": [
            "simple bool"
          ]
        },
        {
          "name": "str.contains",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "str",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.contains\")\n// If the current chart is a continuous futures chart, e.g “BTC1!”, then the function will return true, false otherwise.\nvar isFutures = str.contains(syminfo.tickerid, \"!\")\nplot(isFutures ? 1 : 0)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.pos()](#fun_str.pos)",
            "[str.match()](#fun_str.match)"
          ],
          "syntax": [
            "str.contains(source, str) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "str.substring",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "begin_pos",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "end_pos",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.substring\", overlay = true)\nsym= input.symbol(\"NASDAQ:AAPL\")\npos = str.pos(sym, \":\") // Get position of \":\" character\ntkr= str.substring(sym, pos+1) // \"AAPL\"\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, text = tkr)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[str.contains()](#fun_str.contains)",
            "[str.pos()](#fun_str.pos)",
            "[str.match()](#fun_str.match)"
          ],
          "syntax": [
            "str.substring(source, begin_pos, end_pos) → const string"
          ],
          "returnedTypes": [
            "const string"
          ]
        },
        {
          "name": "str.substring",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "begin_pos",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "end_pos",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.substring\", overlay = true)\nsym= input.symbol(\"NASDAQ:AAPL\")\npos = str.pos(sym, \":\") // Get position of \":\" character\ntkr= str.substring(sym, pos+1) // \"AAPL\"\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, text = tkr)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[str.contains()](#fun_str.contains)",
            "[str.pos()](#fun_str.pos)",
            "[str.match()](#fun_str.match)"
          ],
          "syntax": [
            "str.substring(source, begin_pos, end_pos) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "str.substring",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "begin_pos",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "end_pos",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.substring\", overlay = true)\nsym= input.symbol(\"NASDAQ:AAPL\")\npos = str.pos(sym, \":\") // Get position of \":\" character\ntkr= str.substring(sym, pos+1) // \"AAPL\"\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, text = tkr)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[str.contains()](#fun_str.contains)",
            "[str.pos()](#fun_str.pos)",
            "[str.match()](#fun_str.match)"
          ],
          "syntax": [
            "str.substring(source, begin_pos, end_pos) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "str.replace",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "target",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "replacement",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "occurrence",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.replace\")\nvar source = \"FTX:BTCUSD / FTX:BTCEUR\"\n\n// Replace first occurrence of \"FTX\" with \"BINANCE\" replacement string\nvar newSource = str.replace(source, \"FTX\", \"BINANCE\", 0)\n\nif barstate.islastconfirmedhistory\n\t// Display \"BINANCE:BTCUSD / FTX:BTCEUR\"\n\tlabel.new(bar_index, high, text = newSource)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.replace_all()](#fun_str.replace_all)",
            "[str.match()](#fun_str.match)"
          ],
          "syntax": [
            "str.replace(source, target, replacement, occurrence) → const string"
          ],
          "returnedTypes": [
            "const string"
          ]
        },
        {
          "name": "str.replace",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "target",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "replacement",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "occurrence",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.replace\")\nvar source = \"FTX:BTCUSD / FTX:BTCEUR\"\n\n// Replace first occurrence of \"FTX\" with \"BINANCE\" replacement string\nvar newSource = str.replace(source, \"FTX\", \"BINANCE\", 0)\n\nif barstate.islastconfirmedhistory\n\t// Display \"BINANCE:BTCUSD / FTX:BTCEUR\"\n\tlabel.new(bar_index, high, text = newSource)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.replace_all()](#fun_str.replace_all)",
            "[str.match()](#fun_str.match)"
          ],
          "syntax": [
            "str.replace(source, target, replacement, occurrence) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "str.replace",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "target",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "replacement",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "occurrence",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.replace\")\nvar source = \"FTX:BTCUSD / FTX:BTCEUR\"\n\n// Replace first occurrence of \"FTX\" with \"BINANCE\" replacement string\nvar newSource = str.replace(source, \"FTX\", \"BINANCE\", 0)\n\nif barstate.islastconfirmedhistory\n\t// Display \"BINANCE:BTCUSD / FTX:BTCEUR\"\n\tlabel.new(bar_index, high, text = newSource)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.replace_all()](#fun_str.replace_all)",
            "[str.match()](#fun_str.match)"
          ],
          "syntax": [
            "str.replace(source, target, replacement, occurrence) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "str.lower",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.upper()](#fun_str.upper)"
          ],
          "syntax": [
            "str.lower(source) → const string"
          ],
          "returnedTypes": [
            "const string"
          ]
        },
        {
          "name": "str.lower",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.upper()](#fun_str.upper)"
          ],
          "syntax": [
            "str.lower(source) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "str.lower",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.upper()](#fun_str.upper)"
          ],
          "syntax": [
            "str.lower(source) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "str.upper",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.lower()](#fun_str.lower)"
          ],
          "syntax": [
            "str.upper(source) → const string"
          ],
          "returnedTypes": [
            "const string"
          ]
        },
        {
          "name": "str.upper",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.lower()](#fun_str.lower)"
          ],
          "syntax": [
            "str.upper(source) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "str.upper",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.lower()](#fun_str.lower)"
          ],
          "syntax": [
            "str.upper(source) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "str.startswith",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "str",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.endswith()](#fun_str.endswith)"
          ],
          "syntax": [
            "str.startswith(source, str) → const bool"
          ],
          "returnedTypes": [
            "const bool"
          ]
        },
        {
          "name": "str.startswith",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "str",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.endswith()](#fun_str.endswith)"
          ],
          "syntax": [
            "str.startswith(source, str) → simple bool"
          ],
          "returnedTypes": [
            "simple bool"
          ]
        },
        {
          "name": "str.startswith",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "str",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.endswith()](#fun_str.endswith)"
          ],
          "syntax": [
            "str.startswith(source, str) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "str.endswith",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "str",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.startswith()](#fun_str.startswith)"
          ],
          "syntax": [
            "str.endswith(source, str) → const bool"
          ],
          "returnedTypes": [
            "const bool"
          ]
        },
        {
          "name": "str.endswith",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "str",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.startswith()](#fun_str.startswith)"
          ],
          "syntax": [
            "str.endswith(source, str) → simple bool"
          ],
          "returnedTypes": [
            "simple bool"
          ]
        },
        {
          "name": "str.endswith",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "str",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[str.startswith()](#fun_str.startswith)"
          ],
          "syntax": [
            "str.endswith(source, str) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "str.match",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "regex",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.match\")\n\ns = input.string(\"It's time to sell some NASDAQ:AAPL!\")\n\n// finding first substring that matches regular expression \"[\\w]+:[\\w]+\"\nvar string tickerid = str.match(s, \"[\\\\w]+:[\\\\w]+\")\n\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, text = tickerid) // \"NASDAQ:AAPL\""
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[str.contains()](#fun_str.contains)",
            "[str.substring()](#fun_str.substring)"
          ],
          "syntax": [
            "str.match(source, regex) → simple string"
          ],
          "returnedTypes": [
            "simple string"
          ]
        },
        {
          "name": "str.match",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "regex",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"str.match\")\n\ns = input.string(\"It's time to sell some NASDAQ:AAPL!\")\n\n// finding first substring that matches regular expression \"[\\w]+:[\\w]+\"\nvar string tickerid = str.match(s, \"[\\\\w]+:[\\\\w]+\")\n\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, text = tickerid) // \"NASDAQ:AAPL\""
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[str.contains()](#fun_str.contains)",
            "[str.substring()](#fun_str.substring)"
          ],
          "syntax": [
            "str.match(source, regex) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "str.pos",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "str",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[str.contains()](#fun_str.contains)",
            "[str.match()](#fun_str.match)",
            "[str.substring()](#fun_str.substring)"
          ],
          "syntax": [
            "str.pos(source, str) → const int"
          ],
          "returnedTypes": [
            "const int"
          ]
        },
        {
          "name": "str.pos",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "str",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[str.contains()](#fun_str.contains)",
            "[str.match()](#fun_str.match)",
            "[str.substring()](#fun_str.substring)"
          ],
          "syntax": [
            "str.pos(source, str) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "str.pos",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "str",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[str.contains()](#fun_str.contains)",
            "[str.match()](#fun_str.match)",
            "[str.substring()](#fun_str.substring)"
          ],
          "syntax": [
            "str.pos(source, str) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "str.split",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "string",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "separator",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "str.split(string, separator) → array<string>"
          ],
          "returnedTypes": [
            "array<string>"
          ]
        },
        {
          "name": "str.length",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "string",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "str.length(string) → const int"
          ],
          "returnedTypes": [
            "const int"
          ]
        },
        {
          "name": "str.length",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "string",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "str.length(string) → simple int"
          ],
          "returnedTypes": [
            "simple int"
          ]
        },
        {
          "name": "str.length",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "string",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "str.length(string) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "ta.percentile_nearest_rank",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "percentage",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[ta.percentile_linear_interpolation()](#fun_ta.percentile_linear_interpolation)",
            "http://en.wikipedia.org/wiki/Percentile#The_Nearest_Rank_method"
          ],
          "syntax": [
            "ta.percentile_nearest_rank(source, length, percentage) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.percentile_linear_interpolation",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "length",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "percentage",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[ta.percentile_nearest_rank()](#fun_ta.percentile_nearest_rank)"
          ],
          "syntax": [
            "ta.percentile_linear_interpolation(source, length, percentage) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.crossover",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "source2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "ta.crossover(source1, source2) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "ta.crossunder",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "source2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "ta.crossunder(source1, source2) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "strategy",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "title",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "shorttitle",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "format",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "precision",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "scale",
              "desc": "",
              "allowedTypeIDs": [
                "const scale_type"
              ],
              "displayType": "const scale_type"
            },
            {
              "name": "pyramiding",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "calc_on_order_fills",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "calc_on_every_tick",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "max_bars_back",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "backtest_fill_limits_assumption",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "default_qty_type",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "default_qty_value",
              "desc": "",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "initial_capital",
              "desc": "",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "currency",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "slippage",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "commission_type",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "commission_value",
              "desc": "",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "process_orders_on_close",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "close_entries_rule",
              "desc": "",
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "margin_long",
              "desc": "",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "margin_short",
              "desc": "",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "explicit_plot_zorder",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "max_lines_count",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "max_labels_count",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "max_boxes_count",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "calc_bars_count",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "risk_free_rate",
              "desc": "",
              "allowedTypeIDs": [
                "const int",
                "const float"
              ],
              "displayType": "const int/float"
            },
            {
              "name": "use_bar_magnifier",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "fill_orders_on_standard_ohlc",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "max_polylines_count",
              "desc": "",
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            },
            {
              "name": "dynamic_requests",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "behind_chart",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"My strategy\", overlay = true)\n\n// Enter long by market if current open is greater than previous high.\nif open > high[1]\n\tstrategy.entry(\"Long\", strategy.long, 1)\n// Generate a full exit bracket (profit 10 points, loss 5 points per contract) from the entry named \"Long\".\nstrategy.exit(\"Exit\", \"Long\", profit = 10, loss = 5)"
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[indicator()](#fun_indicator)",
            "[library()](#fun_library)"
          ],
          "syntax": [
            "strategy(title, shorttitle, overlay, format, precision, scale, pyramiding, calc_on_order_fills, calc_on_every_tick, max_bars_back, backtest_fill_limits_assumption, default_qty_type, default_qty_value, initial_capital, currency, slippage, commission_type, commission_value, process_orders_on_close, close_entries_rule, margin_long, margin_short, explicit_plot_zorder, max_lines_count, max_labels_count, max_boxes_count, calc_bars_count, risk_free_rate, use_bar_magnifier, fill_orders_on_standard_ohlc, max_polylines_count, dynamic_requests, behind_chart) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.entry",
          "desc": [
            "",
            "",
            "",
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "direction",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series strategy_direction",
                "simple strategy_direction",
                "input strategy_direction",
                "const strategy_direction"
              ],
              "displayType": "series strategy_direction"
            },
            {
              "name": "qty",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "limit",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "stop",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "oca_name",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "oca_type",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "comment",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "alert_message",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "disable_alert",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"Market order strategy\", overlay = true)\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\n// Place a market order to close the short trade and enter a long position when `sma14` crosses over `sma28`.\nif ta.crossover(sma14, sma28)\n    strategy.entry(\"My Long Entry ID\", strategy.long)\n\n// Place a market order to close the long trade and enter a short position when `sma14` crosses under `sma28`.\nif ta.crossunder(sma14, sma28)\n    strategy.entry(\"My Short Entry ID\", strategy.short)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"Limit order strategy\", overlay=true, margin_long=100, margin_short=100)\n\n//@variable The distance from the `close` price for each limit order.\nfloat limitOffsetInput = input.int(100, \"Limit offset, in ticks\", 1) * syminfo.mintick\n\n//@function Draws a label and line at the specified `price` to visualize a limit order's level.\ndrawLimit(float price, bool isLong) =>\n    color col = isLong ? color.blue : color.red\n    label.new(\n         bar_index, price, (isLong ? \"Long\" : \"Short\") + \" limit order created\",\n         style = label.style_label_right, color = col, textcolor = color.white\n     )\n    line.new(bar_index, price, bar_index + 1, price, extend = extend.right, style = line.style_dashed, color = col)\n\n//@function Stops the `l` line from extending further.\nmethod stopExtend(line l) =>\n    l.set_x2(bar_index)\n    l.set_extend(extend.none)\n\n// Initialize two `line` variables to reference limit line IDs.\nvar line longLimit  = na\nvar line shortLimit = na\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\nif ta.crossover(sma14, sma28)\n    // Cancel any unfilled sell orders with the specified ID.\n    strategy.cancel(\"My Short Entry ID\")\n    //@variable The limit price level. Its value is `limitOffsetInput` ticks below the current `close`.\n    float limitLevel = close - limitOffsetInput\n    // Place a long limit order to close the short trade and enter a long position at the `limitLevel`.\n    strategy.entry(\"My Long Entry ID\", strategy.long, limit = limitLevel)\n    // Make new drawings for the long limit and stop extending the `shortLimit` line.\n    longLimit := drawLimit(limitLevel, isLong = true)\n    shortLimit.stopExtend()\n\nif ta.crossunder(sma14, sma28)\n    // Cancel any unfilled buy orders with the specified ID.\n    strategy.cancel(\"My Long Entry ID\")\n    //@variable The limit price level. Its value is `limitOffsetInput` ticks above the current `close`.\n    float limitLevel = close + limitOffsetInput\n    // Place a short limit order to close the long trade and enter a short position at the `limitLevel`.\n    strategy.entry(\"My Short Entry ID\", strategy.short, limit = limitLevel)\n    // Make new drawings for the short limit and stop extending the `shortLimit` line.\n    shortLimit := drawLimit(limitLevel, isLong = false)\n    longLimit.stopExtend()"
              ]
            }
          ],
          "syntax": [
            "strategy.entry(id, direction, qty, limit, stop, oca_name, oca_type, comment, alert_message, disable_alert) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.order",
          "desc": [
            "",
            "",
            "",
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "direction",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series strategy_direction",
                "simple strategy_direction",
                "input strategy_direction",
                "const strategy_direction"
              ],
              "displayType": "series strategy_direction"
            },
            {
              "name": "qty",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "limit",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "stop",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "oca_name",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "oca_type",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            },
            {
              "name": "comment",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "alert_message",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "disable_alert",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"Market order strategy\", overlay = true)\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\n// Place a market order to enter a long position when `sma14` crosses over `sma28`.\nif ta.crossover(sma14, sma28) and strategy.position_size == 0\n    strategy.order(\"My Long Entry ID\", strategy.long)\n\n// Place a market order to sell the same quantity as the long trade when `sma14` crosses under `sma28`,\n// effectively closing the long position.\nif ta.crossunder(sma14, sma28) and strategy.position_size > 0\n    strategy.order(\"My Long Exit ID\", strategy.short)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"Limit and stop exit strategy\", overlay = true)\n\n//@variable The distance from the long entry price for each short limit order.\nfloat shortOffsetInput = input.int(200, \"Sell limit/stop offset, in ticks\", 1) * syminfo.mintick\n\n//@function Draws a label and line at the specified `price` to visualize a limit order's level.\ndrawLimit(float price, bool isLong, bool isStop = false) =>\n    color col = isLong ? color.blue : color.red\n    label.new(\n         bar_index, price, (isLong ? \"Long \" : \"Short \") + (isStop ? \"stop\" : \"limit\") + \" order created\",\n         style = label.style_label_right, color = col, textcolor = color.white\n     )\n    line.new(bar_index, price, bar_index + 1, price, extend = extend.right, style = line.style_dashed, color = col)\n\n//@function Stops the `l` line from extending further.\nmethod stopExtend(line l) =>\n    l.set_x2(bar_index)\n    l.set_extend(extend.none)\n\n// Initialize two `line` variables to reference limit and stop line IDs.\nvar line profitLimit = na\nvar line lossStop    = na\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\nif ta.crossover(sma14, sma28) and strategy.position_size == 0\n    // Place a market order to enter a long position.\n    strategy.order(\"My Long Entry ID\", strategy.long)\n\nif strategy.position_size > 0 and strategy.position_size[1] == 0\n    //@variable The entry price of the long trade.\n    float entryPrice = strategy.opentrades.entry_price(0)\n    // Calculate short limit and stop levels above and below the `entryPrice`.\n    float profitLevel = entryPrice + shortOffsetInput\n    float lossLevel   = entryPrice - shortOffsetInput\n    // Place short limit and stop orders at the `profitLevel` and `lossLevel`.\n    strategy.order(\"Profit\", strategy.short, limit = profitLevel, oca_name = \"Bracket\", oca_type = strategy.oca.cancel)\n    strategy.order(\"Loss\", strategy.short, stop = lossLevel, oca_name = \"Bracket\", oca_type = strategy.oca.cancel)\n    // Make new drawings for the `profitLimit` and `lossStop` lines.\n    profitLimit := drawLimit(profitLevel, isLong = false)\n    lossStop    := drawLimit(lossLevel, isLong = false, isStop = true)\n\nif ta.change(strategy.closedtrades) > 0\n    // Stop extending the `profitLimit` and `lossStop` lines.\n    profitLimit.stopExtend()\n    lossStop.stopExtend()"
              ]
            }
          ],
          "syntax": [
            "strategy.order(id, direction, qty, limit, stop, oca_name, oca_type, comment, alert_message, disable_alert) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.exit",
          "desc": [
            "",
            "",
            "",
            "",
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "from_entry",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "qty",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "qty_percent",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "profit",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "limit",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "loss",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "stop",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "trail_price",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "trail_points",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "trail_offset",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "oca_name",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "comment",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "comment_profit",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "comment_loss",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "comment_trailing",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "alert_message",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "alert_profit",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "alert_loss",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "alert_trailing",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "disable_alert",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"Exit bracket strategy\", overlay = true)\n\n// Inputs that define the profit and loss amount of each trade as a tick distance from the entry price.\nint profitDistanceInput = input.int(100, \"Profit distance, in ticks\", 1)\nint lossDistanceInput   = input.int(100, \"Loss distance, in ticks\", 1)\n\n// Variables to track the take-profit and stop-loss price.\nvar float takeProfit = na\nvar float stopLoss   = na\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\nif ta.crossover(sma14, sma28) and strategy.opentrades == 0\n    // Place a market order to enter a long position.\n    strategy.entry(\"My Long Entry ID\", strategy.long)\n    // Place a take-profit and stop-loss order when the entry order fills.\n    strategy.exit(\"My Long Exit ID\", \"My Long Entry ID\", profit = profitDistanceInput, loss = lossDistanceInput)\n\nif ta.change(strategy.opentrades) == 1\n    //@variable The long entry price.\n    float entryPrice = strategy.opentrades.entry_price(0)\n    // Update the `takeProfit` and `stopLoss` values.\n    takeProfit := entryPrice + profitDistanceInput * syminfo.mintick\n    stopLoss   := entryPrice - lossDistanceInput * syminfo.mintick\n\nif ta.change(strategy.closedtrades) == 1\n    // Reset the `takeProfit` and `stopLoss`.\n    takeProfit := na\n    stopLoss   := na\n\n// Plot the `takeProfit` and `stopLoss`.\nplot(takeProfit, \"Take-profit level\", color.green, 2, plot.style_linebr)\nplot(stopLoss, \"Stop-loss level\", color.red, 2, plot.style_linebr)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"Trailing stop strategy\", overlay = true)\n\n//@variable The distance required to activate the trailing stop.\nfloat activationDistanceInput = input.int(100, \"Trail activation distance, in ticks\") * syminfo.mintick\n//@variable The number of ticks the trailing stop follows behind the price as it reaches new peaks.\nint trailDistanceInput = input.int(100, \"Trail distance, in ticks\")\n\n//@function Draws a label and line at the specified `price` to visualize a trailing stop order's activation level.\ndrawActivation(float price) =>\n    label.new(\n         bar_index, price, \"Activation level\", style = label.style_label_right,\n         color = color.gray, textcolor = color.white\n     )\n    line.new(\n         bar_index, price, bar_index + 1, price, extend = extend.right, style = line.style_dashed, color = color.gray\n     )\n\n//@function Stops the `l` line from extending further.\nmethod stopExtend(line l) =>\n    l.set_x2(bar_index)\n    l.set_extend(extend.none)\n\n// The activation line, active trailing stop price, and active trailing stop flag.\nvar line activationLine     = na\nvar float trailingStopPrice = na\nvar bool isActive           = false\n\nif bar_index % 100 == 0 and strategy.opentrades == 0\n    trailingStopPrice := na\n    isActive          := false\n    // Place a market order to enter a long position.\n    strategy.entry(\"My Long Entry ID\", strategy.long)\n    //@variable The activation level's price.\n    float activationPrice = close + activationDistanceInput\n    // Create a trailing stop order that activates the defined number of ticks above the entry price.\n    strategy.exit(\n         \"My Long Exit ID\", \"My Long Entry ID\", trail_price = activationPrice, trail_offset = trailDistanceInput,\n         oca_name = \"Exit\"\n     )\n    // Create new drawings at the `activationPrice`.\n    activationLine := drawActivation(activationPrice)\n\n// Logic for trailing stop visualization.\nif strategy.opentrades == 1\n    // Stop extending the `activationLine` when the stop activates.\n    if not isActive and high > activationLine.get_price(bar_index)\n        isActive := true\n        activationLine.stopExtend()\n    // Update the `trailingStopPrice` while the trailing stop is active.\n    if isActive\n        float offsetPrice = high - trailDistanceInput * syminfo.mintick\n        trailingStopPrice := math.max(nz(trailingStopPrice, offsetPrice), offsetPrice)\n\n// Close the trade with a market order if the trailing stop does not activate before the next 300th bar.\nif not isActive and bar_index % 300 == 0\n    strategy.close_all(\"Market close\")\n\n// Reset the `trailingStopPrice` and `isActive` flags when the trade closes, and stop extending the `activationLine`.\nif ta.change(strategy.closedtrades) > 0\n    if not isActive\n        activationLine.stopExtend()\n    trailingStopPrice := na\n    isActive          := false\n\n// Plot the `trailingStopPrice`.\nplot(trailingStopPrice, \"Trailing stop\", color.red, 3, plot.style_linebr)"
              ]
            }
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "syntax": [
            "strategy.exit(id, from_entry, qty, qty_percent, profit, limit, loss, stop, trail_price, trail_points, trail_offset, oca_name, comment, comment_profit, comment_loss, comment_trailing, alert_message, alert_profit, alert_loss, alert_trailing, disable_alert) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.cancel",
          "desc": [
            "",
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(title = \"Order cancellation demo\")\n\nconditionForBuy = open > high[1]\nif conditionForBuy\n    strategy.entry(\"Long\", strategy.long, 1, limit = low) // Enter long using limit order at low price of current bar if `conditionForBuy` is `true`.\nif not conditionForBuy\n    strategy.cancel(\"Long\") // Cancel the entry order with name \"Long\" if `conditionForBuy` is `false`."
          ],
          "syntax": [
            "strategy.cancel(id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.cancel_all",
          "desc": [
            "",
            ""
          ],
          "examples": [
            "//@version=6\nstrategy(title = \"Cancel all orders demo\")\nconditionForBuy1 = open > high[1]\nif conditionForBuy1\n    strategy.entry(\"Long entry 1\", strategy.long, 1, limit = low) // Enter long using a limit order if `conditionForBuy1` is `true`.\nconditionForBuy2 = conditionForBuy1 and open[1] > high[2]\nfloat lowest2 = ta.lowest(low, 2)\nif conditionForBuy2\n    strategy.entry(\"Long entry 2\", strategy.long, 1, limit = lowest2) // Enter long using a limit order if `conditionForBuy2` is `true`.\nconditionForStopTrading = open < lowest2\nif conditionForStopTrading\n    strategy.cancel_all() // Cancel both limit orders if `conditionForStopTrading` is `true`."
          ],
          "syntax": [
            "strategy.cancel_all() → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "ta.pivothigh",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "leftbars",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "rightbars",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"PivotHigh\", overlay=true)\nleftBars = input(2)\nrightBars=input(2)\nph = ta.pivothigh(leftBars, rightBars)\nplot(ph, style=plot.style_cross, linewidth=3, color= color.red, offset=-rightBars)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.pivothigh(leftbars, rightbars) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.pivothigh",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "leftbars",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "rightbars",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"PivotHigh\", overlay=true)\nleftBars = input(2)\nrightBars=input(2)\nph = ta.pivothigh(leftBars, rightBars)\nplot(ph, style=plot.style_cross, linewidth=3, color= color.red, offset=-rightBars)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.pivothigh(source, leftbars, rightbars) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.pivotlow",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "leftbars",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "rightbars",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"PivotLow\", overlay=true)\nleftBars = input(2)\nrightBars=input(2)\npl = ta.pivotlow(close, leftBars, rightBars)\nplot(pl, style=plot.style_cross, linewidth=3, color= color.blue, offset=-rightBars)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.pivotlow(leftbars, rightbars) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "ta.pivotlow",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "leftbars",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "rightbars",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"PivotLow\", overlay=true)\nleftBars = input(2)\nrightBars=input(2)\npl = ta.pivotlow(close, leftBars, rightBars)\nplot(pl, style=plot.style_cross, linewidth=3, color= color.blue, offset=-rightBars)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "ta.pivotlow(source, leftbars, rightbars) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.close_all",
          "desc": [
            "",
            ""
          ],
          "args": [
            {
              "name": "comment",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "alert_message",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "immediately",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "disable_alert",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"Multi-entry close strategy\")\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\n// Place a market order to enter a long trade every time `sma14` crosses over `sma28`.\nif ta.crossover(sma14, sma28)\n    strategy.order(\"My Long Entry ID \" + str.tostring(strategy.opentrades), strategy.long)\n\n// Place a market order to close the entire position every 500 bars.\nif bar_index % 500 == 0\n    strategy.close_all()\n\n// Plot the position size.\nplot(strategy.position_size)"
          ],
          "syntax": [
            "strategy.close_all(comment, alert_message, immediately, disable_alert) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.close",
          "desc": [
            "",
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "comment",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "qty",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "qty_percent",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "alert_message",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "immediately",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "disable_alert",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"Partial close strategy\")\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\n// Place a market order to enter a long position when `sma14` crosses over `sma28`.\nif ta.crossover(sma14, sma28)\n    strategy.entry(\"My Long Entry ID\", strategy.long)\n\n// Place a market order to close the long trade when `sma14` crosses under `sma28`.\nif ta.crossunder(sma14, sma28)\n    strategy.close(\"My Long Entry ID\", \"50% market close\", qty_percent = 50)\n\n// Plot the position size.\nplot(strategy.position_size)"
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "strategy.close(id, comment, qty, qty_percent, alert_message, immediately, disable_alert) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.risk.max_position_size",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "contracts",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"risk.max_position_size Demo\", default_qty_value = 100)\nstrategy.risk.max_position_size(10)\nif open > close\n\tstrategy.entry(\"buy\", strategy.long)\nplot(strategy.position_size) // max plot value will be 10"
          ],
          "syntax": [
            "strategy.risk.max_position_size(contracts) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.risk.max_intraday_loss",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "type",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "alert_message",
              "desc": "",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "// Sets the maximum intraday loss using the strategy's equity value.\n//@version=6\nstrategy(\"strategy.risk.max_intraday_loss Example 1\", overlay = false, default_qty_type = strategy.percent_of_equity, default_qty_value = 100)\n\n// Input for maximum intraday loss %.\nlossPct = input.float(10)\n\n// Set maximum intraday loss to our lossPct input\nstrategy.risk.max_intraday_loss(lossPct, strategy.percent_of_equity)\n\n// Enter Short at bar_index zero.\nif bar_index == 0\n\tstrategy.entry(\"Short\", strategy.short)\n\n// Store equity value from the beginning of the day\neqFromDayStart = ta.valuewhen(ta.change(dayofweek) > 0, strategy.equity, 0)\n\n// Calculate change of the current equity from the beginning of the current day.\neqChgPct = 100 * ((strategy.equity - eqFromDayStart) / strategy.equity)\n\n// Plot it\nplot(eqChgPct)\nhline(-lossPct)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "// Sets the maximum intraday loss using the strategy's cash value.\n//@version=6\nstrategy(\"strategy.risk.max_intraday_loss Example 2\", overlay = false)\n\n// Input for maximum intraday loss in absolute cash value of the symbol.\nabsCashLoss = input.float(5)\n\n// Set maximum intraday loss to `absCashLoss` in account currency.\nstrategy.risk.max_intraday_loss(absCashLoss, strategy.cash)\n\n// Enter Short at bar_index zero.\nif bar_index == 0\n\tstrategy.entry(\"Short\", strategy.short)\n\n// Store the open price value from the beginning of the day.\nbeginPrice = ta.valuewhen(ta.change(dayofweek) > 0, open, 0)\n\n// Calculate the absolute price change for the current period.\npriceChg = (close - beginPrice)\n\nhline(absCashLoss)\nplot(priceChg)"
              ]
            }
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)",
            "[strategy.percent_of_equity](#const_strategy.percent_of_equity)",
            "[strategy.cash](#const_strategy.cash)"
          ],
          "syntax": [
            "strategy.risk.max_intraday_loss(value, type, alert_message) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.risk.max_intraday_filled_orders",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "count",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "alert_message",
              "desc": "",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"risk.max_intraday_filled_orders Demo\")\nstrategy.risk.max_intraday_filled_orders(10) // After 10 orders are filled, no more strategy orders will be placed (except for a market order to exit current open market position, if there is any).\nif open > close\n\tstrategy.entry(\"buy\", strategy.long)\nif open < close\n\tstrategy.entry(\"sell\", strategy.short)"
          ],
          "syntax": [
            "strategy.risk.max_intraday_filled_orders(count, alert_message) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.risk.allow_entry_in",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"strategy.risk.allow_entry_in\")\n\nstrategy.risk.allow_entry_in(strategy.direction.long)\nif open > close\n\tstrategy.entry(\"Long\", strategy.long)\n// Instead of opening a short position with 10 contracts, this command will close long entries.\nif open < close\n\tstrategy.entry(\"Short\", strategy.short, qty = 10)"
          ],
          "syntax": [
            "strategy.risk.allow_entry_in(value) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.risk.max_cons_loss_days",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "count",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            },
            {
              "name": "alert_message",
              "desc": "",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"risk.max_cons_loss_days Demo 1\")\nstrategy.risk.max_cons_loss_days(3) // No orders will be placed after 3 days, if each day is with loss.\nplot(strategy.position_size)"
          ],
          "syntax": [
            "strategy.risk.max_cons_loss_days(count, alert_message) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.risk.max_drawdown",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "simple int/float"
            },
            {
              "name": "type",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            },
            {
              "name": "alert_message",
              "desc": "",
              "allowedTypeIDs": [
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "simple string"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"risk.max_drawdown Demo 1\")\nstrategy.risk.max_drawdown(50, strategy.percent_of_equity) // set maximum drawdown to 50% of maximum equity\nplot(strategy.position_size)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"risk.max_drawdown Demo 2\", currency = \"EUR\")\nstrategy.risk.max_drawdown(2000, strategy.cash) // set maximum drawdown to 2000 EUR from maximum equity\nplot(strategy.position_size)"
              ]
            }
          ],
          "syntax": [
            "strategy.risk.max_drawdown(value, type, alert_message) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.copy",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            }
          ],
          "examples": [
            "//@version=6\nindicator('Last 50 bars price ranges', overlay = true)\nLOOKBACK = 50\nhighest = ta.highest(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nif barstate.islastconfirmedhistory\n\tvar BoxLast = box.new(bar_index[LOOKBACK], highest, bar_index, lowest, bgcolor = color.new(color.green, 80))\n\tvar BoxPrev = box.copy(BoxLast)\n\tbox.set_lefttop(BoxPrev, bar_index[LOOKBACK * 2], highest[50])\n\tbox.set_rightbottom(BoxPrev, bar_index[LOOKBACK], lowest[50])\n\tbox.set_bgcolor(BoxPrev, color.new(color.red, 80))"
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.delete()](#fun_box.delete)"
          ],
          "syntax": [
            "box.copy(id) → series box"
          ],
          "returnedTypes": [
            "series box"
          ]
        },
        {
          "name": "box.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "top_left",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            },
            {
              "name": "bottom_right",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            },
            {
              "name": "border_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "border_width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "border_style",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "extend",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "xloc",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "bgcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "text",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series int/string"
            },
            {
              "name": "text_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "text_halign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_valign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_wrap",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_font_family",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "text_formatting",
              "desc": "",
              "allowedTypeIDs": [
                "const text_format"
              ],
              "displayType": "const text_format"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"box.new\")\nvar b = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)\nbox.set_lefttop(b, time, 100)\nbox.set_rightbottom(b, time + 60 * 60 * 24, 500)\nbox.set_bgcolor(b, color.green)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[box.delete()](#fun_box.delete)",
            "[box.get_left()](#fun_box.get_left)",
            "[box.get_top()](#fun_box.get_top)",
            "[box.get_right()](#fun_box.get_right)",
            "[box.get_bottom()](#fun_box.get_bottom)",
            "[box.set_top_left_point()](#fun_box.set_top_left_point)",
            "[box.set_left()](#fun_box.set_left)",
            "[box.set_top()](#fun_box.set_top)",
            "[box.set_bottom_right_point()](#fun_box.set_bottom_right_point)",
            "[box.set_right()](#fun_box.set_right)",
            "[box.set_bottom()](#fun_box.set_bottom)",
            "[box.set_border_color()](#fun_box.set_border_color)",
            "[box.set_bgcolor()](#fun_box.set_bgcolor)",
            "[box.set_border_width()](#fun_box.set_border_width)",
            "[box.set_border_style()](#fun_box.set_border_style)",
            "[box.set_extend()](#fun_box.set_extend)",
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_formatting()](#fun_box.set_text_formatting)",
            "[box.set_xloc()](#fun_box.set_xloc)"
          ],
          "syntax": [
            "box.new(top_left, bottom_right, border_color, border_width, border_style, extend, xloc, bgcolor, text, text_size, text_color, text_halign, text_valign, text_wrap, text_font_family, force_overlay, text_formatting) → series box"
          ],
          "returnedTypes": [
            "series box"
          ]
        },
        {
          "name": "box.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "left",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "top",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "right",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "bottom",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "border_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "border_width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "border_style",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "extend",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "xloc",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "bgcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "text",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series int/string"
            },
            {
              "name": "text_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "text_halign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_valign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_wrap",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_font_family",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "text_formatting",
              "desc": "",
              "allowedTypeIDs": [
                "const text_format"
              ],
              "displayType": "const text_format"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"box.new\")\nvar b = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)\nbox.set_lefttop(b, time, 100)\nbox.set_rightbottom(b, time + 60 * 60 * 24, 500)\nbox.set_bgcolor(b, color.green)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[box.delete()](#fun_box.delete)",
            "[box.get_left()](#fun_box.get_left)",
            "[box.get_top()](#fun_box.get_top)",
            "[box.get_right()](#fun_box.get_right)",
            "[box.get_bottom()](#fun_box.get_bottom)",
            "[box.set_top_left_point()](#fun_box.set_top_left_point)",
            "[box.set_left()](#fun_box.set_left)",
            "[box.set_top()](#fun_box.set_top)",
            "[box.set_bottom_right_point()](#fun_box.set_bottom_right_point)",
            "[box.set_right()](#fun_box.set_right)",
            "[box.set_bottom()](#fun_box.set_bottom)",
            "[box.set_border_color()](#fun_box.set_border_color)",
            "[box.set_bgcolor()](#fun_box.set_bgcolor)",
            "[box.set_border_width()](#fun_box.set_border_width)",
            "[box.set_border_style()](#fun_box.set_border_style)",
            "[box.set_extend()](#fun_box.set_extend)",
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_formatting()](#fun_box.set_text_formatting)",
            "[box.set_xloc()](#fun_box.set_xloc)"
          ],
          "syntax": [
            "box.new(left, top, right, bottom, border_color, border_width, border_style, extend, xloc, bgcolor, text, text_size, text_color, text_halign, text_valign, text_wrap, text_font_family, force_overlay, text_formatting) → series box"
          ],
          "returnedTypes": [
            "series box"
          ]
        },
        {
          "name": "box.delete",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)"
          ],
          "syntax": [
            "box.delete(id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.get_left",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.set_left()](#fun_box.set_left)"
          ],
          "syntax": [
            "box.get_left(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "box.get_right",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.set_right()](#fun_box.set_right)"
          ],
          "syntax": [
            "box.get_right(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "box.get_top",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.set_top()](#fun_box.set_top)"
          ],
          "syntax": [
            "box.get_top(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "box.get_bottom",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.set_bottom()](#fun_box.set_bottom)"
          ],
          "syntax": [
            "box.get_bottom(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "box.set_left",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "left",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.get_left()](#fun_box.get_left)"
          ],
          "syntax": [
            "box.set_left(id, left) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_lefttop",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "left",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "top",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.get_left()](#fun_box.get_left)",
            "[box.get_top()](#fun_box.get_top)"
          ],
          "syntax": [
            "box.set_lefttop(id, left, top) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_right",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "right",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.get_right()](#fun_box.get_right)"
          ],
          "syntax": [
            "box.set_right(id, right) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_rightbottom",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "right",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "bottom",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.get_right()](#fun_box.get_right)",
            "[box.get_bottom()](#fun_box.get_bottom)"
          ],
          "syntax": [
            "box.set_rightbottom(id, right, bottom) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_top",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "top",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.get_top()](#fun_box.get_top)"
          ],
          "syntax": [
            "box.set_top(id, top) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_bottom",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "bottom",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[box.get_bottom()](#fun_box.get_bottom)"
          ],
          "syntax": [
            "box.set_bottom(id, bottom) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_border_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)"
          ],
          "syntax": [
            "box.set_border_color(id, color) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_bgcolor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)"
          ],
          "syntax": [
            "box.set_bgcolor(id, color) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_border_width",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "width",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)"
          ],
          "syntax": [
            "box.set_border_width(id, width) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_border_style",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "style",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)"
          ],
          "syntax": [
            "box.set_border_style(id, style) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_extend",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "extend",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[extend.none](#const_extend.none)",
            "[extend.right](#const_extend.right)",
            "[extend.left](#const_extend.left)",
            "[extend.both](#const_extend.both)"
          ],
          "syntax": [
            "box.set_extend(id, extend) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_xloc",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "left",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "right",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "xloc",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[xloc.bar_index](#const_xloc.bar_index)",
            "[xloc.bar_time](#const_xloc.bar_time)"
          ],
          "syntax": [
            "box.set_xloc(id, left, right, xloc) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text_font_family",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "text_font_family",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Example of setting the box font\")\nif barstate.islastconfirmedhistory\n    b = box.new(bar_index, open-ta.tr, bar_index-50, open-ta.tr*5, text=\"monospace\")\n    box.set_text_font_family(b, font.family_monospace)"
          ],
          "seeAlso": [
            "[box.new()](#fun_box.new)",
            "[font.family_default](#const_font.family_default)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "syntax": [
            "box.set_text_font_family(id, text_font_family) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text_halign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "text_halign",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_size()](#fun_box.set_text_size)",
            "[box.set_text_valign()](#fun_box.set_text_valign)",
            "[box.set_text_color()](#fun_box.set_text_color)"
          ],
          "syntax": [
            "box.set_text_halign(id, text_halign) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text_valign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "text_valign",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_size()](#fun_box.set_text_size)",
            "[box.set_text_color()](#fun_box.set_text_color)",
            "[box.set_text_halign()](#fun_box.set_text_halign)"
          ],
          "syntax": [
            "box.set_text_valign(id, text_valign) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text_size",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "text_size",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series int/string"
            }
          ],
          "seeAlso": [
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_color()](#fun_box.set_text_color)",
            "[box.set_text_valign()](#fun_box.set_text_valign)",
            "[box.set_text_halign()](#fun_box.set_text_halign)"
          ],
          "syntax": [
            "box.set_text_size(id, text_size) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "text",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.set_text_color()](#fun_box.set_text_color)",
            "[box.set_text_size()](#fun_box.set_text_size)",
            "[box.set_text_valign()](#fun_box.set_text_valign)",
            "[box.set_text_halign()](#fun_box.set_text_halign)",
            "[box.set_text_formatting()](#fun_box.set_text_formatting)"
          ],
          "syntax": [
            "box.set_text(id, text) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text_formatting",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "text_formatting",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const text_format"
              ],
              "displayType": "const text_format"
            }
          ],
          "seeAlso": [
            "[box.set_text_color()](#fun_box.set_text_color)",
            "[box.set_text_size()](#fun_box.set_text_size)",
            "[box.set_text_valign()](#fun_box.set_text_valign)",
            "[box.set_text_halign()](#fun_box.set_text_halign)",
            "[box.set_text()](#fun_box.set_text)"
          ],
          "syntax": [
            "box.set_text_formatting(id, text_formatting) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_text_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "text_color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_size()](#fun_box.set_text_size)",
            "[box.set_text_valign()](#fun_box.set_text_valign)",
            "[box.set_text_halign()](#fun_box.set_text_halign)"
          ],
          "syntax": [
            "box.set_text_color(id, text_color) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.copy",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            }
          ],
          "examples": [
            "//@version=6\nindicator('Last 100 bars price range', overlay = true)\nLOOKBACK = 100\nhighest = ta.highest(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nif barstate.islastconfirmedhistory\n\tvar lineTop = line.new(bar_index[LOOKBACK], highest, bar_index, highest, color = color.green)\n\tvar lineBottom = line.copy(lineTop)\n\tline.set_y1(lineBottom, lowest)\n\tline.set_y2(lineBottom, lowest)\n\tline.set_color(lineBottom, color.red)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)",
            "[line.delete()](#fun_line.delete)"
          ],
          "syntax": [
            "line.copy(id) → series line"
          ],
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "name": "box.set_text_wrap",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "text_wrap",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[box.set_text()](#fun_box.set_text)",
            "[box.set_text_size()](#fun_box.set_text_size)",
            "[box.set_text_valign()](#fun_box.set_text_valign)",
            "[box.set_text_halign()](#fun_box.set_text_halign)",
            "[box.set_text_color()](#fun_box.set_text_color)"
          ],
          "syntax": [
            "box.set_text_wrap(id, text_wrap) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "y1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "x2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "y2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "xloc",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "extend",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "style",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"line.new\")\nvar line1 = line.new(0, low, bar_index, high, extend=extend.right)\nvar line2 = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, style=line.style_dashed)\nline.set_x2(line1, 0)\nline.set_xloc(line1, time, time + 60 * 60 * 24, xloc.bar_time)\nline.set_color(line2, color.green)\nline.set_width(line2, 5)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[line.delete()](#fun_line.delete)",
            "[line.set_x1()](#fun_line.set_x1)",
            "[line.set_y1()](#fun_line.set_y1)",
            "[line.set_xy1()](#fun_line.set_xy1)",
            "[line.set_x2()](#fun_line.set_x2)",
            "[line.set_y2()](#fun_line.set_y2)",
            "[line.set_xy2()](#fun_line.set_xy2)",
            "[line.set_xloc()](#fun_line.set_xloc)",
            "[line.set_color()](#fun_line.set_color)",
            "[line.set_extend()](#fun_line.set_extend)",
            "[line.set_style()](#fun_line.set_style)",
            "[line.set_width()](#fun_line.set_width)"
          ],
          "syntax": [
            "line.new(x1, y1, x2, y2, xloc, extend, color, style, width, force_overlay) → series line"
          ],
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "name": "line.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "first_point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            },
            {
              "name": "second_point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            },
            {
              "name": "xloc",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "extend",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "style",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"line.new\")\nvar line1 = line.new(0, low, bar_index, high, extend=extend.right)\nvar line2 = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, style=line.style_dashed)\nline.set_x2(line1, 0)\nline.set_xloc(line1, time, time + 60 * 60 * 24, xloc.bar_time)\nline.set_color(line2, color.green)\nline.set_width(line2, 5)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[line.delete()](#fun_line.delete)",
            "[line.set_x1()](#fun_line.set_x1)",
            "[line.set_y1()](#fun_line.set_y1)",
            "[line.set_xy1()](#fun_line.set_xy1)",
            "[line.set_x2()](#fun_line.set_x2)",
            "[line.set_y2()](#fun_line.set_y2)",
            "[line.set_xy2()](#fun_line.set_xy2)",
            "[line.set_xloc()](#fun_line.set_xloc)",
            "[line.set_color()](#fun_line.set_color)",
            "[line.set_extend()](#fun_line.set_extend)",
            "[line.set_style()](#fun_line.set_style)",
            "[line.set_width()](#fun_line.set_width)"
          ],
          "syntax": [
            "line.new(first_point, second_point, xloc, extend, color, style, width, force_overlay) → series line"
          ],
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "name": "line.set_x1",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_x1(id, x) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_y1",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_y1(id, y) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_xy1",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_xy1(id, x, y) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_x2",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_x2(id, x) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_y2",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_y2(id, y) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_xy2",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_xy2(id, x, y) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_xloc",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "x1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "x2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "xloc",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[xloc.bar_index](#const_xloc.bar_index)",
            "[xloc.bar_time](#const_xloc.bar_time)",
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_xloc(id, x1, x2, xloc) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_extend",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "extend",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[extend.none](#const_extend.none)",
            "[extend.right](#const_extend.right)",
            "[extend.left](#const_extend.left)",
            "[extend.both](#const_extend.both)",
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_extend(id, extend) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_color(id, color) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_style",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "style",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[line.style_solid](#const_line.style_solid)",
            "[line.style_dotted](#const_line.style_dotted)",
            "[line.style_dashed](#const_line.style_dashed)",
            "[line.style_arrow_left](#const_line.style_arrow_left)",
            "[line.style_arrow_right](#const_line.style_arrow_right)",
            "[line.style_arrow_both](#const_line.style_arrow_both)",
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_style(id, style) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_width",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "width",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.set_width(id, width) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.delete",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            }
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.delete(id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.get_x1",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"line.get_x1\")\nmy_line = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)\na = line.get_x1(my_line)\nplot(time - line.get_x1(my_line)) //draws zero plot"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.get_x1(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "line.get_y1",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.get_y1(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "line.get_x2",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.get_x2(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "line.get_y2",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.get_y2(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "line.get_price",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"GetPrice\", overlay=true)\nvar line l = na\nif bar_index == 10\n    l := line.new(0, high[5], bar_index, high)\nplot(line.get_price(l, bar_index), color=color.green)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[line.new()](#fun_line.new)"
          ],
          "syntax": [
            "line.get_price(id, x) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "label.copy",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            }
          ],
          "examples": [
            "//@version=6\nindicator('Last 100 bars highest/lowest', overlay = true)\nLOOKBACK = 100\nhighest = ta.highest(LOOKBACK)\nhighestBars = ta.highestbars(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nlowestBars = ta.lowestbars(LOOKBACK)\nif barstate.islastconfirmedhistory\n\tvar labelHigh = label.new(bar_index + highestBars, highest, str.tostring(highest), color = color.green)\n\tvar labelLow = label.copy(labelHigh)\n\tlabel.set_xy(labelLow, bar_index + lowestBars, lowest)\n\tlabel.set_text(labelLow, str.tostring(lowest))\n\tlabel.set_color(labelLow, color.red)\n\tlabel.set_style(labelLow, label.style_label_up)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.delete()](#fun_label.delete)"
          ],
          "syntax": [
            "label.copy(id) → series label"
          ],
          "returnedTypes": [
            "series label"
          ]
        },
        {
          "name": "linefill.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "line1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "line2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "syntax": [
            "linefill.new(line1, line2, color) → series linefill"
          ],
          "returnedTypes": [
            "series linefill"
          ]
        },
        {
          "name": "linefill.delete",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series linefill"
              ],
              "displayType": "series linefill"
            }
          ],
          "syntax": [
            "linefill.delete(id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "linefill.set_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series linefill"
              ],
              "displayType": "series linefill"
            },
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "syntax": [
            "linefill.set_color(id, color) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "linefill.get_line1",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series linefill"
              ],
              "displayType": "series linefill"
            }
          ],
          "syntax": [
            "linefill.get_line1(id) → series line"
          ],
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "name": "linefill.get_line2",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series linefill"
              ],
              "displayType": "series linefill"
            }
          ],
          "syntax": [
            "linefill.get_line2(id) → series line"
          ],
          "returnedTypes": [
            "series line"
          ]
        },
        {
          "name": "array.new_linefill",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "initial_value",
              "desc": "",
              "allowedTypeIDs": [
                "series linefill"
              ],
              "displayType": "series linefill"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "array.new_linefill(size, initial_value) → array<linefill>"
          ],
          "returnedTypes": [
            "array<linefill>"
          ]
        },
        {
          "name": "label.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            },
            {
              "name": "text",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "xloc",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "yloc",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "style",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "textcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series int/string"
            },
            {
              "name": "textalign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_font_family",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "text_formatting",
              "desc": "",
              "allowedTypeIDs": [
                "const text_format"
              ],
              "displayType": "const text_format"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"label.new\")\nvar label1 = label.new(bar_index, low, text=\"Hello, world!\", style=label.style_circle)\nlabel.set_x(label1, 0)\nlabel.set_xloc(label1, time, xloc.bar_time)\nlabel.set_color(label1, color.red)\nlabel.set_size(label1, size.large)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[label.delete()](#fun_label.delete)",
            "[label.set_x()](#fun_label.set_x)",
            "[label.set_y()](#fun_label.set_y)",
            "[label.set_xy()](#fun_label.set_xy)",
            "[label.set_xloc()](#fun_label.set_xloc)",
            "[label.set_yloc()](#fun_label.set_yloc)",
            "[label.set_color()](#fun_label.set_color)",
            "[label.set_textcolor()](#fun_label.set_textcolor)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_size()](#fun_label.set_size)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.set_tooltip()](#fun_label.set_tooltip)",
            "[label.set_text()](#fun_label.set_text)",
            "[label.set_text_formatting()](#fun_label.set_text_formatting)"
          ],
          "syntax": [
            "label.new(point, text, xloc, yloc, color, style, textcolor, size, textalign, tooltip, text_font_family, force_overlay, text_formatting) → series label"
          ],
          "returnedTypes": [
            "series label"
          ]
        },
        {
          "name": "label.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "text",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "xloc",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "yloc",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "style",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "textcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series int/string"
            },
            {
              "name": "textalign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_font_family",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "text_formatting",
              "desc": "",
              "allowedTypeIDs": [
                "const text_format"
              ],
              "displayType": "const text_format"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"label.new\")\nvar label1 = label.new(bar_index, low, text=\"Hello, world!\", style=label.style_circle)\nlabel.set_x(label1, 0)\nlabel.set_xloc(label1, time, xloc.bar_time)\nlabel.set_color(label1, color.red)\nlabel.set_size(label1, size.large)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[label.delete()](#fun_label.delete)",
            "[label.set_x()](#fun_label.set_x)",
            "[label.set_y()](#fun_label.set_y)",
            "[label.set_xy()](#fun_label.set_xy)",
            "[label.set_xloc()](#fun_label.set_xloc)",
            "[label.set_yloc()](#fun_label.set_yloc)",
            "[label.set_color()](#fun_label.set_color)",
            "[label.set_textcolor()](#fun_label.set_textcolor)",
            "[label.set_style()](#fun_label.set_style)",
            "[label.set_size()](#fun_label.set_size)",
            "[label.set_textalign()](#fun_label.set_textalign)",
            "[label.set_tooltip()](#fun_label.set_tooltip)",
            "[label.set_text()](#fun_label.set_text)",
            "[label.set_text_formatting()](#fun_label.set_text_formatting)"
          ],
          "syntax": [
            "label.new(x, y, text, xloc, yloc, color, style, textcolor, size, textalign, tooltip, text_font_family, force_overlay, text_formatting) → series label"
          ],
          "returnedTypes": [
            "series label"
          ]
        },
        {
          "name": "label.set_x",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_x(id, x) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_y",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_y(id, y) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_xy",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "y",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_xy(id, x, y) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_xloc",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "x",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "xloc",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[xloc.bar_index](#const_xloc.bar_index)",
            "[xloc.bar_time](#const_xloc.bar_time)",
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_xloc(id, x, xloc) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_yloc",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "yloc",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[yloc.price](#const_yloc.price)",
            "[yloc.abovebar](#const_yloc.abovebar)",
            "[yloc.belowbar](#const_yloc.belowbar)",
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_yloc(id, yloc) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_text",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "text",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_text_formatting()](#fun_label.set_text_formatting)"
          ],
          "syntax": [
            "label.set_text(id, text) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_text_formatting",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "text_formatting",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const text_format"
              ],
              "displayType": "const text_format"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[label.set_text()](#fun_label.set_text)"
          ],
          "syntax": [
            "label.set_text_formatting(id, text_formatting) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_text_font_family",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "text_font_family",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Example of setting the label font\")\nif barstate.islastconfirmedhistory\n    l = label.new(bar_index, 0, \"monospace\", yloc=yloc.abovebar)\n    label.set_text_font_family(l, font.family_monospace)"
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)",
            "[font.family_default](#const_font.family_default)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "syntax": [
            "label.set_text_font_family(id, text_font_family) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "color",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_color(id, color) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_style",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "style",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_style(id, style) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_textcolor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "textcolor",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_textcolor(id, textcolor) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_size",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "size",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series int/string"
            }
          ],
          "seeAlso": [
            "[size.auto](#const_size.auto)",
            "[size.tiny](#const_size.tiny)",
            "[size.small](#const_size.small)",
            "[size.normal](#const_size.normal)",
            "[size.large](#const_size.large)",
            "[size.huge](#const_size.huge)",
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_size(id, size) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_textalign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "textalign",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[text.align_left](#const_text.align_left)",
            "[text.align_center](#const_text.align_center)",
            "[text.align_right](#const_text.align_right)",
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_textalign(id, textalign) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_tooltip",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "tooltip",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.set_tooltip(id, tooltip) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.delete",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            }
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.delete(id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.get_x",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"label.get_x\")\nmy_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)\na = label.get_x(my_label)\nplot(time - label.get_x(my_label)) //draws zero plot"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.get_x(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "label.get_y",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.get_y(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "label.get_text",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"label.get_text\")\nmy_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)\na = label.get_text(my_label)\nlabel.new(time, close, text = a + \" new\", xloc=xloc.bar_time)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[label.new()](#fun_label.new)"
          ],
          "syntax": [
            "label.get_text(id) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "max_bars_back",
          "desc": [
            "",
            "",
            "",
            "",
            ""
          ],
          "args": [
            {
              "name": "var",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series color",
                "simple color",
                "input color",
                "const color",
                "series label",
                "series line"
              ],
              "displayType": "series int/float/bool/color/label/line"
            },
            {
              "name": "num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const int"
              ],
              "displayType": "const int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"max_bars_back\")\nclose_() => close\ndepth() => 400\nd = depth()\nv = close_()\nmax_bars_back(v, 500)\nout = if bar_index > 0\n\tv[d]\nelse\n\tv\nplot(out)"
          ],
          "returns": [
            "void"
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "Param 'max_bars_back' of [indicator()](#fun_indicator) and [strategy()](#fun_strategy) functions."
          ],
          "syntax": [
            "max_bars_back(var, num) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.new<type>",
          "desc": [
            ""
          ],
          "syntax": [
            "array.new<type>(size, initial_value) → array<type>"
          ],
          "args": [
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "initial_value",
              "desc": "",
              "allowedTypeIDs": [],
              "displayType": "<array_type>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.new<string> example\")\na = array.new<string>(1, \"Hello, World!\")\nlabel.new(bar_index, close, array.get(a, 0))"
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"array.new<color> example\")\na = array.new<color>()\narray.push(a, color.red)\narray.push(a, color.green)\nplot(close, color = array.get(a, close > open ? 1 : 0))"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"array.new<float> example\")\nlength = 5\nvar a = array.new<float>(length, close)\nif array.size(a) == length\n\tarray.remove(a, 0)\n\tarray.push(a, close)\nplot(array.sum(a) / length, \"SMA\")"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"array.new<line> example\")\n// draw last 15 lines\nvar a = array.new<line>()\narray.push(a, line.new(bar_index - 1, close[1], bar_index, close))\nif array.size(a) > 15\n    ln = array.shift(a)\n    line.delete(ln)"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.from()](#fun_array.from)",
            "[array.push()](#fun_array.push)",
            "[array.get()](#fun_array.get)",
            "[array.size()](#fun_array.size)",
            "[array.remove()](#fun_array.remove)",
            "[array.shift()](#fun_array.shift)",
            "[array.sum()](#fun_array.sum)"
          ],
          "template": true
        },
        {
          "name": "array.new_float",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "initial_value",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.new_float example\")\nlength = 5\na = array.new_float(length, close)\nplot(array.sum(a) / length)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_color()](#fun_array.new_color)",
            "[array.new_bool()](#fun_array.new_bool)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)",
            "[array.sort()](#fun_array.sort)"
          ],
          "syntax": [
            "array.new_float(size, initial_value) → array<float>"
          ],
          "returnedTypes": [
            "array<float>"
          ]
        },
        {
          "name": "array.new_int",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "initial_value",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.new_int example\")\nlength = 5\na = array.new_int(length, int(close))\nplot(array.sum(a) / length)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)",
            "[array.sort()](#fun_array.sort)"
          ],
          "syntax": [
            "array.new_int(size, initial_value) → array<int>"
          ],
          "returnedTypes": [
            "array<int>"
          ]
        },
        {
          "name": "array.new_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "initial_value",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.new_color example\")\nlength = 5\na = array.new_color(length, color.red)\nplot(close, color = array.get(a, 0))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)",
            "[array.sort()](#fun_array.sort)"
          ],
          "syntax": [
            "array.new_color(size, initial_value) → array<color>"
          ],
          "returnedTypes": [
            "array<color>"
          ]
        },
        {
          "name": "array.new_bool",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "initial_value",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.new_bool example\")\nlength = 5\na = array.new_bool(length, close > open)\nplot(array.get(a, 0) ? close : open)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)",
            "[array.sort()](#fun_array.sort)"
          ],
          "syntax": [
            "array.new_bool(size, initial_value) → array<bool>"
          ],
          "returnedTypes": [
            "array<bool>"
          ]
        },
        {
          "name": "array.new_string",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "initial_value",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.new_string example\")\nlength = 5\na = array.new_string(length, \"text\")\nlabel.new(bar_index, close, array.get(a, 0))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)"
          ],
          "syntax": [
            "array.new_string(size, initial_value) → array<string>"
          ],
          "returnedTypes": [
            "array<string>"
          ]
        },
        {
          "name": "array.new_line",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "initial_value",
              "desc": "",
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.new_line example\")\n// draw last 15 lines\nvar a = array.new_line()\narray.push(a, line.new(bar_index - 1, close[1], bar_index, close))\nif array.size(a) > 15\n\tln = array.shift(a)\n\tline.delete(ln)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)"
          ],
          "syntax": [
            "array.new_line(size, initial_value) → array<line>"
          ],
          "returnedTypes": [
            "array<line>"
          ]
        },
        {
          "name": "array.new_box",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "initial_value",
              "desc": "",
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.new_box example\")\nboxes = array.new_box()\narray.push(boxes, box.new(time, close, time+2, low, xloc=xloc.bar_time))\nplot(1)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)"
          ],
          "syntax": [
            "array.new_box(size, initial_value) → array<box>"
          ],
          "returnedTypes": [
            "array<box>"
          ]
        },
        {
          "name": "array.new_table",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "initial_value",
              "desc": "",
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"table array\")\ntables = array.new_table()\narray.push(tables, table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1))\nplot(1)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)"
          ],
          "syntax": [
            "array.new_table(size, initial_value) → array<table>"
          ],
          "returnedTypes": [
            "array<table>"
          ]
        },
        {
          "name": "array.new_label",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "initial_value",
              "desc": "",
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.new_label example\", overlay = true, max_labels_count = 500)\n\n//@variable The number of labels to show on the chart.\nint labelCount = input.int(50, \"Labels to show\", 1, 500)\n\n//@variable An array of `label` objects.\nvar array<label> labelArray = array.new_label()\n\n//@variable A `chart.point` for the new label.\nlabelPoint = chart.point.from_index(bar_index, close)\n//@variable The text in the new label.\nstring labelText = na\n//@variable The color of the new label.\ncolor labelColor = na\n//@variable The style of the new label.\nstring labelStyle = na\n\n// Set the label attributes for rising bars.\nif close > open\n    labelText  := \"Rising\"\n    labelColor := color.green\n    labelStyle := label.style_label_down\n// Set the label attributes for falling bars.\nelse if close < open\n    labelText  := \"Falling\"\n    labelColor := color.red\n    labelStyle := label.style_label_up\n\n// Add a new label to the `labelArray` when the chart bar closed at a new value.\nif close != open\n    labelArray.push(label.new(labelPoint, labelText, color = labelColor, style = labelStyle))\n// Remove the first element and delete its label when the size of the `labelArray` exceeds the `labelCount`.\nif labelArray.size() > labelCount\n    label.delete(labelArray.shift())"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)"
          ],
          "syntax": [
            "array.new_label(size, initial_value) → array<label>"
          ],
          "returnedTypes": [
            "array<label>"
          ]
        },
        {
          "name": "array.copy",
          "desc": [
            ""
          ],
          "syntax": [
            "array.copy(id) → array<type>"
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.copy example\")\nlength = 5\na = array.new_float(length, close)\nb = array.copy(a)\na := array.new_float(length, open)\nplot(array.sum(a) / length)\nplot(array.sum(b) / length)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)",
            "[array.sort()](#fun_array.sort)"
          ]
        },
        {
          "name": "array.slice",
          "desc": [
            ""
          ],
          "syntax": [
            "array.slice(id, index_from, index_to) → array<type>"
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            },
            {
              "name": "index_from",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "index_to",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.slice example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\n// take elements from 0 to 4\n// *note that changes in slice also modify original array\nslice = array.slice(a, 0, 5)\nplot(array.sum(a) / 10)\nplot(array.sum(slice) / 5)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)",
            "[array.sort()](#fun_array.sort)"
          ]
        },
        {
          "name": "array.size",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.size example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\n// note that changes in slice also modify original array\nslice = array.slice(a, 0, 5)\narray.push(slice, open)\n// size was changed in slice and in original array\nplot(array.size(a))\nplot(array.size(slice))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.sum()](#fun_array.sum)",
            "[array.slice()](#fun_array.slice)",
            "[array.sort()](#fun_array.sort)"
          ],
          "syntax": [
            "array.size(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.first",
          "desc": [
            ""
          ],
          "syntax": [
            "array.first(id) → series <type>"
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.first example\")\narr = array.new_int(3, 10)\nplot(array.first(arr))"
          ],
          "seeAlso": [
            "[array.last()](#fun_array.last)",
            "[array.get()](#fun_array.get)"
          ]
        },
        {
          "name": "array.last",
          "desc": [
            ""
          ],
          "syntax": [
            "array.last(id) → series <type>"
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.last example\")\narr = array.new_int(3, 10)\nplot(array.last(arr))"
          ],
          "seeAlso": [
            "[array.first()](#fun_array.first)",
            "[array.get()](#fun_array.get)"
          ]
        },
        {
          "name": "array.every",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<bool>"
              ],
              "displayType": "array<bool>"
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.some()](#fun_array.some)",
            "[array.get()](#fun_array.get)"
          ],
          "syntax": [
            "array.every(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "array.some",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<bool>"
              ],
              "displayType": "array<bool>"
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.every()](#fun_array.every)",
            "[array.get()](#fun_array.get)"
          ],
          "syntax": [
            "array.some(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "array.get",
          "desc": [
            ""
          ],
          "syntax": [
            "array.get(id, index) → series <type>"
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            },
            {
              "name": "index",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.get example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i] - open[i])\nplot(array.get(a, 9))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.slice()](#fun_array.slice)",
            "[array.sort()](#fun_array.sort)"
          ]
        },
        {
          "name": "array.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "nth",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.min\")\na = array.from(5, -2, 0, 9, 1)\nsecondLowest = array.min(a, 1) // 0\nplot(secondLowest)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.sum()](#fun_array.sum)"
          ],
          "syntax": [
            "array.min(id, nth) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            },
            {
              "name": "nth",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.min\")\na = array.from(5, -2, 0, 9, 1)\nsecondLowest = array.min(a, 1) // 0\nplot(secondLowest)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.sum()](#fun_array.sum)"
          ],
          "syntax": [
            "array.min(id, nth) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "nth",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.max\")\na = array.from(5, -2, 0, 9, 1)\nthirdHighest = array.max(a, 2) // 1\nplot(thirdHighest)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.min()](#fun_array.min)",
            "[array.sum()](#fun_array.sum)"
          ],
          "syntax": [
            "array.max(id, nth) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            },
            {
              "name": "nth",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.max\")\na = array.from(5, -2, 0, 9, 1)\nthirdHighest = array.max(a, 2) // 1\nplot(thirdHighest)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.min()](#fun_array.min)",
            "[array.sum()](#fun_array.sum)"
          ],
          "syntax": [
            "array.max(id, nth) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.range",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.range example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.range(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.min()](#fun_array.min)",
            "[array.max()](#fun_array.max)",
            "[array.sum()](#fun_array.sum)"
          ],
          "syntax": [
            "array.range(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.range",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.range example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.range(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.min()](#fun_array.min)",
            "[array.max()](#fun_array.max)",
            "[array.sum()](#fun_array.sum)"
          ],
          "syntax": [
            "array.range(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.sum",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.sum example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.sum(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)"
          ],
          "syntax": [
            "array.sum(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.sum",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.sum example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.sum(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)"
          ],
          "syntax": [
            "array.sum(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.set",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            },
            {
              "name": "index",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.set example\")\na = array.new_float(10)\nfor i = 0 to 9\n\tarray.set(a, i, close[i])\nplot(array.sum(a) / 10)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.get()](#fun_array.get)",
            "[array.slice()](#fun_array.slice)"
          ],
          "syntax": [
            "array.set(id, index, value) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.from",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "<arg..._type>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "array.from(arg0, arg1, ...) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ]
        },
        {
          "name": "array.from",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "array.from(arg0, arg1, ...) → array<int>"
          ],
          "returnedTypes": [
            "array<int>"
          ]
        },
        {
          "name": "array.from",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "array.from(arg0, arg1, ...) → array<float>"
          ],
          "returnedTypes": [
            "array<float>"
          ]
        },
        {
          "name": "array.from",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "array.from(arg0, arg1, ...) → array<bool>"
          ],
          "returnedTypes": [
            "array<bool>"
          ]
        },
        {
          "name": "array.from",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "array.from(arg0, arg1, ...) → array<string>"
          ],
          "returnedTypes": [
            "array<string>"
          ]
        },
        {
          "name": "array.from",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "array.from(arg0, arg1, ...) → array<label>"
          ],
          "returnedTypes": [
            "array<label>"
          ]
        },
        {
          "name": "array.from",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "array.from(arg0, arg1, ...) → array<line>"
          ],
          "returnedTypes": [
            "array<line>"
          ]
        },
        {
          "name": "array.from",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "array.from(arg0, arg1, ...) → array<color>"
          ],
          "returnedTypes": [
            "array<color>"
          ]
        },
        {
          "name": "array.from",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series enum"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "array.from(arg0, arg1, ...) → array<enum>"
          ],
          "returnedTypes": [
            "array<>"
          ]
        },
        {
          "name": "array.from",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "array.from(arg0, arg1, ...) → array<box>"
          ],
          "returnedTypes": [
            "array<box>"
          ]
        },
        {
          "name": "array.from",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "array.from(arg0, arg1, ...) → array<table>"
          ],
          "returnedTypes": [
            "array<table>"
          ]
        },
        {
          "name": "array.from",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series linefill"
              ],
              "displayType": "series linefill"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)"
          ],
          "remarks": [
            ""
          ],
          "returns": [
            ""
          ],
          "syntax": [
            "array.from(arg0, arg1, ...) → array<linefill>"
          ],
          "returnedTypes": [
            "array<linefill>"
          ]
        },
        {
          "name": "array.fill",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            },
            {
              "name": "index_from",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "index_to",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.fill example\")\na = array.new_float(10)\narray.fill(a, close)\nplot(array.sum(a))"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.slice()](#fun_array.slice)"
          ],
          "syntax": [
            "array.fill(id, value, index_from, index_to) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.insert",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            },
            {
              "name": "index",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.insert example\")\na = array.new_float(5, close)\narray.insert(a, 0, open)\nplot(array.get(a, 5))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.push()](#fun_array.push)",
            "[array.remove()](#fun_array.remove)",
            "[array.pop()](#fun_array.pop)",
            "[array.unshift()](#fun_array.unshift)"
          ],
          "syntax": [
            "array.insert(id, index, value) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.join",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>",
                "array<string>"
              ],
              "displayType": "array<int/float/string>"
            },
            {
              "name": "separator",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.join example\")\na = array.new_float(5, 5)\nlabel.new(bar_index, close, array.join(a, \",\"))"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.insert()](#fun_array.insert)",
            "[array.remove()](#fun_array.remove)",
            "[array.pop()](#fun_array.pop)",
            "[array.unshift()](#fun_array.unshift)"
          ],
          "syntax": [
            "array.join(id, separator) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "array.push",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.push example\")\na = array.new_float(5, 0)\narray.push(a, open)\nplot(array.get(a, 5))"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.insert()](#fun_array.insert)",
            "[array.remove()](#fun_array.remove)",
            "[array.pop()](#fun_array.pop)",
            "[array.unshift()](#fun_array.unshift)"
          ],
          "syntax": [
            "array.push(id, value) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.remove",
          "desc": [
            ""
          ],
          "syntax": [
            "array.remove(id, index) → series <type>"
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            },
            {
              "name": "index",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.remove example\")\na = array.new_float(5,high)\nremovedEl = array.remove(a, 0)\nplot(array.size(a))\nplot(removedEl)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.push()](#fun_array.push)",
            "[array.insert()](#fun_array.insert)",
            "[array.pop()](#fun_array.pop)",
            "[array.shift()](#fun_array.shift)"
          ]
        },
        {
          "name": "array.pop",
          "desc": [
            ""
          ],
          "syntax": [
            "array.pop(id) → series <type>"
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.pop example\")\na = array.new_float(5,high)\nremovedEl = array.pop(a)\nplot(array.size(a))\nplot(removedEl)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.push()](#fun_array.push)",
            "[array.remove()](#fun_array.remove)",
            "[array.insert()](#fun_array.insert)",
            "[array.shift()](#fun_array.shift)"
          ]
        },
        {
          "name": "array.clear",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.clear example\")\na = array.new_float(5,high)\narray.clear(a)\narray.push(a, close)\nplot(array.get(a,0))\nplot(array.size(a))"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.push()](#fun_array.push)",
            "[array.remove()](#fun_array.remove)",
            "[array.pop()](#fun_array.pop)"
          ],
          "syntax": [
            "array.clear(id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.sort",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>",
                "array<string>"
              ],
              "displayType": "array<int/float/string>"
            },
            {
              "name": "order",
              "desc": "",
              "allowedTypeIDs": [
                "series sort_order",
                "simple sort_order",
                "input sort_order",
                "const sort_order"
              ],
              "displayType": "series sort_order"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.sort example\")\na = array.new_float(0,0)\nfor i = 0 to 5\n\tarray.push(a, high[i])\narray.sort(a, order.descending)\nif barstate.islast\n\tlabel.new(bar_index, close, str.tostring(a))"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.sort(id, order) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.sort_indices",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>",
                "array<string>"
              ],
              "displayType": "array<int/float/string>"
            },
            {
              "name": "order",
              "desc": "",
              "allowedTypeIDs": [
                "series sort_order",
                "simple sort_order",
                "input sort_order",
                "const sort_order"
              ],
              "displayType": "series sort_order"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.sort_indices\")\na = array.from(5, -2, 0, 9, 1)\nsortedIndices = array.sort_indices(a) // [1, 2, 4, 0, 3]\nindexOfSmallestValue = array.get(sortedIndices, 0) // 1\nsmallestValue = array.get(a, indexOfSmallestValue) // -2\nplot(smallestValue)"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.sort_indices(id, order) → array<int>"
          ],
          "returnedTypes": [
            "array<int>"
          ]
        },
        {
          "name": "array.percentrank",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "index",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.percentrank(id, index) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.percentrank",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            },
            {
              "name": "index",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.percentrank(id, index) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.percentile_nearest_rank",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "percentage",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.percentile_nearest_rank(id, percentage) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.percentile_nearest_rank",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            },
            {
              "name": "percentage",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.percentile_nearest_rank(id, percentage) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.percentile_linear_interpolation",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "percentage",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.percentile_linear_interpolation(id, percentage) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.percentile_linear_interpolation",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            },
            {
              "name": "percentage",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.percentile_linear_interpolation(id, percentage) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.abs",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            }
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.abs(id) → array<float>"
          ],
          "returnedTypes": [
            "array<float>"
          ]
        },
        {
          "name": "array.abs",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            }
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.abs(id) → array<int>"
          ],
          "returnedTypes": [
            "array<int>"
          ]
        },
        {
          "name": "array.binary_search",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "val",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.binary_search\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search(a, 0) // 1\nplot(position)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.binary_search(id, val) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.binary_search_leftmost",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "val",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"array.binary_search_leftmost\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search_leftmost(a, 3) // 2\nplot(position)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"array.binary_search_leftmost, repetitive elements\")\na = array.from(4, 5, 5, 5)\n// Returns the index of the first instance.\nposition = array.binary_search_leftmost(a, 5)\nplot(position) // Plots 1"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.binary_search_leftmost(id, val) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.binary_search_rightmost",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "val",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"array.binary_search_rightmost\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search_rightmost(a, 3) // 3\nplot(position)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"array.binary_search_rightmost, repetitive elements\")\na = array.from(4, 5, 5, 5)\n// Returns the index of the last instance.\nposition = array.binary_search_rightmost(a, 5)\nplot(position) // Plots 3"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)",
            "[array.reverse()](#fun_array.reverse)",
            "[order.ascending](#const_order.ascending)",
            "[order.descending](#const_order.descending)"
          ],
          "syntax": [
            "array.binary_search_rightmost(id, val) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.concat",
          "desc": [
            ""
          ],
          "syntax": [
            "array.concat(id1, id2) → array<type>"
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.concat example\")\na = array.new_float(0,0)\nb = array.new_float(0,0)\nfor i = 0 to 4\n    array.push(a, high[i])\n    array.push(b, low[i])\nc = array.concat(a,b)\nplot(array.size(a))\nplot(array.size(b))\nplot(array.size(c))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.insert()](#fun_array.insert)",
            "[array.slice()](#fun_array.slice)"
          ]
        },
        {
          "name": "array.avg",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.avg example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.avg(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)",
            "[array.stdev()](#fun_array.stdev)"
          ],
          "syntax": [
            "array.avg(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.avg",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.avg example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.avg(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)",
            "[array.stdev()](#fun_array.stdev)"
          ],
          "syntax": [
            "array.avg(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.stdev",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "biased",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.stdev example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.stdev(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)",
            "[array.avg()](#fun_array.avg)"
          ],
          "syntax": [
            "array.stdev(id, biased) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.stdev",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            },
            {
              "name": "biased",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.stdev example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.stdev(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)",
            "[array.avg()](#fun_array.avg)"
          ],
          "syntax": [
            "array.stdev(id, biased) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.variance",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "biased",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.variance example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.variance(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.stdev()](#fun_array.stdev)",
            "[array.min()](#fun_array.min)",
            "[array.avg()](#fun_array.avg)",
            "[array.covariance()](#fun_array.covariance)"
          ],
          "syntax": [
            "array.variance(id, biased) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.variance",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            },
            {
              "name": "biased",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.variance example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.variance(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.stdev()](#fun_array.stdev)",
            "[array.min()](#fun_array.min)",
            "[array.avg()](#fun_array.avg)",
            "[array.covariance()](#fun_array.covariance)"
          ],
          "syntax": [
            "array.variance(id, biased) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.covariance",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            },
            {
              "name": "biased",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.covariance example\")\na = array.new_float(0)\nb = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\n\tarray.push(b, open[i])\nplot(array.covariance(a, b))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.max()](#fun_array.max)",
            "[array.stdev()](#fun_array.stdev)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)"
          ],
          "syntax": [
            "array.covariance(id1, id2, biased) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.mode",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.mode example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.mode(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[ta.mode()](#fun_ta.mode)",
            "[matrix.mode()](#fun_matrix.mode)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)",
            "[array.min()](#fun_array.min)"
          ],
          "syntax": [
            "array.mode(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.mode",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.mode example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.mode(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[ta.mode()](#fun_ta.mode)",
            "[matrix.mode()](#fun_matrix.mode)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)",
            "[array.min()](#fun_array.min)"
          ],
          "syntax": [
            "array.mode(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.median",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.median example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.median(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.median()](#fun_array.median)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)",
            "[array.min()](#fun_array.min)"
          ],
          "syntax": [
            "array.median(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "array.median",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.median example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.median(a))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[array.median()](#fun_array.median)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)",
            "[array.min()](#fun_array.min)"
          ],
          "syntax": [
            "array.median(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.standardize",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.standardize example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nb = array.standardize(a)\nplot(array.min(b))\nplot(array.max(b))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)",
            "[array.mode()](#fun_array.mode)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)",
            "[array.stdev()](#fun_array.stdev)"
          ],
          "syntax": [
            "array.standardize(id) → array<float>"
          ],
          "returnedTypes": [
            "array<float>"
          ]
        },
        {
          "name": "array.standardize",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.standardize example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nb = array.standardize(a)\nplot(array.min(b))\nplot(array.max(b))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.max()](#fun_array.max)",
            "[array.min()](#fun_array.min)",
            "[array.mode()](#fun_array.mode)",
            "[array.avg()](#fun_array.avg)",
            "[array.variance()](#fun_array.variance)",
            "[array.stdev()](#fun_array.stdev)"
          ],
          "syntax": [
            "array.standardize(id) → array<int>"
          ],
          "returnedTypes": [
            "array<int>"
          ]
        },
        {
          "name": "array.indexof",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.indexof example\")\na = array.new_float(5,high)\nindex = array.indexof(a, high)\nplot(index)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.lastindexof()](#fun_array.lastindexof)",
            "[array.get()](#fun_array.get)",
            "[array.lastindexof()](#fun_array.lastindexof)",
            "[array.remove()](#fun_array.remove)",
            "[array.insert()](#fun_array.insert)"
          ],
          "syntax": [
            "array.indexof(id, value) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.lastindexof",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.lastindexof example\")\na = array.new_float(5,high)\nindex = array.lastindexof(a, high)\nplot(index)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.set()](#fun_array.set)",
            "[array.push()](#fun_array.push)",
            "[array.remove()](#fun_array.remove)",
            "[array.insert()](#fun_array.insert)"
          ],
          "syntax": [
            "array.lastindexof(id, value) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "array.includes",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.includes example\")\na = array.new_float(5,high)\np = close\nif array.includes(a, high)\n\tp := open\nplot(p)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.indexof()](#fun_array.indexof)",
            "[array.shift()](#fun_array.shift)",
            "[array.remove()](#fun_array.remove)",
            "[array.insert()](#fun_array.insert)"
          ],
          "syntax": [
            "array.includes(id, value) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "array.shift",
          "desc": [
            ""
          ],
          "syntax": [
            "array.shift(id) → series <type>"
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.shift example\")\na = array.new_float(5,high)\nremovedEl = array.shift(a)\nplot(array.size(a))\nplot(removedEl)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[array.unshift()](#fun_array.unshift)",
            "[array.set()](#fun_array.set)",
            "[array.push()](#fun_array.push)",
            "[array.remove()](#fun_array.remove)",
            "[array.includes()](#fun_array.includes)"
          ]
        },
        {
          "name": "array.unshift",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the array's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.unshift example\")\na = array.new_float(5, 0)\narray.unshift(a, open)\nplot(array.get(a, 0))"
          ],
          "seeAlso": [
            "[array.shift()](#fun_array.shift)",
            "[array.set()](#fun_array.set)",
            "[array.insert()](#fun_array.insert)",
            "[array.remove()](#fun_array.remove)",
            "[array.indexof()](#fun_array.indexof)"
          ],
          "syntax": [
            "array.unshift(id, value) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "array.reverse",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"array.reverse example\")\na = array.new_float(0)\nfor i = 0 to 9\n\tarray.push(a, close[i])\nplot(array.get(a, 0))\narray.reverse(a)\nplot(array.get(a, 0))"
          ],
          "seeAlso": [
            "[array.new_float()](#fun_array.new_float)",
            "[array.sort()](#fun_array.sort)",
            "[array.push()](#fun_array.push)",
            "[array.set()](#fun_array.set)",
            "[array.avg()](#fun_array.avg)"
          ],
          "syntax": [
            "array.reverse(id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "alert",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "message",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "freq",
              "desc": "",
              "allowedTypeIDs": [
                "input string",
                "const string"
              ],
              "displayType": "input string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`alert()` example\", \"\", true)\nma = ta.sma(close, 14)\nxUp = ta.crossover(close, ma)\nif xUp\n    // Trigger the alert the first time a cross occurs during the real-time bar.\n    alert(\"Price (\" + str.tostring(close) + \") crossed over MA (\" + str.tostring(ma) + \").\", alert.freq_once_per_bar)\nplot(ma)\nplotchar(xUp, \"xUp\", \"▲\", location.top, size = size.tiny)"
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[alertcondition()](#fun_alertcondition)"
          ],
          "syntax": [
            "alert(message, freq) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "request.earnings",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "ticker",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "field",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "gaps",
              "desc": "",
              "allowedTypeIDs": [
                "simple barmerge_gaps",
                "input barmerge_gaps",
                "const barmerge_gaps"
              ],
              "displayType": "simple barmerge_gaps"
            },
            {
              "name": "lookahead",
              "desc": "",
              "allowedTypeIDs": [
                "simple barmerge_lookahead",
                "input barmerge_lookahead",
                "const barmerge_lookahead"
              ],
              "displayType": "simple barmerge_lookahead"
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "currency",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"request.earnings\")\ns1 = request.earnings(\"NASDAQ:BELFA\")\nplot(s1)\ns2 = request.earnings(\"NASDAQ:BELFA\", earnings.actual, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)\nplot(s2)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[request.dividends()](#fun_request.dividends)",
            "[request.splits()](#fun_request.splits)",
            "[request.security()](#fun_request.security)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ],
          "syntax": [
            "request.earnings(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "request.dividends",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "ticker",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "field",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "gaps",
              "desc": "",
              "allowedTypeIDs": [
                "simple barmerge_gaps",
                "input barmerge_gaps",
                "const barmerge_gaps"
              ],
              "displayType": "simple barmerge_gaps"
            },
            {
              "name": "lookahead",
              "desc": "",
              "allowedTypeIDs": [
                "simple barmerge_lookahead",
                "input barmerge_lookahead",
                "const barmerge_lookahead"
              ],
              "displayType": "simple barmerge_lookahead"
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "currency",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"request.dividends\")\ns1 = request.dividends(\"NASDAQ:BELFA\")\nplot(s1)\ns2 = request.dividends(\"NASDAQ:BELFA\", dividends.net, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)\nplot(s2)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[request.earnings()](#fun_request.earnings)",
            "[request.splits()](#fun_request.splits)",
            "[request.security()](#fun_request.security)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ],
          "syntax": [
            "request.dividends(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "request.splits",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "ticker",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "field",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "gaps",
              "desc": "",
              "allowedTypeIDs": [
                "simple barmerge_gaps",
                "input barmerge_gaps",
                "const barmerge_gaps"
              ],
              "displayType": "simple barmerge_gaps"
            },
            {
              "name": "lookahead",
              "desc": "",
              "allowedTypeIDs": [
                "simple barmerge_lookahead",
                "input barmerge_lookahead",
                "const barmerge_lookahead"
              ],
              "displayType": "simple barmerge_lookahead"
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"request.splits\")\ns1 = request.splits(\"NASDAQ:BELFA\", splits.denominator)\nplot(s1)\ns2 = request.splits(\"NASDAQ:BELFA\", splits.denominator, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)\nplot(s2)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[request.earnings()](#fun_request.earnings)",
            "[request.dividends()](#fun_request.dividends)",
            "[request.security()](#fun_request.security)",
            "[syminfo.tickerid](#var_syminfo.tickerid)"
          ],
          "syntax": [
            "request.splits(ticker, field, gaps, lookahead, ignore_invalid_symbol) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "request.economic",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "country_code",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "field",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "gaps",
              "desc": "",
              "allowedTypeIDs": [
                "simple barmerge_gaps",
                "input barmerge_gaps",
                "const barmerge_gaps"
              ],
              "displayType": "simple barmerge_gaps"
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"US GDP\")\ne = request.economic(\"US\", \"GDP\")\nplot(e)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[request.financial()](#fun_request.financial)"
          ],
          "syntax": [
            "request.economic(country_code, field, gaps, ignore_invalid_symbol) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "request.seed",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "source",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "symbol",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "expression",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "<arg_expr_type>"
            },
            {
              "name": "ignore_invalid_symbol",
              "desc": "",
              "allowedTypeIDs": [
                "input bool",
                "const bool"
              ],
              "displayType": "input bool"
            },
            {
              "name": "calc_bars_count",
              "desc": "",
              "allowedTypeIDs": [
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "simple int"
            }
          ],
          "returns": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"BTC Development Activity\")\n\n[devAct, devActSMA] = request.seed(\"seed_crypto_santiment\", \"BTC_DEV_ACTIVITY\", [close, ta.sma(close, 10)])\n\nplot(devAct, \"BTC Development Activity\")\nplot(devActSMA, \"BTC Development Activity SMA10\", color = color.yellow)"
          ],
          "syntax": [
            "request.seed(source, symbol, expression, ignore_invalid_symbol, calc_bars_count) → series <type>"
          ]
        },
        {
          "name": "table.new",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "position",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "columns",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "rows",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "bgcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "frame_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "frame_width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "border_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "border_width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"table.new example\")\nvar testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)\nif barstate.islast\n    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))\n    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[table.cell()](#fun_table.cell)",
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.set_bgcolor()](#fun_table.set_bgcolor)",
            "[table.set_border_color()](#fun_table.set_border_color)",
            "[table.set_border_width()](#fun_table.set_border_width)",
            "[table.set_frame_color()](#fun_table.set_frame_color)",
            "[table.set_frame_width()](#fun_table.set_frame_width)",
            "[table.set_position()](#fun_table.set_position)"
          ],
          "syntax": [
            "table.new(position, columns, rows, bgcolor, frame_color, frame_width, border_color, border_width, force_overlay) → series table"
          ],
          "returnedTypes": [
            "series table"
          ]
        },
        {
          "name": "table.delete",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"table.delete example\")\nvar testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)\nif barstate.islast\n    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))\n    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)\nif barstate.isrealtime\n    table.delete(testTable)"
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[table.clear()](#fun_table.clear)"
          ],
          "syntax": [
            "table.delete(table_id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.set_position",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "position",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)",
            "[table.set_bgcolor()](#fun_table.set_bgcolor)",
            "[table.set_border_color()](#fun_table.set_border_color)",
            "[table.set_border_width()](#fun_table.set_border_width)",
            "[table.set_frame_color()](#fun_table.set_frame_color)",
            "[table.set_frame_width()](#fun_table.set_frame_width)"
          ],
          "syntax": [
            "table.set_position(table_id, position) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.set_bgcolor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "bgcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)",
            "[table.set_border_color()](#fun_table.set_border_color)",
            "[table.set_border_width()](#fun_table.set_border_width)",
            "[table.set_frame_color()](#fun_table.set_frame_color)",
            "[table.set_frame_width()](#fun_table.set_frame_width)",
            "[table.set_position()](#fun_table.set_position)"
          ],
          "syntax": [
            "table.set_bgcolor(table_id, bgcolor) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.set_frame_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "frame_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)",
            "[table.set_border_color()](#fun_table.set_border_color)",
            "[table.set_border_width()](#fun_table.set_border_width)",
            "[table.set_bgcolor()](#fun_table.set_bgcolor)",
            "[table.set_frame_width()](#fun_table.set_frame_width)",
            "[table.set_position()](#fun_table.set_position)"
          ],
          "syntax": [
            "table.set_frame_color(table_id, frame_color) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.set_border_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "border_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)",
            "[table.set_frame_color()](#fun_table.set_frame_color)",
            "[table.set_border_width()](#fun_table.set_border_width)",
            "[table.set_bgcolor()](#fun_table.set_bgcolor)",
            "[table.set_frame_width()](#fun_table.set_frame_width)",
            "[table.set_position()](#fun_table.set_position)"
          ],
          "syntax": [
            "table.set_border_color(table_id, border_color) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.set_frame_width",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "frame_width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)",
            "[table.set_frame_color()](#fun_table.set_frame_color)",
            "[table.set_border_width()](#fun_table.set_border_width)",
            "[table.set_bgcolor()](#fun_table.set_bgcolor)",
            "[table.set_border_color()](#fun_table.set_border_color)",
            "[table.set_position()](#fun_table.set_position)"
          ],
          "syntax": [
            "table.set_frame_width(table_id, frame_width) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.set_border_width",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "border_width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[table.clear()](#fun_table.clear)",
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)",
            "[table.set_frame_color()](#fun_table.set_frame_color)",
            "[table.set_frame_width()](#fun_table.set_frame_width)",
            "[table.set_bgcolor()](#fun_table.set_bgcolor)",
            "[table.set_border_color()](#fun_table.set_border_color)",
            "[table.set_position()](#fun_table.set_position)"
          ],
          "syntax": [
            "table.set_border_width(table_id, border_width) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "height",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            },
            {
              "name": "text_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "text_halign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_valign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series int/string"
            },
            {
              "name": "bgcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_font_family",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "text_formatting",
              "desc": "",
              "allowedTypeIDs": [
                "const text_format"
              ],
              "displayType": "const text_format"
            }
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_formatting()](#fun_table.cell_set_text_formatting)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell(table_id, column, row, text, width, height, text_color, text_halign, text_valign, text_size, bgcolor, tooltip, text_font_family, text_formatting) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"TABLE example\")\nvar tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)\ntable.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)\ntable.cell_set_text(tLog, row = 0, column = 0, text = \"sometext\")"
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)",
            "[table.cell_set_text_formatting()](#fun_table.cell_set_text_formatting)"
          ],
          "syntax": [
            "table.cell_set_text(table_id, column, row, text) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text_formatting",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text_formatting",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const text_format"
              ],
              "displayType": "const text_format"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)",
            "[table.cell_set_text()](#fun_table.cell_set_text)"
          ],
          "syntax": [
            "table.cell_set_text_formatting(table_id, column, row, text_formatting) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text_font_family",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text_font_family",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Example of setting the table cell font\")\nvar t = table.new(position.top_left, rows = 1, columns = 1)\ntable.cell(t, 0, 0, \"monospace\", text_color = color.blue)\ntable.cell_set_text_font_family(t, 0, 0, font.family_monospace)"
          ],
          "seeAlso": [
            "[table.new()](#fun_table.new)",
            "[font.family_default](#const_font.family_default)",
            "[font.family_monospace](#const_font.family_monospace)"
          ],
          "syntax": [
            "table.cell_set_text_font_family(table_id, column, row, text_font_family) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_tooltip",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "tooltip",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"TABLE example\")\nvar tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)\ntable.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)\ntable.cell_set_tooltip(tLog, row = 0, column = 0, tooltip = \"sometext\")"
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_text()](#fun_table.cell_set_text)"
          ],
          "syntax": [
            "table.cell_set_tooltip(table_id, column, row, tooltip) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_width",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_width(table_id, column, row, width) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_height",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "height",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_height(table_id, column, row, height) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text_color",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_text_color(table_id, column, row, text_color) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text_halign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text_halign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_text_halign(table_id, column, row, text_halign) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text_valign",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text_valign",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_text_valign(table_id, column, row, text_valign) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_text_size",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "text_size",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series int/string"
            }
          ],
          "seeAlso": [
            "[table.cell_set_bgcolor()](#fun_table.cell_set_bgcolor)",
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_text_size(table_id, column, row, text_size) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.cell_set_bgcolor",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "bgcolor",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            }
          ],
          "seeAlso": [
            "[table.cell_set_height()](#fun_table.cell_set_height)",
            "[table.cell_set_text()](#fun_table.cell_set_text)",
            "[table.cell_set_text_color()](#fun_table.cell_set_text_color)",
            "[table.cell_set_text_halign()](#fun_table.cell_set_text_halign)",
            "[table.cell_set_text_size()](#fun_table.cell_set_text_size)",
            "[table.cell_set_text_valign()](#fun_table.cell_set_text_valign)",
            "[table.cell_set_width()](#fun_table.cell_set_width)",
            "[table.cell_set_tooltip()](#fun_table.cell_set_tooltip)"
          ],
          "syntax": [
            "table.cell_set_bgcolor(table_id, column, row, bgcolor) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "table.clear",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "start_column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "start_row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "end_column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "end_row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"A donut\", overlay=true)\nif barstate.islast\n    colNum = 8, rowNum = 8\n    padding = \"◯\"\n    donutTable = table.new(position.middle_right, colNum, rowNum)\n    for c = 0 to colNum - 1\n        for r = 0 to rowNum - 1\n            table.cell(donutTable, c, r, text=padding, bgcolor=#face6e, text_color=color.new(color.black, 100))\n    table.clear(donutTable, 2, 2, 5, 5)"
          ],
          "seeAlso": [
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)"
          ],
          "syntax": [
            "table.clear(table_id, start_column, start_row, end_column, end_row) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.new<type>",
          "desc": [
            ""
          ],
          "syntax": [
            "matrix.new<type>(rows, columns, initial_value) → matrix<type>"
          ],
          "args": [
            {
              "name": "rows",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "columns",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "initial_value",
              "desc": "",
              "allowedTypeIDs": [],
              "displayType": "<matrix_type>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.new<type>()` Example 1\")\n\n// Create a 2x3 (2 rows x 3 columns) \"int\" matrix with values zero.\nvar m = matrix.new<int>(2, 3, 0)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.new<type>()` Example 2\")\n\n// Function to create a matrix whose rows are filled with array values.\nmatrixFromArray(int rows, int columns, array<float> data) =>\n\tm = matrix.new<float>(rows, columns)\n\tfor i = 0 to rows <= 0 ? na : rows - 1\n\t\tfor j = 0 to columns <= 0 ? na : columns - 1\n\t\t\tmatrix.set(m, i, j, array.get(data, i * columns + j))\n\tm\n\n// Create a 3x3 matrix from an array of values.\nvar m1 = matrixFromArray(3, 3, array.from(1, 2, 3, 4, 5, 6, 7, 8, 9))\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m1))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.new<type>()` Example 3\")\n\n// Function to create a matrix from a text string.\n// Values in a row must be separated by a space. Each line is one row.\nmatrixFromInputArea(stringOfValues) =>\n\tvar rowsArray = str.split(stringOfValues, \"\\n\")\n\tvar rows = array.size(rowsArray)\n\tvar cols = array.size(str.split(array.get(rowsArray, 0), \" \"))\n\tvar matrix = matrix.new<float>(rows, cols, na)\n\trow = 0\n\tfor rowString in rowsArray\n\t\tcol = 0\n\t\tvalues = str.split(rowString, \" \")\n\t\tfor val in values\n\t\t\tmatrix.set(matrix, row, col, str.tonumber(val))\n\t\t\tcol += 1\n\t\trow += 1\n\tmatrix\n\n\nstringInput = input.text_area(\"1 2 3\\n4 5 6\\n7 8 9\")\nvar m = matrixFromInputArea(stringInput)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.new<type>()` Example 4\")\n\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n\tresult = matrix.new<float>(rows, columns)\n\tfor i = 0 to rows - 1\n\t\tfor j = 0 to columns - 1\n\t\t\tmatrix.set(result, i, j, math.random())\n\tresult\n\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.fill()](#fun_matrix.fill)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)",
            "[array.new<type>()](#fun_array.new<type>)"
          ],
          "template": true
        },
        {
          "name": "matrix.row",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.row()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from `hlc3` values.\nm = matrix.new<float>(2, 3, hlc3)\n\n// Return an array with the values of the first row of the matrix.\na = matrix.row(m, 0)\n\n// Plot the first value from the array `a`.\nplot(array.get(a, 0))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[array.get()](#fun_array.get)",
            "[matrix.col()](#fun_matrix.col)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.row(id, row) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ]
        },
        {
          "name": "matrix.col",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.col()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from `hlc3` values.\nm = matrix.new<float>(2, 3, hlc3)\n\n// Return an array with the values of the first column of matrix `m`.\na = matrix.col(m, 0)\n\n// Plot the first value from the array `a`.\nplot(array.get(a, 0))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[array.get()](#fun_array.get)",
            "[matrix.col()](#fun_matrix.col)",
            "[matrix.columns()](#fun_matrix.columns)"
          ],
          "syntax": [
            "matrix.col(id, column) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ]
        },
        {
          "name": "matrix.reshape",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "rows",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "columns",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.reshape()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix.\n\tvar m1 = matrix.new<float>(2, 3)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 0, 2, 3)\n\tmatrix.set(m1, 1, 0, 4)\n\tmatrix.set(m1, 1, 1, 5)\n\tmatrix.set(m1, 1, 2, 6)\n\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\n\t// Reshape the copy to a 3x2.\n\tmatrix.reshape(m2, 3, 2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Reshaped matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.add_row()](#fun_matrix.add_row)",
            "[matrix.add_col()](#fun_matrix.add_col)"
          ],
          "syntax": [
            "matrix.reshape(id, rows, columns) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.get",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.get()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from the `hl2` values.\nm = matrix.new<float>(2, 3, hl2)\n\n// Return the value of the element at index [0, 0] of matrix `m`.\nx = matrix.get(m, 0, 0)\n\nplot(x)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.get(id, row, column) → <matrix_type>"
          ],
          "returnedTypes": []
        },
        {
          "name": "matrix.set",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the matrix's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.set()` Example\")\n\n// Create a 2x3 \"int\" matrix containing values `4`.\nm = matrix.new<int>(2, 3, 4)\n\n// Replace the value of element at row 1 and column 2 with value `3`.\nmatrix.set(m, 0, 1, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))"
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.set(id, row, column, value) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.add_row",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "array_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.add_row()` Example 1\")\n\n// Create a 2x3 \"int\" matrix containing values `0`.\nm = matrix.new<int>(2, 3, 0)\n\n// Add a row with `na` values to the matrix.\nmatrix.add_row(m)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.add_row()` Example 2\")\n\nif barstate.islastconfirmedhistory\n\t// Create an empty matrix object.\n\tvar m = matrix.new<int>()\n\n\t// Create an array with values `1` and `2`.\n\tvar a = array.from(1, 2)\n\n\t// Add the `a` array as the first row of the empty matrix.\n\tmatrix.add_row(m, 0, a)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)",
            "[matrix.add_col()](#fun_matrix.add_col)"
          ],
          "syntax": [
            "matrix.add_row(id, row, array_id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.add_col",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "array_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<>"
              ],
              "displayType": "any array type"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.add_col()` Example 1\")\n\n// Create a 2x3 \"int\" matrix containing values `0`.\nm = matrix.new<int>(2, 3, 0)\n\n// Add a column with `na` values to the matrix.\nmatrix.add_col(m)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.add_col()` Example 2\")\n\nif barstate.islastconfirmedhistory\n\t// Create an empty matrix object.\n\tvar m = matrix.new<int>()\n\n\t// Create an array with values `1` and `3`.\n\tvar a = array.from(1, 3)\n\n\t// Add the `a` array as the first column of the empty matrix.\n\tmatrix.add_col(m, 0, a)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m))"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)",
            "[matrix.add_row()](#fun_matrix.add_row)"
          ],
          "syntax": [
            "matrix.add_col(id, column, array_id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.remove_row",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"matrix_remove_row\", overlay = true)\n\n// Create a 2x2 \"int\" matrix containing values `1`.\nvar matrixOrig = matrix.new<int>(2, 2, 1)\n\n// Set values to the 'matrixOrig' matrix.\nmatrix.set(matrixOrig, 0, 1, 2)\nmatrix.set(matrixOrig, 1, 0, 3)\nmatrix.set(matrixOrig, 1, 1, 4)\n\n// Create a copy of the 'matrixOrig' matrix.\nmatrixCopy = matrix.copy(matrixOrig)\n\n// Remove the first row from the matrix `matrixCopy`.\narr = matrix.remove_row(matrixCopy, 0)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 3, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(matrixOrig))\n\ttable.cell(t, 1, 0, \"Removed Elements:\")\n\ttable.cell(t, 1, 1, str.tostring(arr))\n\ttable.cell(t, 2, 0, \"Result Matrix:\")\n\ttable.cell(t, 2, 1, str.tostring(matrixCopy))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.copy()](#fun_matrix.copy)",
            "[matrix.remove_col()](#fun_matrix.remove_col)"
          ],
          "syntax": [
            "matrix.remove_row(id, row) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ]
        },
        {
          "name": "matrix.remove_col",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"matrix_remove_col\", overlay = true)\n\n// Create a 2x2 matrix with ones.\nvar matrixOrig = matrix.new<int>(2, 2, 1)\n\n// Set values to the 'matrixOrig' matrix.\nmatrix.set(matrixOrig, 0, 1, 2)\nmatrix.set(matrixOrig, 1, 0, 3)\nmatrix.set(matrixOrig, 1, 1, 4)\n\n\n// Create a copy of the 'matrixOrig' matrix.\nmatrixCopy = matrix.copy(matrixOrig)\n\n// Remove the first column from the `matrixCopy` matrix.\narr = matrix.remove_col(matrixCopy, 0)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 3, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(matrixOrig))\n\ttable.cell(t, 1, 0, \"Removed Elements:\")\n\ttable.cell(t, 1, 1, str.tostring(arr))\n\ttable.cell(t, 2, 0, \"Result Matrix:\")\n\ttable.cell(t, 2, 1, str.tostring(matrixCopy))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.copy()](#fun_matrix.copy)",
            "[matrix.remove_row()](#fun_matrix.remove_row)"
          ],
          "syntax": [
            "matrix.remove_col(id, column) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ]
        },
        {
          "name": "matrix.fill",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the matrix's elements>"
            },
            {
              "name": "from_row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "to_row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "from_column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "to_column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.fill()` Example\")\n\n// Create a 4x5 \"int\" matrix containing values `0`.\nm = matrix.new<float>(4, 5, 0)\n\n// Fill the intersection of rows 1 to 2 and columns 2 to 3 of the matrix with `hl2` values.\nmatrix.fill(m, hl2, 0, 2, 1, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, str.tostring(m))"
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.fill(id, value, from_row, to_row, from_column, to_column) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.submatrix",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "from_row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "to_row",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "from_column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "to_column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.submatrix()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix matrix with values `0`.\n\tvar m1 = matrix.new<int>(2, 3, 0)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 0, 2, 3)\n\tmatrix.set(m1, 1, 0, 4)\n\tmatrix.set(m1, 1, 1, 5)\n\tmatrix.set(m1, 1, 2, 6)\n\n\t// Create a 2x2 submatrix of the `m1` matrix.\n\tvar m2 = matrix.submatrix(m1, 0, 2, 1, 3)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Submatrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.row()](#fun_matrix.row)",
            "[matrix.col()](#fun_matrix.col)",
            "[matrix.reshape()](#fun_matrix.reshape)"
          ],
          "syntax": [
            "matrix.submatrix(id, from_row, to_row, from_column, to_column) → matrix<type>"
          ],
          "returnedTypes": [
            "matrix<>"
          ]
        },
        {
          "name": "matrix.copy",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.copy()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 \"float\" matrix with `1` values.\n\tvar m1 = matrix.new<float>(2, 3, 1)\n\n\t// Copy the matrix to a new one.\n\t// Note that unlike what `matrix.copy()` does,\n\t// the simple assignment operation `m2 = m1`\n\t// would NOT create a new copy of the `m1` matrix.\n\t// It would merely create a copy of its ID referencing the same matrix.\n\tvar m2 = matrix.copy(m1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix Copy:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.copy(id) → matrix<type>"
          ],
          "returnedTypes": [
            "matrix<>"
          ]
        },
        {
          "name": "matrix.columns",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.columns()` Example\")\n\n// Create a 2x6 matrix with values `0`.\nvar m = matrix.new<int>(2, 6, 0)\n\n// Get the quantity of columns in matrix `m`.\nvar x = matrix.columns(m)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, \"Columns: \" + str.tostring(x) + \"\\n\" + str.tostring(m))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.col()](#fun_matrix.col)",
            "[matrix.row()](#fun_matrix.row)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.columns(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "matrix.rows",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.rows()` Example\")\n\n// Create a 2x6 matrix with values `0`.\nvar m = matrix.new<int>(2, 6, 0)\n\n// Get the quantity of rows in the matrix.\nvar x = matrix.rows(m)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n\tlabel.new(bar_index, high, \"Rows: \" + str.tostring(x) + \"\\n\" + str.tostring(m))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.row()](#fun_matrix.row)"
          ],
          "syntax": [
            "matrix.rows(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "matrix.elements_count",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            }
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.elements_count(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "matrix.concat",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.concat()` Example\")\n\n// Create a 2x4 \"int\" matrix containing values `0`.\nm1 = matrix.new<int>(2, 4, 0)\n// Create a 2x4 \"int\" matrix containing values `1`.\nm2 = matrix.new<int>(2, 4, 1)\n\n// Append matrix `m2` to `m1`.\nmatrix.concat(m1, m2)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix Elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.concat(id1, id2) → matrix<type>"
          ],
          "returnedTypes": [
            "matrix<>"
          ]
        },
        {
          "name": "matrix.swap_rows",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "row1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "row2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.swap_rows()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 3x2 matrix with ‘na’ values.\n\tvar m1 = matrix.new<int>(3, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\tmatrix.set(m1, 2, 0, 5)\n\tmatrix.set(m1, 2, 1, 6)\n\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\n\t// Swap the first and second rows of the matrix copy.\n\tmatrix.swap_rows(m2, 0, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Swapped rows in copy:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.swap_columns()](#fun_matrix.swap_columns)"
          ],
          "syntax": [
            "matrix.swap_rows(id, row1, row2) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.swap_columns",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            },
            {
              "name": "column1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "column2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.swap_columns()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix with ‘na’ values.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\n\t// Swap the first and second columns of the matrix copy.\n\tmatrix.swap_columns(m2, 0, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Swapped columns in copy:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.swap_columns(id, column1, column2) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.reverse",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.reverse()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Copy the matrix to a new one.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Copy matrix elements to a new matrix.\n\tvar m2 = matrix.copy(m1)\n\n\t// Reverse the `m2` copy of the original matrix.\n\tmatrix.reverse(m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Reversed matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)",
            "[matrix.reshape()](#fun_matrix.reshape)"
          ],
          "syntax": [
            "matrix.reverse(id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.sort",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>",
                "matrix<string>"
              ],
              "displayType": "matrix<int/float/string>"
            },
            {
              "name": "column",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "order",
              "desc": "",
              "allowedTypeIDs": [
                "series sort_order",
                "simple sort_order",
                "input sort_order",
                "const sort_order"
              ],
              "displayType": "series sort_order"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.sort()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<float>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 3)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 1)\n\tmatrix.set(m1, 1, 1, 2)\n\n\t// Copy the matrix to a new one.\n\tvar m2 = matrix.copy(m1)\n\t// Sort the rows of `m2` using the default arguments (first column and ascending order).\n\tmatrix.sort(m2)\n\n\t// Display using a table.\n\tif barstate.islastconfirmedhistory\n\t\tvar t = table.new(position.top_right, 2, 2, color.green)\n\t\ttable.cell(t, 0, 0, \"Original matrix:\")\n\t\ttable.cell(t, 0, 1, str.tostring(m1))\n\t\ttable.cell(t, 1, 0, \"Sorted matrix:\")\n\t\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.max()](#fun_matrix.max)",
            "[matrix.min()](#fun_matrix.min)",
            "[matrix.avg()](#fun_matrix.avg)"
          ],
          "syntax": [
            "matrix.sort(id, column, order) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "matrix.det",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.det` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<float>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0,  3)\nmatrix.set(m, 0, 1,  7)\nmatrix.set(m, 1, 0,  1)\nmatrix.set(m, 1, 1, -4)\n\n// Get the determinant of the matrix.\nvar x = matrix.det(m)\n\nplot(x, 'Matrix determinant')"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)"
          ],
          "syntax": [
            "matrix.det(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "matrix.det",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.det` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<float>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0,  3)\nmatrix.set(m, 0, 1,  7)\nmatrix.set(m, 1, 0,  1)\nmatrix.set(m, 1, 1, -4)\n\n// Get the determinant of the matrix.\nvar x = matrix.det(m)\n\nplot(x, 'Matrix determinant')"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)"
          ],
          "syntax": [
            "matrix.det(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "matrix.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.min()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the minimum value from the matrix.\nvar x = matrix.min(m)\n\nplot(x, 'Matrix minimum value')"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.max()](#fun_matrix.max)",
            "[matrix.avg()](#fun_matrix.avg)",
            "[matrix.sort()](#fun_matrix.sort)"
          ],
          "syntax": [
            "matrix.min(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "matrix.min",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.min()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the minimum value from the matrix.\nvar x = matrix.min(m)\n\nplot(x, 'Matrix minimum value')"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.max()](#fun_matrix.max)",
            "[matrix.avg()](#fun_matrix.avg)",
            "[matrix.sort()](#fun_matrix.sort)"
          ],
          "syntax": [
            "matrix.min(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "matrix.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.max()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the maximum value in the matrix.\nvar x = matrix.max(m)\n\nplot(x, 'Matrix maximum value')"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.min()](#fun_matrix.min)",
            "[matrix.avg()](#fun_matrix.avg)",
            "[matrix.sort()](#fun_matrix.sort)"
          ],
          "syntax": [
            "matrix.max(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "matrix.max",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.max()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the maximum value in the matrix.\nvar x = matrix.max(m)\n\nplot(x, 'Matrix maximum value')"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.min()](#fun_matrix.min)",
            "[matrix.avg()](#fun_matrix.avg)",
            "[matrix.sort()](#fun_matrix.sort)"
          ],
          "syntax": [
            "matrix.max(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "matrix.avg",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.avg()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the average value of the matrix.\nvar x = matrix.avg(m)\n\nplot(x, 'Matrix average value')"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.avg(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "matrix.avg",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.avg()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the average value of the matrix.\nvar x = matrix.avg(m)\n\nplot(x, 'Matrix average value')"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.avg(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "matrix.median",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.median()` Example\")\n\n// Create a 2x2 matrix.\nm = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the median of the matrix.\nx = matrix.median(m)\n\nplot(x, 'Median of the matrix')"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.mode()](#fun_matrix.mode)",
            "[matrix.sort()](#fun_matrix.sort)",
            "[matrix.avg()](#fun_matrix.avg)"
          ],
          "syntax": [
            "matrix.median(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "matrix.median",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.median()` Example\")\n\n// Create a 2x2 matrix.\nm = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the median of the matrix.\nx = matrix.median(m)\n\nplot(x, 'Median of the matrix')"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.mode()](#fun_matrix.mode)",
            "[matrix.sort()](#fun_matrix.sort)",
            "[matrix.avg()](#fun_matrix.avg)"
          ],
          "syntax": [
            "matrix.median(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "matrix.mode",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.mode()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 0)\nmatrix.set(m, 0, 1, 0)\nmatrix.set(m, 1, 0, 1)\nmatrix.set(m, 1, 1, 1)\n\n// Get the mode of the matrix.\nvar x = matrix.mode(m)\n\nplot(x, 'Mode of the matrix')"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.median()](#fun_matrix.median)",
            "[matrix.sort()](#fun_matrix.sort)",
            "[matrix.avg()](#fun_matrix.avg)"
          ],
          "syntax": [
            "matrix.mode(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "matrix.mode",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.mode()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 0)\nmatrix.set(m, 0, 1, 0)\nmatrix.set(m, 1, 0, 1)\nmatrix.set(m, 1, 1, 1)\n\n// Get the mode of the matrix.\nvar x = matrix.mode(m)\n\nplot(x, 'Mode of the matrix')"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.median()](#fun_matrix.median)",
            "[matrix.sort()](#fun_matrix.sort)",
            "[matrix.avg()](#fun_matrix.avg)"
          ],
          "syntax": [
            "matrix.mode(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "matrix.transpose",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.transpose()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<float>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Create a transpose of the matrix.\n\tvar m2 = matrix.transpose(m1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Transposed matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)",
            "[matrix.reshape()](#fun_matrix.reshape)",
            "[matrix.reverse()](#fun_matrix.reverse)"
          ],
          "syntax": [
            "matrix.transpose(id) → matrix<type>"
          ],
          "returnedTypes": [
            "matrix<>"
          ]
        },
        {
          "name": "matrix.sum",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>"
              ],
              "displayType": "series int/float/matrix<int>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.sum()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(2, 3, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix that sums matrices `m1` and `m2`.\n\tvar m3 = matrix.sum(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Sum of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.sum()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix with values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix containing the sum of the `m1` matrix with the \"int\" value `1`.\n\tvar m2 = matrix.sum(m1, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Sum of a matrix and a scalar:\")\n\ttable.cell(t, 0, 1, str.tostring(m2))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.sum(id1, id2) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.sum",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "series int/float/matrix<int/float>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.sum()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(2, 3, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix that sums matrices `m1` and `m2`.\n\tvar m3 = matrix.sum(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Sum of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.sum()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix with values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix containing the sum of the `m1` matrix with the \"int\" value `1`.\n\tvar m2 = matrix.sum(m1, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Sum of a matrix and a scalar:\")\n\ttable.cell(t, 0, 1, str.tostring(m2))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.sum(id1, id2) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ]
        },
        {
          "name": "matrix.diff",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>"
              ],
              "displayType": "series int/float/matrix<int>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.diff()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(2, 3, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix containing the difference between matrices `m1` and `m2`.\n\tvar m3 = matrix.diff(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Difference between two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.diff()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix with values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix containing the difference between the `m1` matrix and the \"int\" value `1`.\n\tvar m2 = matrix.diff(m1, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Difference between a matrix and a scalar:\")\n\ttable.cell(t, 0, 1, str.tostring(m2))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.diff(id1, id2) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.diff",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "series int/float/matrix<int/float>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.diff()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(2, 3, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix containing the difference between matrices `m1` and `m2`.\n\tvar m3 = matrix.diff(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Difference between two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.diff()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix with values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix containing the difference between the `m1` matrix and the \"int\" value `1`.\n\tvar m2 = matrix.diff(m1, 1)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Difference between a matrix and a scalar:\")\n\ttable.cell(t, 0, 1, str.tostring(m2))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.diff(id1, id2) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ]
        },
        {
          "name": "matrix.mult",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>"
              ],
              "displayType": "series int/float/matrix<int>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 6x2 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(6, 2, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\t// Note that it must have the same quantity of rows as there are columns in the first matrix.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix from the multiplication of the two matrices.\n\tvar m3 = matrix.mult(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Product of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix from the product of the two matrices.\n\tscalar = 5\n\tvar m2 = matrix.mult(m1, scalar)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Scalar:\")\n\ttable.cell(t, 2, 1, str.tostring(scalar))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 2:\")\n\ttable.cell(t, 4, 1, str.tostring(m2))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 3\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<int>(2, 3, 4)\n\n\t// Create an array of three elements.\n\tvar array<int> a = array.from(1, 1, 1)\n\n\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.\n\tvar m3 = matrix.mult(m1, a)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Value:\")\n\ttable.cell(t, 2, 1, str.tostring(a, \" \"))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 3:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.sum()](#fun_matrix.sum)",
            "[matrix.diff()](#fun_matrix.diff)"
          ],
          "syntax": [
            "matrix.mult(id1, id2) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.mult",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "series int/float/matrix<int/float>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 6x2 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(6, 2, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\t// Note that it must have the same quantity of rows as there are columns in the first matrix.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix from the multiplication of the two matrices.\n\tvar m3 = matrix.mult(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Product of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix from the product of the two matrices.\n\tscalar = 5\n\tvar m2 = matrix.mult(m1, scalar)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Scalar:\")\n\ttable.cell(t, 2, 1, str.tostring(scalar))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 2:\")\n\ttable.cell(t, 4, 1, str.tostring(m2))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 3\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<int>(2, 3, 4)\n\n\t// Create an array of three elements.\n\tvar array<int> a = array.from(1, 1, 1)\n\n\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.\n\tvar m3 = matrix.mult(m1, a)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Value:\")\n\ttable.cell(t, 2, 1, str.tostring(a, \" \"))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 3:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.sum()](#fun_matrix.sum)",
            "[matrix.diff()](#fun_matrix.diff)"
          ],
          "syntax": [
            "matrix.mult(id1, id2) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ]
        },
        {
          "name": "matrix.mult",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>"
              ],
              "displayType": "array<int>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 6x2 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(6, 2, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\t// Note that it must have the same quantity of rows as there are columns in the first matrix.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix from the multiplication of the two matrices.\n\tvar m3 = matrix.mult(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Product of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix from the product of the two matrices.\n\tscalar = 5\n\tvar m2 = matrix.mult(m1, scalar)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Scalar:\")\n\ttable.cell(t, 2, 1, str.tostring(scalar))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 2:\")\n\ttable.cell(t, 4, 1, str.tostring(m2))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 3\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<int>(2, 3, 4)\n\n\t// Create an array of three elements.\n\tvar array<int> a = array.from(1, 1, 1)\n\n\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.\n\tvar m3 = matrix.mult(m1, a)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Value:\")\n\ttable.cell(t, 2, 1, str.tostring(a, \" \"))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 3:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.sum()](#fun_matrix.sum)",
            "[matrix.diff()](#fun_matrix.diff)"
          ],
          "syntax": [
            "matrix.mult(id1, id2) → array<int>"
          ],
          "returnedTypes": [
            "array<int>"
          ]
        },
        {
          "name": "matrix.mult",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<int>",
                "array<float>"
              ],
              "displayType": "array<int/float>"
            }
          ],
          "detailedDesc": [
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 6x2 matrix containing values `5`.\n\tvar m1 = matrix.new<float>(6, 2, 5)\n\t// Create a 2x3 matrix containing values `4`.\n\t// Note that it must have the same quantity of rows as there are columns in the first matrix.\n\tvar m2 = matrix.new<float>(2, 3, 4)\n\t// Create a new matrix from the multiplication of the two matrices.\n\tvar m3 = matrix.mult(m1, m2)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 1, 2, color.green)\n\ttable.cell(t, 0, 0, \"Product of two matrices:\")\n\ttable.cell(t, 0, 1, str.tostring(m3))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<float>(2, 3, 4)\n\n\t// Create a new matrix from the product of the two matrices.\n\tscalar = 5\n\tvar m2 = matrix.mult(m1, scalar)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Scalar:\")\n\ttable.cell(t, 2, 1, str.tostring(scalar))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 2:\")\n\ttable.cell(t, 4, 1, str.tostring(m2))"
              ]
            },
            {
              "desc": [
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"`matrix.mult()` Example 3\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x3 matrix containing values `4`.\n\tvar m1 = matrix.new<int>(2, 3, 4)\n\n\t// Create an array of three elements.\n\tvar array<int> a = array.from(1, 1, 1)\n\n\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.\n\tvar m3 = matrix.mult(m1, a)\n\n\t// Display using a table.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"x\")\n\ttable.cell(t, 2, 0, \"Value:\")\n\ttable.cell(t, 2, 1, str.tostring(a, \" \"))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Matrix 3:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
              ]
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.sum()](#fun_matrix.sum)",
            "[matrix.diff()](#fun_matrix.diff)"
          ],
          "syntax": [
            "matrix.mult(id1, id2) → array<float>"
          ],
          "returnedTypes": [
            "array<float>"
          ]
        },
        {
          "name": "matrix.pinv",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.pinv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Pseudoinverse of the matrix.\n\tvar m2 = matrix.pinv(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Pseudoinverse matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.inv()](#fun_matrix.inv)"
          ],
          "syntax": [
            "matrix.pinv(id) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ]
        },
        {
          "name": "matrix.pinv",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.pinv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Pseudoinverse of the matrix.\n\tvar m2 = matrix.pinv(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Pseudoinverse matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.inv()](#fun_matrix.inv)"
          ],
          "syntax": [
            "matrix.pinv(id) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.inv",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.inv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Inverse of the matrix.\n\tvar m2 = matrix.inv(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Inverse matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.pinv()](#fun_matrix.pinv)",
            "[matrix.copy()](#fun_matrix.copy)",
            "[str.tostring()](#fun_str.tostring)"
          ],
          "syntax": [
            "matrix.inv(id) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ]
        },
        {
          "name": "matrix.inv",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.inv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Inverse of the matrix.\n\tvar m2 = matrix.inv(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Inverse matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.pinv()](#fun_matrix.pinv)",
            "[matrix.copy()](#fun_matrix.copy)",
            "[str.tostring()](#fun_str.tostring)"
          ],
          "syntax": [
            "matrix.inv(id) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.rank",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.rank()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Get the rank of the matrix.\n\tr = matrix.rank(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Rank of the matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(r))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[str.tostring()](#fun_str.tostring)"
          ],
          "syntax": [
            "matrix.rank(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "matrix.trace",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.trace()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Get the trace of the matrix.\n\ttr = matrix.trace(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Trace of the matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(tr))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.trace(id) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "matrix.trace",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.trace()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 1)\n\tmatrix.set(m1, 0, 1, 2)\n\tmatrix.set(m1, 1, 0, 3)\n\tmatrix.set(m1, 1, 1, 4)\n\n\t// Get the trace of the matrix.\n\ttr = matrix.trace(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Trace of the matrix:\")\n\ttable.cell(t, 1, 1, str.tostring(tr))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.trace(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "matrix.eigenvalues",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.eigenvalues()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 2)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 6)\n\tmatrix.set(m1, 1, 1, 8)\n\n\t// Get the eigenvalues of the matrix.\n\ttr = matrix.eigenvalues(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Array of Eigenvalues:\")\n\ttable.cell(t, 1, 1, str.tostring(tr))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.eigenvectors()](#fun_matrix.eigenvectors)"
          ],
          "syntax": [
            "matrix.eigenvalues(id) → array<float>"
          ],
          "returnedTypes": [
            "array<float>"
          ]
        },
        {
          "name": "matrix.eigenvalues",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.eigenvalues()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, na)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 2)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 6)\n\tmatrix.set(m1, 1, 1, 8)\n\n\t// Get the eigenvalues of the matrix.\n\ttr = matrix.eigenvalues(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Array of Eigenvalues:\")\n\ttable.cell(t, 1, 1, str.tostring(tr))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.eigenvectors()](#fun_matrix.eigenvectors)"
          ],
          "syntax": [
            "matrix.eigenvalues(id) → array<int>"
          ],
          "returnedTypes": [
            "array<int>"
          ]
        },
        {
          "name": "matrix.eigenvectors",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.eigenvectors()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix\n\tvar m1 = matrix.new<int>(2, 2, 1)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 2)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 6)\n\tmatrix.set(m1, 1, 1, 8)\n\n\t// Get the eigenvectors of the matrix.\n\tm2 = matrix.eigenvectors(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix Elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix Eigenvectors:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.eigenvalues()](#fun_matrix.eigenvalues)"
          ],
          "syntax": [
            "matrix.eigenvectors(id) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ]
        },
        {
          "name": "matrix.eigenvectors",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.eigenvectors()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix\n\tvar m1 = matrix.new<int>(2, 2, 1)\n\t// Fill the matrix with values.\n\tmatrix.set(m1, 0, 0, 2)\n\tmatrix.set(m1, 0, 1, 4)\n\tmatrix.set(m1, 1, 0, 6)\n\tmatrix.set(m1, 1, 1, 8)\n\n\t// Get the eigenvectors of the matrix.\n\tm2 = matrix.eigenvectors(m1)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix Elements:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix Eigenvectors:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.eigenvalues()](#fun_matrix.eigenvalues)"
          ],
          "syntax": [
            "matrix.eigenvectors(id) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.kron",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.kron()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n\t// Create two matrices with default values `1` and `2`.\n\tvar m1 = matrix.new<float>(2, 2, 1)\n\tvar m2 = matrix.new<float>(2, 2, 2)\n\n\t// Calculate the Kronecker product of the matrices.\n\tvar m3 = matrix.kron(m1, m2)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"⊗\")\n\ttable.cell(t, 2, 0, \"Matrix 2:\")\n\ttable.cell(t, 2, 1, str.tostring(m2))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Kronecker product:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.mult()](#fun_matrix.mult)",
            "[str.tostring()](#fun_str.tostring)",
            "[table.new()](#fun_table.new)"
          ],
          "syntax": [
            "matrix.kron(id1, id2) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ]
        },
        {
          "name": "matrix.kron",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id1",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.kron()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n\t// Create two matrices with default values `1` and `2`.\n\tvar m1 = matrix.new<float>(2, 2, 1)\n\tvar m2 = matrix.new<float>(2, 2, 2)\n\n\t// Calculate the Kronecker product of the matrices.\n\tvar m3 = matrix.kron(m1, m2)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 5, 2, color.green)\n\ttable.cell(t, 0, 0, \"Matrix 1:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 1, \"⊗\")\n\ttable.cell(t, 2, 0, \"Matrix 2:\")\n\ttable.cell(t, 2, 1, str.tostring(m2))\n\ttable.cell(t, 3, 1, \"=\")\n\ttable.cell(t, 4, 0, \"Kronecker product:\")\n\ttable.cell(t, 4, 1, str.tostring(m3))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.mult()](#fun_matrix.mult)",
            "[str.tostring()](#fun_str.tostring)",
            "[table.new()](#fun_table.new)"
          ],
          "syntax": [
            "matrix.kron(id1, id2) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.pow",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            },
            {
              "name": "power",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.pow()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, 2)\n\t// Calculate the power of three of the matrix.\n\tvar m2 = matrix.pow(m1, 3)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix³:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.mult()](#fun_matrix.mult)"
          ],
          "syntax": [
            "matrix.pow(id, power) → matrix<float>"
          ],
          "returnedTypes": [
            "matrix<float>"
          ]
        },
        {
          "name": "matrix.pow",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>"
              ],
              "displayType": "matrix<int>"
            },
            {
              "name": "power",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"`matrix.pow()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n\t// Create a 2x2 matrix.\n\tvar m1 = matrix.new<int>(2, 2, 2)\n\t// Calculate the power of three of the matrix.\n\tvar m2 = matrix.pow(m1, 3)\n\n\t// Display matrix elements.\n\tvar t = table.new(position.top_right, 2, 2, color.green)\n\ttable.cell(t, 0, 0, \"Original Matrix:\")\n\ttable.cell(t, 0, 1, str.tostring(m1))\n\ttable.cell(t, 1, 0, \"Matrix³:\")\n\ttable.cell(t, 1, 1, str.tostring(m2))"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.mult()](#fun_matrix.mult)"
          ],
          "syntax": [
            "matrix.pow(id, power) → matrix<int>"
          ],
          "returnedTypes": [
            "matrix<int>"
          ]
        },
        {
          "name": "matrix.is_zero",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)"
          ],
          "syntax": [
            "matrix.is_zero(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "matrix.is_identity",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.is_square()](#fun_matrix.is_square)",
            "[matrix.is_diagonal()](#fun_matrix.is_diagonal)"
          ],
          "syntax": [
            "matrix.is_identity(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "matrix.is_binary",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)"
          ],
          "syntax": [
            "matrix.is_binary(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "matrix.is_symmetric",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)"
          ],
          "syntax": [
            "matrix.is_symmetric(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "matrix.is_antisymmetric",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)"
          ],
          "syntax": [
            "matrix.is_antisymmetric(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "matrix.is_diagonal",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)",
            "[matrix.is_identity()](#fun_matrix.is_identity)",
            "[matrix.is_antidiagonal()](#fun_matrix.is_antidiagonal)"
          ],
          "syntax": [
            "matrix.is_diagonal(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "matrix.is_antidiagonal",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)",
            "[matrix.is_identity()](#fun_matrix.is_identity)",
            "[matrix.is_diagonal()](#fun_matrix.is_diagonal)"
          ],
          "syntax": [
            "matrix.is_antidiagonal(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "matrix.is_triangular",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.is_square()](#fun_matrix.is_square)"
          ],
          "syntax": [
            "matrix.is_triangular(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "matrix.is_stochastic",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<int>",
                "matrix<float>"
              ],
              "displayType": "matrix<int/float>"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.set()](#fun_matrix.set)"
          ],
          "syntax": [
            "matrix.is_stochastic(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "matrix.is_square",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "matrix<>"
              ],
              "displayType": "any matrix type"
            }
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[matrix.new<type>()](#fun_matrix.new<type>)",
            "[matrix.get()](#fun_matrix.get)",
            "[matrix.set()](#fun_matrix.set)",
            "[matrix.columns()](#fun_matrix.columns)",
            "[matrix.rows()](#fun_matrix.rows)"
          ],
          "syntax": [
            "matrix.is_square(id) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "table.merge_cells",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "table_id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series table"
              ],
              "displayType": "series table"
            },
            {
              "name": "start_column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "start_row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "end_column",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "end_row",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"table.merge_cells example\")\nSMA50  = ta.sma(close, 50)\nSMA100 = ta.sma(close, 100)\nSMA200 = ta.sma(close, 200)\nif barstate.islast\n\tmaTable = table.new(position.bottom_right, 3, 3, bgcolor = color.gray, border_width = 1, border_color = color.black)\n\t// Header\n\ttable.cell(maTable, 0, 0, text = \"SMA Table\")\n\ttable.merge_cells(maTable, 0, 0, 2, 0)\n\t// Cell Titles\n\ttable.cell(maTable, 0, 1, text = \"SMA 50\")\n\ttable.cell(maTable, 1, 1, text = \"SMA 100\")\n\ttable.cell(maTable, 2, 1, text = \"SMA 200\")\n\t// Values\n\ttable.cell(maTable, 0, 2, bgcolor = color.white, text = str.tostring(SMA50))\n\ttable.cell(maTable, 1, 2, bgcolor = color.white, text = str.tostring(SMA100))\n\ttable.cell(maTable, 2, 2, bgcolor = color.white, text = str.tostring(SMA200))"
          ],
          "remarks": [
            "",
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[table.delete()](#fun_table.delete)",
            "[table.new()](#fun_table.new)"
          ],
          "syntax": [
            "table.merge_cells(table_id, start_column, start_row, end_column, end_row) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "strategy.closedtrades.entry_price",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"strategy.closedtrades.entry_price Example 1\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Return the entry price for the latest entry.\nentryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)\n\nplot(entryPrice, \"Long entry price\")"
              ]
            },
            {
              "desc": [],
              "examples": [
                "// Calculates the average profit percentage for all closed trades.\n//@version=6\nstrategy(\"strategy.closedtrades.entry_price Example 2\")\n\n// Strategy calls to create single short and long trades\nif bar_index == last_bar_index - 15\n    strategy.entry(\"Long Entry\", strategy.long)\nelse if bar_index == last_bar_index - 10\n    strategy.close(\"Long Entry\")\n    strategy.entry(\"Short\", strategy.short)\nelse if bar_index == last_bar_index - 5\n    strategy.close(\"Short\")\n\n// Calculate profit for both closed trades.\nprofitPct = 0.0\nfor tradeNo = 0 to strategy.closedtrades - 1\n    entryP = strategy.closedtrades.entry_price(tradeNo)\n    exitP = strategy.closedtrades.exit_price(tradeNo)\n    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100\n\n// Calculate average profit percent for both closed trades.\navgProfitPct = nz(profitPct / strategy.closedtrades)\n\nplot(avgProfitPct)"
              ]
            }
          ],
          "seeAlso": [
            "[strategy.closedtrades.entry_price()](#fun_strategy.closedtrades.entry_price)",
            "[strategy.closedtrades.exit_price()](#fun_strategy.closedtrades.exit_price)",
            "[strategy.closedtrades.size()](#fun_strategy.closedtrades.size)",
            "[strategy.closedtrades](#var_strategy.closedtrades)"
          ],
          "syntax": [
            "strategy.closedtrades.entry_price(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.closedtrades.entry_bar_index",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"strategy.closedtrades.entry_bar_index Example\")\n// Enter long trades on three rising bars; exit on two falling bars.\nif ta.rising(close, 3)\n    strategy.entry(\"Long\", strategy.long)\nif ta.falling(close, 2)\n    strategy.close(\"Long\")\n// Function that calculates the average amount of bars in a trade.\navgBarsPerTrade() =>\n\tsumBarsPerTrade = 0\n\tfor tradeNo = 0 to strategy.closedtrades - 1\n\t\t// Loop through all closed trades, starting with the oldest.\n\t\tsumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1\n\tresult = nz(sumBarsPerTrade / strategy.closedtrades)\nplot(avgBarsPerTrade())"
          ],
          "seeAlso": [
            "[strategy.closedtrades.exit_bar_index()](#fun_strategy.closedtrades.exit_bar_index)",
            "[strategy.opentrades.entry_bar_index()](#fun_strategy.opentrades.entry_bar_index)"
          ],
          "syntax": [
            "strategy.closedtrades.entry_bar_index(trade_num) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "strategy.closedtrades.entry_time",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"strategy.closedtrades.entry_time Example\", overlay = true)\n\n// Enter long trades on three rising bars; exit on two falling bars.\nif ta.rising(close, 3)\n    strategy.entry(\"Long\", strategy.long)\nif ta.falling(close, 2)\n    strategy.close(\"Long\")\n\n// Calculate the average trade duration\navgTradeDuration() =>\n    sumTradeDuration = 0\n    for i = 0 to strategy.closedtrades - 1\n        sumTradeDuration += strategy.closedtrades.exit_time(i) - strategy.closedtrades.entry_time(i)\n    result = nz(sumTradeDuration / strategy.closedtrades)\n\n// Display average duration converted to seconds and formatted using 2 decimal points\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(avgTradeDuration() / 1000, \"#.##\") + \" seconds\")"
          ],
          "seeAlso": [
            "[strategy.opentrades.entry_time()](#fun_strategy.opentrades.entry_time)",
            "[strategy.closedtrades.exit_time()](#fun_strategy.closedtrades.exit_time)",
            "[time](#var_time)"
          ],
          "syntax": [
            "strategy.closedtrades.entry_time(trade_num) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "strategy.closedtrades.exit_price",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"strategy.closedtrades.exit_price Example 1\")\n\n// We are creating a long trade every 5 bars\nif bar_index % 5 == 0\n    strategy.entry(\"Long\", strategy.long)\nstrategy.close(\"Long\")\n\n// Return the exit price from the latest closed trade.\nexitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)\n\nplot(exitPrice, \"Long exit price\")"
              ]
            },
            {
              "desc": [],
              "examples": [
                "// Calculates the average profit percentage for all closed trades.\n//@version=6\nstrategy(\"strategy.closedtrades.exit_price Example 2\")\n\n// Strategy calls to create single short and long trades.\nif bar_index == last_bar_index - 15\n    strategy.entry(\"Long Entry\", strategy.long)\nelse if bar_index == last_bar_index - 10\n    strategy.close(\"Long Entry\")\n    strategy.entry(\"Short\", strategy.short)\nelse if bar_index == last_bar_index - 5\n    strategy.close(\"Short\")\n\n// Calculate profit for both closed trades.\nprofitPct = 0.0\nfor tradeNo = 0 to strategy.closedtrades - 1\n    entryP = strategy.closedtrades.entry_price(tradeNo)\n    exitP = strategy.closedtrades.exit_price(tradeNo)\n    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100\n\n// Calculate average profit percent for both closed trades.\navgProfitPct = nz(profitPct / strategy.closedtrades)\n\nplot(avgProfitPct)"
              ]
            }
          ],
          "seeAlso": [
            "[strategy.closedtrades.entry_price()](#fun_strategy.closedtrades.entry_price)"
          ],
          "syntax": [
            "strategy.closedtrades.exit_price(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.closedtrades.exit_bar_index",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"strategy.closedtrades.exit_bar_index Example 1\")\n\n// Strategy calls to place a single short trade. We enter the trade at the first bar and exit the trade at 10 bars before the last chart bar.\nif bar_index == 0\n    strategy.entry(\"Short\", strategy.short)\nif bar_index == last_bar_index - 10\n    strategy.close(\"Short\")\n\n// Calculate the amount of bars since the last closed trade.\nbarsSinceClosed = strategy.closedtrades > 0 ? bar_index - strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1) : na\n\nplot(barsSinceClosed, \"Bars since last closed trade\")"
              ]
            },
            {
              "desc": [],
              "examples": [
                "// Calculates the average amount of bars per trade.\n//@version=6\nstrategy(\"strategy.closedtrades.exit_bar_index Example 2\")\n\n// Enter long trades on three rising bars; exit on two falling bars.\nif ta.rising(close, 3)\n    strategy.entry(\"Long\", strategy.long)\nif ta.falling(close, 2)\n    strategy.close(\"Long\")\n\n// Function that calculates the average amount of bars per trade.\navgBarsPerTrade() =>\n    sumBarsPerTrade = 0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        // Loop through all closed trades, starting with the oldest.\n        sumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1\n    result = nz(sumBarsPerTrade / strategy.closedtrades)\n\nplot(avgBarsPerTrade())"
              ]
            }
          ],
          "seeAlso": [
            "[bar_index](#var_bar_index)",
            "[last_bar_index](#var_last_bar_index)"
          ],
          "syntax": [
            "strategy.closedtrades.exit_bar_index(trade_num) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "strategy.closedtrades.exit_time",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"strategy.closedtrades.exit_time Example 1\")\n\n// Enter long trades on three rising bars; exit on two falling bars.\nif ta.rising(close, 3)\n    strategy.entry(\"Long\", strategy.long)\nif ta.falling(close, 2)\n    strategy.close(\"Long\")\n\n// Calculate the average trade duration.\navgTradeDuration() =>\n    sumTradeDuration = 0\n    for i = 0 to strategy.closedtrades - 1\n        sumTradeDuration += strategy.closedtrades.exit_time(i) - strategy.closedtrades.entry_time(i)\n    result = nz(sumTradeDuration / strategy.closedtrades)\n\n// Display average duration converted to seconds and formatted using 2 decimal points.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(avgTradeDuration() / 1000, \"#.##\") + \" seconds\")"
              ]
            },
            {
              "desc": [],
              "examples": [
                "// Reopens a closed trade after X seconds.\n//@version=6\nstrategy(\"strategy.closedtrades.exit_time Example 2\")\n\n// Strategy calls to emulate a single long trade at the first bar.\nif bar_index == 0\n    strategy.entry(\"Long\", strategy.long)\n\nreopenPositionAfter(timeSec) =>\n    if strategy.closedtrades > 0\n        if time - strategy.closedtrades.exit_time(strategy.closedtrades - 1) >= timeSec * 1000\n            strategy.entry(\"Long\", strategy.long)\n\n// Reopen last closed position after 120 sec.\nreopenPositionAfter(120)\n\nif ta.change(strategy.opentrades) != 0\n    strategy.exit(\"Long\", stop = low * 0.9, profit = high * 2.5)"
              ]
            }
          ],
          "seeAlso": [
            "[strategy.closedtrades.entry_time()](#fun_strategy.closedtrades.entry_time)"
          ],
          "syntax": [
            "strategy.closedtrades.exit_time(trade_num) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "strategy.closedtrades.size",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"`strategy.closedtrades.size` Example 1\")\n\n// We calculate the max amt of shares we can buy.\namtShares = math.floor(strategy.equity / close)\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long, qty = amtShares)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot the number of contracts traded in the last closed trade.\nplot(strategy.closedtrades.size(strategy.closedtrades - 1), \"Number of contracts traded\")"
              ]
            },
            {
              "desc": [],
              "examples": [
                "// Calculates the average profit percentage for all closed trades.\n//@version=6\nstrategy(\"`strategy.closedtrades.size` Example 2\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n\n// Calculate profit for both closed trades.\nprofitPct = 0.0\nfor tradeNo = 0 to strategy.closedtrades - 1\n    entryP = strategy.closedtrades.entry_price(tradeNo)\n    exitP = strategy.closedtrades.exit_price(tradeNo)\n    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100\n\n// Calculate average profit percent for both closed trades.\navgProfitPct = nz(profitPct / strategy.closedtrades)\n\nplot(avgProfitPct)"
              ]
            }
          ],
          "seeAlso": [
            "[strategy.opentrades.size()](#fun_strategy.opentrades.size)",
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.closedtrades](#var_strategy.closedtrades)",
            "[strategy.opentrades](#var_strategy.opentrades)"
          ],
          "syntax": [
            "strategy.closedtrades.size(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.closedtrades.profit",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"`strategy.closedtrades.profit()` example\")\n\n// Enter a long trade every 15 bars, and close a long trade every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n//@function Calculates the average gross profit from all available closed trades. \navgGrossProfit() =>\n    var float result = 0.0\n    if result == 0.0 or strategy.closedtrades > strategy.closedtrades[1]\n        float sumGrossProfit = 0.0\n        for tradeNo = 0 to strategy.closedtrades - 1\n            sumGrossProfit += strategy.closedtrades.profit(tradeNo)\n        result := nz(sumGrossProfit / strategy.closedtrades)\n    result\n\nplot(avgGrossProfit(), \"Average gross profit\")"
          ],
          "seeAlso": [
            "[strategy.account_currency](#var_strategy.account_currency)",
            "[strategy.opentrades.profit()](#fun_strategy.opentrades.profit)",
            "[strategy.closedtrades.commission()](#fun_strategy.closedtrades.commission)"
          ],
          "syntax": [
            "strategy.closedtrades.profit(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.closedtrades.commission",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"`strategy.closedtrades.commission` Example\", commission_type = strategy.commission.percent, commission_value = 0.1)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot total fees for the latest closed trade.\nplot(strategy.closedtrades.commission(strategy.closedtrades - 1))"
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)",
            "[strategy.opentrades.commission()](#fun_strategy.opentrades.commission)"
          ],
          "syntax": [
            "strategy.closedtrades.commission(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.closedtrades.max_runup",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"`strategy.closedtrades.max_runup` Example\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Get the biggest max trade runup value from all of the closed trades.\nmaxTradeRunUp() =>\n    maxRunup = 0.0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        maxRunup := math.max(maxRunup, strategy.closedtrades.max_runup(tradeNo))\n    result = maxRunup\n\nplot(maxTradeRunUp(), \"Max trade runup\")"
          ],
          "seeAlso": [
            "[strategy.opentrades.max_runup()](#fun_strategy.opentrades.max_runup)",
            "[strategy.max_runup](#var_strategy.max_runup)"
          ],
          "syntax": [
            "strategy.closedtrades.max_runup(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.closedtrades.max_drawdown",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"`strategy.closedtrades.max_drawdown` Example\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Get the biggest max trade drawdown value from all of the closed trades.\nmaxTradeDrawDown() =>\n    maxDrawdown = 0.0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        maxDrawdown := math.max(maxDrawdown, strategy.closedtrades.max_drawdown(tradeNo))\n    result = maxDrawdown\n\nplot(maxTradeDrawDown(), \"Biggest max drawdown\")"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[strategy.opentrades.max_drawdown()](#fun_strategy.opentrades.max_drawdown)",
            "[strategy.max_drawdown](#var_strategy.max_drawdown)"
          ],
          "syntax": [
            "strategy.closedtrades.max_drawdown(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.closedtrades.max_drawdown_percent",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[strategy.closedtrades.max_drawdown()](#fun_strategy.closedtrades.max_drawdown)",
            "[strategy.max_drawdown](#var_strategy.max_drawdown)"
          ],
          "syntax": [
            "strategy.closedtrades.max_drawdown_percent(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.closedtrades.max_runup_percent",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[strategy.closedtrades.max_runup()](#fun_strategy.closedtrades.max_runup)",
            "[strategy.max_runup](#var_strategy.max_runup)"
          ],
          "syntax": [
            "strategy.closedtrades.max_runup_percent(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.closedtrades.profit_percent",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[strategy.closedtrades.profit()](#fun_strategy.closedtrades.profit)"
          ],
          "syntax": [
            "strategy.closedtrades.profit_percent(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.opentrades.max_drawdown_percent",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[strategy.opentrades.max_drawdown()](#fun_strategy.opentrades.max_drawdown)",
            "[strategy.max_drawdown](#var_strategy.max_drawdown)"
          ],
          "syntax": [
            "strategy.opentrades.max_drawdown_percent(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.opentrades.max_runup_percent",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[strategy.opentrades.max_runup()](#fun_strategy.opentrades.max_runup)",
            "[strategy.max_runup](#var_strategy.max_runup)"
          ],
          "syntax": [
            "strategy.opentrades.max_runup_percent(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.opentrades.profit_percent",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "seeAlso": [
            "[strategy.opentrades.profit()](#fun_strategy.opentrades.profit)"
          ],
          "syntax": [
            "strategy.opentrades.profit_percent(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.closedtrades.entry_id",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"strategy.closedtrades.entry_id Example\", overlay = true)\n\n// Enter a short position and close at the previous to last bar.\nif bar_index == 1\n    strategy.entry(\"Short at bar #\" + str.tostring(bar_index), strategy.short)\nif bar_index == last_bar_index - 2\n    strategy.close_all()\n\n// Display ID of the last entry position.\nif barstate.islastconfirmedhistory\n    label.new(last_bar_index, high, \"Last Entry ID is: \" + strategy.closedtrades.entry_id(strategy.closedtrades - 1))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[strategy.closedtrades.entry_bar_index()](#fun_strategy.closedtrades.entry_bar_index)",
            "[strategy.closedtrades.entry_price()](#fun_strategy.closedtrades.entry_price)",
            "[strategy.closedtrades.entry_time()](#fun_strategy.closedtrades.entry_time)"
          ],
          "syntax": [
            "strategy.closedtrades.entry_id(trade_num) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "strategy.closedtrades.exit_id",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"strategy.closedtrades.exit_id Example\", overlay = true)\n\n// Strategy calls to create single short and long trades\nif bar_index == last_bar_index - 15\n    strategy.entry(\"Long Entry\", strategy.long)\nelse if bar_index == last_bar_index - 10\n    strategy.entry(\"Short Entry\", strategy.short)\n\n// When a new open trade is detected then we create the exit strategy corresponding with the matching entry id\n// We detect the correct entry id by determining if a position is long or short based on the position quantity\nif ta.change(strategy.opentrades) != 0\n    posSign = strategy.opentrades.size(strategy.opentrades - 1)\n    strategy.exit(posSign > 0 ? \"SL Long Exit\" : \"SL Short Exit\", strategy.opentrades.entry_id(strategy.opentrades - 1), stop = posSign > 0 ? high - ta.tr : low + ta.tr)\n\n// When a new closed trade is detected then we place a label above the bar with the exit info\nif ta.change(strategy.closedtrades) != 0\n    msg = \"Trade closed by: \" + strategy.closedtrades.exit_id(strategy.closedtrades - 1)\n    label.new(bar_index, high + (3 * ta.tr), msg)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[strategy.closedtrades.exit_bar_index()](#fun_strategy.closedtrades.exit_bar_index)",
            "[strategy.closedtrades.exit_price()](#fun_strategy.closedtrades.exit_price)",
            "[strategy.closedtrades.exit_time()](#fun_strategy.closedtrades.exit_time)"
          ],
          "syntax": [
            "strategy.closedtrades.exit_id(trade_num) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "strategy.opentrades.entry_comment",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"`strategy.opentrades.entry_comment()` Example\", overlay = true)\n\nstopPrice = open * 1.01\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\n\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long, stop = stopPrice, comment = str.tostring(stopPrice, \"#.####\"))\n\nvar testTable = table.new(position.top_right, 1, 3, color.orange, border_width = 1)\n\nif barstate.islastconfirmedhistory or barstate.isrealtime\n    table.cell(testTable, 0, 0, 'Last entry stats')\n    table.cell(testTable, 0, 1, \"Order stop price value: \" + strategy.opentrades.entry_comment(strategy.opentrades - 1))\n    table.cell(testTable, 0, 2, \"Actual Entry Price: \" + str.tostring(strategy.opentrades.entry_price(strategy.opentrades - 1)))"
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)",
            "[strategy.entry()](#fun_strategy.entry)",
            "[strategy.opentrades](#var_strategy.opentrades)"
          ],
          "syntax": [
            "strategy.opentrades.entry_comment(trade_num) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "strategy.closedtrades.entry_comment",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"`strategy.closedtrades.entry_comment()` Example\", overlay = true)\n\nstopPrice = open * 1.01\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\n\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long, stop = stopPrice, comment = str.tostring(stopPrice, \"#.####\"))\n    strategy.exit(\"EXIT\", trail_points = 1000, trail_offset = 0)\n\nvar testTable = table.new(position.top_right, 1, 3, color.orange, border_width = 1)\n\nif barstate.islastconfirmedhistory or barstate.isrealtime\n    table.cell(testTable, 0, 0, 'Last closed trade:')\n    table.cell(testTable, 0, 1, \"Order stop price value: \" + strategy.closedtrades.entry_comment(strategy.closedtrades - 1))\n    table.cell(testTable, 0, 2, \"Actual Entry Price: \" + str.tostring(strategy.closedtrades.entry_price(strategy.closedtrades - 1)))"
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)",
            "[strategy.entry()](#fun_strategy.entry)",
            "[strategy.closedtrades](#var_strategy.closedtrades)"
          ],
          "syntax": [
            "strategy.closedtrades.entry_comment(trade_num) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "strategy.closedtrades.exit_comment",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"`strategy.closedtrades.exit_comment()` Example\", overlay = true)\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Exit\", stop = open * 0.95, limit = close * 1.05, trail_points = 100, trail_offset = 0, comment_profit = \"TP\", comment_loss = \"SL\", comment_trailing = \"TRAIL\")\n\nexitStats() =>\n    int slCount = 0\n    int tpCount = 0\n    int trailCount = 0\n\n    if strategy.closedtrades > 0\n        for i = 0 to strategy.closedtrades - 1\n            switch strategy.closedtrades.exit_comment(i)\n                \"TP\"    => tpCount    += 1\n                \"SL\"    => slCount    += 1\n                \"TRAIL\" => trailCount += 1\n    [slCount, tpCount, trailCount]\n\nvar testTable = table.new(position.top_right, 1, 4, color.orange, border_width = 1)\n\nif barstate.islastconfirmedhistory\n    [slCount, tpCount, trailCount] = exitStats()\n    table.cell(testTable, 0, 0, \"Closed trades (\" + str.tostring(strategy.closedtrades) +\") stats:\")\n    table.cell(testTable, 0, 1, \"Stop Loss: \" + str.tostring(slCount))\n    table.cell(testTable, 0, 2, \"Take Profit: \" + str.tostring(tpCount))\n    table.cell(testTable, 0, 3, \"Trailing Stop: \" + str.tostring(trailCount))"
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)",
            "[strategy.exit()](#fun_strategy.exit)",
            "[strategy.close()](#fun_strategy.close)",
            "[strategy.closedtrades()](#fun_strategy.closedtrades)"
          ],
          "syntax": [
            "strategy.closedtrades.exit_comment(trade_num) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "strategy.opentrades.entry_price",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"strategy.opentrades.entry_price Example 1\", overlay = true)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif ta.crossover(close, ta.sma(close, 14))\n\tstrategy.entry(\"Long\", strategy.long)\n\n// Return the entry price for the latest closed trade.\ncurrEntryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)\ncurrExitPrice = currEntryPrice * 1.05\n\nif high >= currExitPrice\n\tstrategy.close(\"Long\")\n\nplot(currEntryPrice, \"Long entry price\", style = plot.style_linebr)\nplot(currExitPrice, \"Long exit price\", color.green, style = plot.style_linebr)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "// Calculates the average price for the open position.\n//@version=6\nstrategy(\"strategy.opentrades.entry_price Example 2\", pyramiding = 2)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculates the average price for the open position.\navgOpenPositionPrice() =>\n    sumOpenPositionPrice = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        sumOpenPositionPrice += strategy.opentrades.entry_price(tradeNo) * strategy.opentrades.size(tradeNo) / strategy.position_size\n    result = nz(sumOpenPositionPrice / strategy.opentrades)\n\nplot(avgOpenPositionPrice())"
              ]
            }
          ],
          "seeAlso": [
            "[strategy.closedtrades.exit_price()](#fun_strategy.closedtrades.exit_price)"
          ],
          "syntax": [
            "strategy.opentrades.entry_price(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.opentrades.entry_bar_index",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "// Wait 10 bars and then close the position.\n//@version=6\nstrategy(\"`strategy.opentrades.entry_bar_index` Example\")\n\nbarsSinceLastEntry() =>\n    strategy.opentrades > 0 ? bar_index - strategy.opentrades.entry_bar_index(strategy.opentrades - 1) : na\n\n// Enter a long position if there are no open positions.\nif strategy.opentrades == 0\n    strategy.entry(\"Long\", strategy.long)\n\n// Close the long position after 10 bars.\nif barsSinceLastEntry() >= 10\n    strategy.close(\"Long\")"
              ]
            }
          ],
          "seeAlso": [
            "[strategy.closedtrades.entry_bar_index()](#fun_strategy.closedtrades.entry_bar_index)",
            "[strategy.closedtrades.exit_bar_index()](#fun_strategy.closedtrades.exit_bar_index)"
          ],
          "syntax": [
            "strategy.opentrades.entry_bar_index(trade_num) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "strategy.opentrades.entry_time",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"strategy.opentrades.entry_time Example\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculates duration in milliseconds since the last position was opened.\ntimeSinceLastEntry()=>\n    strategy.opentrades > 0 ? (time - strategy.opentrades.entry_time(strategy.opentrades - 1)) : na\n\nplot(timeSinceLastEntry() / 1000 * 60 * 60 * 24, \"Days since last entry\")"
          ],
          "seeAlso": [
            "[strategy.closedtrades.entry_time()](#fun_strategy.closedtrades.entry_time)",
            "[strategy.closedtrades.exit_time()](#fun_strategy.closedtrades.exit_time)"
          ],
          "syntax": [
            "strategy.opentrades.entry_time(trade_num) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "strategy.opentrades.size",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"`strategy.opentrades.size` Example 1\")\n\n// We calculate the max amt of shares we can buy.\namtShares = math.floor(strategy.equity / close)\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long, qty = amtShares)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot the number of contracts in the latest open trade.\nplot(strategy.opentrades.size(strategy.opentrades - 1), \"Amount of contracts in latest open trade\")"
              ]
            },
            {
              "desc": [],
              "examples": [
                "// Calculates the average profit percentage for all open trades.\n//@version=6\nstrategy(\"`strategy.opentrades.size` Example 2\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculate profit for all open trades.\nprofitPct = 0.0\nfor tradeNo = 0 to strategy.opentrades - 1\n    entryP = strategy.opentrades.entry_price(tradeNo)\n    exitP = close\n    profitPct += (exitP - entryP) / entryP * strategy.opentrades.size(tradeNo) * 100\n\n// Calculate average profit percent for all open trades.\navgProfitPct = nz(profitPct / strategy.opentrades)\nplot(avgProfitPct)"
              ]
            }
          ],
          "seeAlso": [
            "[strategy.closedtrades.size()](#fun_strategy.closedtrades.size)",
            "[strategy.position_size](#var_strategy.position_size)",
            "[strategy.opentrades](#var_strategy.opentrades)",
            "[strategy.closedtrades](#var_strategy.closedtrades)"
          ],
          "syntax": [
            "strategy.opentrades.size(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.opentrades.profit",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "// Returns the profit of the last open trade.\n//@version=6\nstrategy(\"`strategy.opentrades.profit` Example 1\", commission_type = strategy.commission.percent, commission_value = 0.1)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\nplot(strategy.opentrades.profit(strategy.opentrades - 1), \"Profit of the latest open trade\")"
              ]
            },
            {
              "desc": [],
              "examples": [
                "// Calculates the profit for all open trades.\n//@version=6\nstrategy(\"`strategy.opentrades.profit` Example 2\", pyramiding = 5)\n\n// Strategy calls to enter 5 long positions every 2 bars.\nif bar_index % 2 == 0\n    strategy.entry(\"Long\", strategy.long, qty = 5)\n\n// Calculate open profit or loss for the open positions.\ntradeOpenPL() =>\n    sumProfit = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        sumProfit += strategy.opentrades.profit(tradeNo)\n    result = sumProfit\n\nplot(tradeOpenPL(), \"Profit of all open trades\")"
              ]
            }
          ],
          "seeAlso": [
            "[strategy.closedtrades.profit()](#fun_strategy.closedtrades.profit)",
            "[strategy.openprofit](#var_strategy.openprofit)",
            "[strategy.netprofit](#var_strategy.netprofit)",
            "[strategy.grossprofit](#var_strategy.grossprofit)"
          ],
          "syntax": [
            "strategy.opentrades.profit(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.opentrades.commission",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "// Calculates the gross profit or loss for the current open position.\n//@version=6\nstrategy(\"`strategy.opentrades.commission` Example\", commission_type = strategy.commission.percent, commission_value = 0.1)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculate gross profit or loss for open positions only.\ntradeOpenGrossPL() =>\n    sumOpenGrossPL = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        sumOpenGrossPL += strategy.opentrades.profit(tradeNo) - strategy.opentrades.commission(tradeNo)\n    result = sumOpenGrossPL\n\nplot(tradeOpenGrossPL())"
              ]
            }
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)",
            "[strategy.closedtrades.commission()](#fun_strategy.closedtrades.commission)"
          ],
          "syntax": [
            "strategy.opentrades.commission(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.opentrades.max_runup",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"strategy.opentrades.max_runup Example 1\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot the max runup of the latest open trade.\nplot(strategy.opentrades.max_runup(strategy.opentrades - 1), \"Max runup of the latest open trade\")"
              ]
            },
            {
              "desc": [],
              "examples": [
                "// Calculates the max trade runup value for all open trades.\n//@version=6\nstrategy(\"strategy.opentrades.max_runup Example 2\", pyramiding = 100)\n\n// Enter a long position every 30 bars.\nif bar_index % 30 == 0\n    strategy.entry(\"Long\", strategy.long)\n\n// Calculate biggest max trade runup value from all of the open trades.\nmaxOpenTradeRunUp() =>\n    maxRunup = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        maxRunup := math.max(maxRunup, strategy.opentrades.max_runup(tradeNo))\n    result = maxRunup\n\nplot(maxOpenTradeRunUp(), \"Biggest max runup of all open trades\")"
              ]
            }
          ],
          "seeAlso": [
            "[strategy.closedtrades.max_runup()](#fun_strategy.closedtrades.max_runup)",
            "[strategy.max_drawdown](#var_strategy.max_drawdown)"
          ],
          "syntax": [
            "strategy.opentrades.max_runup(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.opentrades.max_drawdown",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"strategy.opentrades.max_drawdown Example 1\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot the max drawdown of the latest open trade.\nplot(strategy.opentrades.max_drawdown(strategy.opentrades - 1), \"Max drawdown of the latest open trade\")"
              ]
            },
            {
              "desc": [],
              "examples": [
                "// Calculates the max trade drawdown value for all open trades.\n//@version=6\nstrategy(\"`strategy.opentrades.max_drawdown` Example 2\", pyramiding = 100)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Get the biggest max trade drawdown value from all of the open trades.\nmaxTradeDrawDown() =>\n    maxDrawdown = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        maxDrawdown := math.max(maxDrawdown, strategy.opentrades.max_drawdown(tradeNo))\n    result = maxDrawdown\n\nplot(maxTradeDrawDown(), \"Biggest max drawdown\")"
              ]
            }
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[strategy.closedtrades.max_drawdown()](#fun_strategy.closedtrades.max_drawdown)",
            "[strategy.max_drawdown](#var_strategy.max_drawdown)"
          ],
          "syntax": [
            "strategy.opentrades.max_drawdown(trade_num) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.opentrades.entry_id",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "trade_num",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"`strategy.opentrades.entry_id` Example\", overlay = true)\n\n// We enter a long position when 14 period sma crosses over 28 period sma.\n// We enter a short position when 14 period sma crosses under 28 period sma.\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nshortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\n\n// Strategy calls to enter a long or short position when the corresponding condition is met.\nif longCondition\n    strategy.entry(\"Long entry at bar #\" + str.tostring(bar_index), strategy.long)\nif shortCondition\n    strategy.entry(\"Short entry at bar #\" + str.tostring(bar_index), strategy.short)\n\n// Display ID of the latest open position.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high + (2 * ta.tr), \"Last opened position is \\n \" + strategy.opentrades.entry_id(strategy.opentrades - 1))"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[strategy.opentrades.entry_bar_index()](#fun_strategy.opentrades.entry_bar_index)",
            "[strategy.opentrades.entry_price()](#fun_strategy.opentrades.entry_price)",
            "[strategy.opentrades.entry_time()](#fun_strategy.opentrades.entry_time)"
          ],
          "syntax": [
            "strategy.opentrades.entry_id(trade_num) → series string"
          ],
          "returnedTypes": [
            "series string"
          ]
        },
        {
          "name": "strategy.convert_to_account",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nstrategy(\"`strategy.convert_to_account` Example 1\", currency = currency.EUR)\n\nplot(close, \"Close price using default currency\")\nplot(strategy.convert_to_account(close), \"Close price converted to strategy currency\")"
              ]
            },
            {
              "desc": [],
              "examples": [
                "// Calculates the \"Buy and hold return\" using your account's currency.\n//@version=6\nstrategy(\"`strategy.convert_to_account` Example 2\", currency = currency.EUR)\n\ndateInput = input.time(timestamp(\"20 Jul 2021 00:00 +0300\"), \"From Date\", confirm = true)\n\nbuyAndHoldReturnPct(fromDate) =>\n    if time >= fromDate\n        money = close * syminfo.pointvalue\n        var initialBal = strategy.convert_to_account(money)\n        (strategy.convert_to_account(money) - initialBal) / initialBal * 100\n\nplot(buyAndHoldReturnPct(dateInput))"
              ]
            }
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)",
            "[strategy.convert_to_symbol()](#fun_strategy.convert_to_symbol)"
          ],
          "syntax": [
            "strategy.convert_to_account(value) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.default_entry_qty",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "fill_price",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"Supertrend Strategy\", overlay = true, default_qty_type = strategy.percent_of_equity, default_qty_value = 15)\n\n//@variable The length of the ATR calculation.\natrPeriod = input(10, \"ATR Length\")\n//@variable The ATR multiplier.\nfactor = input.float(3.0, \"Factor\", step = 0.01)\n//@variable The tick offset of the stop order.\nstopOffsetInput = input.int(100, \"Tick offset for entry stop\")\n\n// Get the direction of the SuperTrend.\n[_, direction] = ta.supertrend(factor, atrPeriod)\n\nif ta.change(direction) < 0\n\t//@variable The stop price of the entry order.\n\tstopPrice = close + syminfo.mintick * stopOffsetInput\n\t//@variable The expected default fill quantity at the `stopPrice`. This value may not reflect actual qty of the filled order, because fill price may be different.\n\tcalculatedQty = strategy.default_entry_qty(stopPrice)\n\tstrategy.entry(\"My Long Entry Id\", strategy.long, stop = stopPrice)\n\tlabel.new(bar_index, stopPrice, str.format(\"Stop set at {0}\\nExpected qty at {0}: {1}\", math.round_to_mintick(stopPrice), calculatedQty))\n\nif ta.change(direction) > 0\n\tstrategy.close_all()"
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "syntax": [
            "strategy.default_entry_qty(fill_price) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "strategy.convert_to_symbol",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"`strategy.convert_to_symbol` Example\", currency = currency.EUR)\n\n// Calculate the max qty we can buy using current chart's currency.\ncalcContracts(accountMoney) =>\n    math.floor(strategy.convert_to_symbol(accountMoney) / syminfo.pointvalue / close)\n\n// Return max qty we can buy using 300 euros\nqt = calcContracts(300)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars using our custom qty.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long, qty = qt)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")"
          ],
          "seeAlso": [
            "[strategy()](#fun_strategy)",
            "[strategy.convert_to_account()](#fun_strategy.convert_to_account)"
          ],
          "syntax": [
            "strategy.convert_to_symbol(value) → series float"
          ],
          "returnedTypes": [
            "series float"
          ]
        },
        {
          "name": "chart.point.from_index",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "index",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "price",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "chart.point.from_index(index, price) → chart.point"
          ],
          "returnedTypes": [
            "chart.point"
          ]
        },
        {
          "name": "chart.point.copy",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            }
          ],
          "syntax": [
            "chart.point.copy(id) → chart.point"
          ],
          "returnedTypes": [
            "chart.point"
          ]
        },
        {
          "name": "chart.point.from_time",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "time",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "price",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "chart.point.from_time(time, price) → chart.point"
          ],
          "returnedTypes": [
            "chart.point"
          ]
        },
        {
          "name": "chart.point.now",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "price",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            ""
          ],
          "syntax": [
            "chart.point.now(price) → chart.point"
          ],
          "returnedTypes": [
            "chart.point"
          ]
        },
        {
          "name": "chart.point.new",
          "seeAlso": [
            "[polyline.new()](#fun_polyline.new)"
          ],
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "time",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "index",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "price",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float"
              ],
              "displayType": "series int/float"
            }
          ],
          "remarks": [
            "",
            ""
          ],
          "syntax": [
            "chart.point.new(time, index, price) → chart.point"
          ],
          "returnedTypes": [
            "chart.point"
          ]
        },
        {
          "name": "line.set_first_point",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            }
          ],
          "syntax": [
            "line.set_first_point(id, point) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "line.set_second_point",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series line"
              ],
              "displayType": "series line"
            },
            {
              "name": "point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            }
          ],
          "syntax": [
            "line.set_second_point(id, point) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "label.set_point",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series label"
              ],
              "displayType": "series label"
            },
            {
              "name": "point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            }
          ],
          "syntax": [
            "label.set_point(id, point) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_top_left_point",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            }
          ],
          "syntax": [
            "box.set_top_left_point(id, point) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "box.set_bottom_right_point",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series box"
              ],
              "displayType": "series box"
            },
            {
              "name": "point",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "chart.point"
              ],
              "displayType": "chart.point"
            }
          ],
          "syntax": [
            "box.set_bottom_right_point(id, point) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "library",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "title",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "const string"
              ],
              "displayType": "const string"
            },
            {
              "name": "overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            },
            {
              "name": "dynamic_requests",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\n// @description Math library\nlibrary(\"num_methods\", overlay = true)\n// Calculate \"sinh()\" from the float parameter `x`\nexport sinh(float x) =>\n\t(math.exp(x) - math.exp(-x)) / 2.0\nplot(sinh(0))"
          ],
          "seeAlso": [
            "[indicator()](#fun_indicator)",
            "[strategy()](#fun_strategy)"
          ],
          "syntax": [
            "library(title, overlay, dynamic_requests) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "runtime.error",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "message",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "syntax": [
            "runtime.error(message) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "log.info",
          "desc": [
            "",
            "",
            ""
          ],
          "args": [
            {
              "name": "message",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"My strategy\", overlay = true, process_orders_on_close = true)\nbracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n\tlimitLevel = close * 1.01\n\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)\n\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)\n\n\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)\n\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)\n\nif strategy.opentrades > 10\n\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)\n\nlast10Perc = strategy.initial_capital / 10 > strategy.equity\nif (last10Perc and not last10Perc[1])\n\tlog.error(\"The strategy has lost 90% of the initial capital!\")"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "log.info(message) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "log.info",
          "desc": [
            "",
            "",
            ""
          ],
          "args": [
            {
              "name": "formatString",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series string",
                "simple string",
                "input string",
                "const string",
                "array<int>",
                "array<float>",
                "array<bool>",
                "array<string>"
              ],
              "displayType": "series int/float/bool/string/array<int/float/bool/string>"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"My strategy\", overlay = true, process_orders_on_close = true)\nbracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n\tlimitLevel = close * 1.01\n\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)\n\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)\n\n\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)\n\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)\n\nif strategy.opentrades > 10\n\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)\n\nlast10Perc = strategy.initial_capital / 10 > strategy.equity\nif (last10Perc and not last10Perc[1])\n\tlog.error(\"The strategy has lost 90% of the initial capital!\")"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "log.info(formatString, arg0, arg1, ...) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "log.warning",
          "desc": [
            "",
            "",
            ""
          ],
          "args": [
            {
              "name": "message",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"My strategy\", overlay = true, process_orders_on_close = true)\nbracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n\tlimitLevel = close * 1.01\n\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)\n\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)\n\n\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)\n\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)\n\nif strategy.opentrades > 10\n\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)\n\nlast10Perc = strategy.initial_capital / 10 > strategy.equity\nif (last10Perc and not last10Perc[1])\n\tlog.error(\"The strategy has lost 90% of the initial capital!\")"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "log.warning(message) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "log.warning",
          "desc": [
            "",
            "",
            ""
          ],
          "args": [
            {
              "name": "formatString",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series string",
                "simple string",
                "input string",
                "const string",
                "array<int>",
                "array<float>",
                "array<bool>",
                "array<string>"
              ],
              "displayType": "series int/float/bool/string/array<int/float/bool/string>"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"My strategy\", overlay = true, process_orders_on_close = true)\nbracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n\tlimitLevel = close * 1.01\n\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)\n\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)\n\n\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)\n\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)\n\nif strategy.opentrades > 10\n\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)\n\nlast10Perc = strategy.initial_capital / 10 > strategy.equity\nif (last10Perc and not last10Perc[1])\n\tlog.error(\"The strategy has lost 90% of the initial capital!\")"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "log.warning(formatString, arg0, arg1, ...) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "log.error",
          "desc": [
            "",
            "",
            ""
          ],
          "args": [
            {
              "name": "message",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"My strategy\", overlay = true, process_orders_on_close = true)\nbracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n\tlimitLevel = close * 1.01\n\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)\n\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)\n\n\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)\n\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)\n\nif strategy.opentrades > 10\n\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)\n\nlast10Perc = strategy.initial_capital / 10 > strategy.equity\nif (last10Perc and not last10Perc[1])\n\tlog.error(\"The strategy has lost 90% of the initial capital!\")"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "log.error(message) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "log.error",
          "desc": [
            "",
            "",
            ""
          ],
          "args": [
            {
              "name": "formatString",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "arg0, arg1, ...",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int",
                "series float",
                "simple float",
                "input float",
                "const float",
                "series bool",
                "simple bool",
                "input bool",
                "const bool",
                "series string",
                "simple string",
                "input string",
                "const string",
                "array<int>",
                "array<float>",
                "array<bool>",
                "array<string>"
              ],
              "displayType": "series int/float/bool/string/array<int/float/bool/string>"
            }
          ],
          "examples": [
            "//@version=6\nstrategy(\"My strategy\", overlay = true, process_orders_on_close = true)\nbracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n\tlimitLevel = close * 1.01\n\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)\n\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)\n\n\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)\n\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)\n\nif strategy.opentrades > 10\n\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)\n\nlast10Perc = strategy.initial_capital / 10 > strategy.equity\nif (last10Perc and not last10Perc[1])\n\tlog.error(\"The strategy has lost 90% of the initial capital!\")"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            "",
            "",
            "",
            "",
            ""
          ],
          "syntax": [
            "log.error(formatString, arg0, arg1, ...) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "map.new<type,type>",
          "desc": [
            "",
            "",
            ""
          ],
          "args": [],
          "returns": [
            ""
          ],
          "syntax": [
            "map.new<keyType, valueType>() → map<keyType, valueType>"
          ],
          "examples": [
            "//@version=6\nindicator(\"map.new<string, int> example\")\na = map.new<string, int>()\na.put(\"example\", 1)\nlabel.new(bar_index, close, str.tostring(a.get(\"example\")))"
          ],
          "remarks": [
            "",
            ""
          ],
          "seeAlso": [
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.get()](#fun_map.get)",
            "[array.new<type>()](#fun_array.new<type>)"
          ],
          "template": true
        },
        {
          "name": "map.copy",
          "desc": [
            ""
          ],
          "returns": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "map<>"
              ],
              "displayType": "any map type"
            }
          ],
          "syntax": [
            "map.copy(id) → map<keyType, valueType>"
          ],
          "examples": [
            "//@version=6\nindicator(\"map.copy example\")\na = map.new<string, int>()\na.put(\"example\", 1)\nb = map.copy(a)\na := map.new<string, int>()\na.put(\"example\", 2)\nplot(a.get(\"example\"))\nplot(b.get(\"example\"))"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.get()](#fun_map.get)",
            "[map.size()](#fun_map.size)"
          ]
        },
        {
          "name": "map.size",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "map<>"
              ],
              "displayType": "any map type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.size example\")\na = map.new<int, int>()\nsize = 10\nfor i = 0 to size\n\ta.put(i, size-i)\nplot(map.size(a))"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.get()](#fun_map.get)"
          ],
          "syntax": [
            "map.size(id) → series int"
          ],
          "returnedTypes": [
            "series int"
          ]
        },
        {
          "name": "map.get",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "map<>"
              ],
              "displayType": "any map type"
            },
            {
              "name": "key",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the map's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.get example\")\na = map.new<int, int>()\nsize = 10\nfor i = 0 to size\n\ta.put(i, size-i)\nplot(map.get(a, 1))"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.contains()](#fun_map.contains)"
          ],
          "syntax": [
            "map.get(id, key) → <value_type>"
          ],
          "returnedTypes": []
        },
        {
          "name": "map.contains",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "map<>"
              ],
              "displayType": "any map type"
            },
            {
              "name": "key",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the map's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.includes example\")\na = map.new<string, float>()\na.put(\"open\", open)\np = close\nif map.contains(a, \"open\")\n\tp := a.get(\"open\")\nplot(p)"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.size()](#fun_map.size)"
          ],
          "syntax": [
            "map.contains(id, key) → series bool"
          ],
          "returnedTypes": [
            "series bool"
          ]
        },
        {
          "name": "map.keys",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "map<>"
              ],
              "displayType": "any map type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.keys example\")\na = map.new<string, float>()\na.put(\"open\", open)\na.put(\"high\", high)\na.put(\"low\", low)\na.put(\"close\", close)\nkeys = map.keys(a)\nohlc = 0.0\nfor key in keys\n\tohlc += a.get(key)\nplot(ohlc/4)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.get()](#fun_map.get)",
            "[map.values()](#fun_map.values)",
            "[map.size()](#fun_map.size)"
          ],
          "syntax": [
            "map.keys(id) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ]
        },
        {
          "name": "map.values",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "map<>"
              ],
              "displayType": "any map type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.values example\")\na = map.new<string, float>()\na.put(\"open\", open)\na.put(\"high\", high)\na.put(\"low\", low)\na.put(\"close\", close)\nvalues = map.values(a)\nohlc = 0.0\nfor value in values\n\tohlc += value\nplot(ohlc/4)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.get()](#fun_map.get)",
            "[map.keys()](#fun_map.keys)",
            "[map.size()](#fun_map.size)"
          ],
          "syntax": [
            "map.values(id) → array<type>"
          ],
          "returnedTypes": [
            "array<>"
          ]
        },
        {
          "name": "map.put",
          "desc": [
            ""
          ],
          "returns": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "map<>"
              ],
              "displayType": "any map type"
            },
            {
              "name": "key",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the map's elements>"
            },
            {
              "name": "value",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the map's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.put example\")\na = map.new<string, float>()\nmap.put(a, \"first\", 10)\nmap.put(a, \"second\", 15)\nprevFirst = map.put(a, \"first\", 20)\ncurrFirst = a.get(\"first\")\nplot(prevFirst)\nplot(currFirst)"
          ],
          "remarks": [
            ""
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put_all()](#fun_map.put_all)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.remove()](#fun_map.remove)"
          ],
          "syntax": [
            "map.put(id, key, value) → <value_type>"
          ],
          "returnedTypes": []
        },
        {
          "name": "map.put_all",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "map<>"
              ],
              "displayType": "any map type"
            },
            {
              "name": "id2",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "map<>"
              ],
              "displayType": "any map type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.put_all example\")\na = map.new<string, float>()\nb = map.new<string, float>()\na.put(\"first\", 10)\na.put(\"second\", 15)\nb.put(\"third\", 20)\nmap.put_all(a, b)\nplot(a.get(\"third\"))"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.remove()](#fun_map.remove)"
          ],
          "syntax": [
            "map.put_all(id, id2) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "map.remove",
          "desc": [
            ""
          ],
          "returns": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "map<>"
              ],
              "displayType": "any map type"
            },
            {
              "name": "key",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [],
              "displayType": "series <type of the map's elements>"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.remove example\")\na = map.new<string, color>()\na.put(\"firstColor\", color.green)\noldColorValue = map.remove(a, \"firstColor\")\nplot(close, color = oldColorValue)"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put()](#fun_map.put)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.clear()](#fun_map.clear)"
          ],
          "syntax": [
            "map.remove(id, key) → <value_type>"
          ],
          "returnedTypes": []
        },
        {
          "name": "map.clear",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "map<>"
              ],
              "displayType": "any map type"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"map.clear example\")\noddMap = map.new<int, bool>()\noddMap.put(1, true)\noddMap.put(2, false)\noddMap.put(3, true)\nmap.clear(oddMap)\nplot(oddMap.size())"
          ],
          "seeAlso": [
            "[map.new<type,type>()](#fun_map.new<type,type>)",
            "[map.put_all()](#fun_map.put_all)",
            "[map.keys()](#fun_map.keys)",
            "[map.values()](#fun_map.values)",
            "[map.remove()](#fun_map.remove)"
          ],
          "syntax": [
            "map.clear(id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        },
        {
          "name": "polyline.new",
          "seeAlso": [
            "[chart.point.new()](#fun_chart.point.new)"
          ],
          "desc": [
            ""
          ],
          "returns": [
            ""
          ],
          "args": [
            {
              "name": "points",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "array<chart.point>"
              ],
              "displayType": "array<chart.point>"
            },
            {
              "name": "curved",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "closed",
              "desc": "",
              "allowedTypeIDs": [
                "series bool",
                "simple bool",
                "input bool",
                "const bool"
              ],
              "displayType": "series bool"
            },
            {
              "name": "xloc",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "line_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "fill_color",
              "desc": "",
              "allowedTypeIDs": [
                "series color",
                "simple color",
                "input color",
                "const color"
              ],
              "displayType": "series color"
            },
            {
              "name": "line_style",
              "desc": "",
              "allowedTypeIDs": [
                "series string",
                "simple string",
                "input string",
                "const string"
              ],
              "displayType": "series string"
            },
            {
              "name": "line_width",
              "desc": "",
              "allowedTypeIDs": [
                "series int",
                "simple int",
                "input int",
                "const int"
              ],
              "displayType": "series int"
            },
            {
              "name": "force_overlay",
              "desc": "",
              "allowedTypeIDs": [
                "const bool"
              ],
              "displayType": "const bool"
            }
          ],
          "examples": [
            "//@version=6\nindicator(\"Polylines example\", overlay = true)\n\n//@variable If `true`, connects all points in the polyline with curved line segments.\nbool curvedInput = input.bool(false, \"Curve Polyline\")\n//@variable If `true`, connects the first point in the polyline to the last point.\nbool closedInput = input.bool(true, \"Close Polyline\")\n//@variable The color of the space filled by the polyline.\ncolor fillcolor = input.color(color.new(color.blue, 90), \"Fill Color\")\n\n// Time and price inputs for the polyline's points.\np1x = input.time(0,  \"p1\", confirm = true, inline = \"p1\")\np1y = input.price(0, \"  \", confirm = true, inline = \"p1\")\np2x = input.time(0,  \"p2\", confirm = true, inline = \"p2\")\np2y = input.price(0, \"  \", confirm = true, inline = \"p2\")\np3x = input.time(0,  \"p3\", confirm = true, inline = \"p3\")\np3y = input.price(0, \"  \", confirm = true, inline = \"p3\")\np4x = input.time(0,  \"p4\", confirm = true, inline = \"p4\")\np4y = input.price(0, \"  \", confirm = true, inline = \"p4\")\np5x = input.time(0,  \"p5\", confirm = true, inline = \"p5\")\np5y = input.price(0, \"  \", confirm = true, inline = \"p5\")\n\nif barstate.islastconfirmedhistory\n\t//@variable An array of `chart.point` objects for the new polyline.\n\tvar points = array.new<chart.point>()\n\t// Push new `chart.point` instances into the `points` array.\n\tpoints.push(chart.point.from_time(p1x, p1y))\n\tpoints.push(chart.point.from_time(p2x, p2y))\n\tpoints.push(chart.point.from_time(p3x, p3y))\n\tpoints.push(chart.point.from_time(p4x, p4y))\n\tpoints.push(chart.point.from_time(p5x, p5y))\n\t// Add labels for each `chart.point` in `points`.\n\tl1p1 = label.new(points.get(0), text = \"p1\", xloc = xloc.bar_time, color = na)\n\tl1p2 = label.new(points.get(1), text = \"p2\", xloc = xloc.bar_time, color = na)\n\tl2p1 = label.new(points.get(2), text = \"p3\", xloc = xloc.bar_time, color = na)\n\tl2p2 = label.new(points.get(3), text = \"p4\", xloc = xloc.bar_time, color = na)\n\t// Create a new polyline that connects each `chart.point` in the `points` array, starting from the first.\n\tpolyline.new(points, curved = curvedInput, closed = closedInput, fill_color = fillcolor, xloc = xloc.bar_time)"
          ],
          "syntax": [
            "polyline.new(points, curved, closed, xloc, line_color, fill_color, line_style, line_width, force_overlay) → series polyline"
          ],
          "returnedTypes": [
            "series polyline"
          ]
        },
        {
          "name": "polyline.delete",
          "desc": [
            ""
          ],
          "args": [
            {
              "name": "id",
              "desc": "",
              "required": true,
              "allowedTypeIDs": [
                "series polyline"
              ],
              "displayType": "series polyline"
            }
          ],
          "syntax": [
            "polyline.delete(id) → void"
          ],
          "returnedTypes": [
            "void"
          ]
        }
      ]
    }
  ],
  "operators": [
    {
      "title": "Operators",
      "docs": [
        {
          "name": "?:",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 ? expr2 : expr3"
          ],
          "examples": [
            "//@version=6\nindicator(\"?:\")\n// Draw circles at the bars where open crosses close\ns2 = ta.cross(open, close) ? math.avg(open,close) : na\nplot(s2, style=plot.style_circles, linewidth=2, color=color.red)\n\n// Combination of ?: operators for 'switch'-like logic\nc = timeframe.isintraday ? color.red : timeframe.isdaily ? color.green : timeframe.isweekly ? color.blue : color.gray\nplot(hl2, color=c)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            "",
            ""
          ],
          "seeAlso": [
            "[na](#var_na)"
          ]
        },
        {
          "name": "+",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 + expr2"
          ],
          "returns": [
            "",
            "",
            "",
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "+",
          "desc": [
            ""
          ],
          "syntax": [
            "+ expr"
          ],
          "returns": [
            "",
            "",
            "",
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "-",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 - expr2"
          ],
          "returns": [
            "",
            "",
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "-",
          "desc": [
            ""
          ],
          "syntax": [
            "- expr"
          ],
          "returns": [
            "",
            "",
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "[]",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1[expr2]"
          ],
          "examples": [
            "//@version=6\nindicator(\"[]\")\n// [] can be used to \"save\" variable value between bars\na = 0.0 // declare `a`\na := a[1] // immediately set current value to the same as previous. `na` in the beginning of history\nif high == low // if some condition - change `a` value to another\n    a := low\nplot(a)"
          ],
          "returns": [
            ""
          ],
          "seeAlso": [
            "[math.floor()](#fun_math.floor)"
          ]
        },
        {
          "name": "=",
          "desc": [
            ""
          ],
          "syntax": [
            "<var_name> := <initial_value>"
          ],
          "examples": [
            "//@version=6\nindicator(\"`=` showcase\")\n// The following are all valid variable declarations.\ni = 1\nMS_IN_ONE_MINUTE = 1000 * 60\nshowPlotInput = input.bool(true, \"Show plots\")\npHi = ta.pivothigh(5, 5)\nplotColor = color.green\n\nplot(pHi, color = plotColor, display = showPlotInput ? display.all : display.none, precision = i)"
          ]
        },
        {
          "name": ":=",
          "desc": [
            ""
          ],
          "syntax": [
            "<var_name> := <new_value>"
          ],
          "examples": [
            "//@version=6\nindicator(\"My script\")\n\nmyVar = 10\n\nif close > open\n    // Modifies the existing global scope `myVar` variable by changing its value from 10 to 20.\n    myVar := 20\n    // Creates a new `myVar` variable local to the `if` condition and unreachable from the global scope.\n    // Does not affect the `myVar` declared in global scope.\n    myVar = 30\n\nplot(myVar)"
          ]
        },
        {
          "name": "==",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 == expr2"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "!=",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 != expr2"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": ">",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 > expr2"
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": "<",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 < expr2"
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": ">=",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 >= expr2"
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": "<=",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 <= expr2"
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": "*",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 * expr2"
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": "/",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 / expr2"
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": "%",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 % expr2"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            "",
            ""
          ]
        },
        {
          "name": "+=",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 += expr2"
          ],
          "examples": [
            "//@version=6\nindicator(\"+=\")\n// Equals to expr1 = expr1 + expr2.\na = 2\nb = 3\na += b\n// Result: a = 5.\nplot(a)"
          ],
          "returns": [
            ""
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "-=",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 -= expr2"
          ],
          "examples": [
            "//@version=6\nindicator(\"-=\")\n// Equals to expr1 = expr1 - expr2.\na = 2\nb = 3\na -= b\n// Result: a = -1.\nplot(a)"
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": "*=",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 *= expr2"
          ],
          "examples": [
            "//@version=6\nindicator(\"*=\")\n// Equals to expr1 = expr1 * expr2.\na = 2\nb = 3\na *= b\n// Result: a = 6.\nplot(a)"
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": "/=",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 /= expr2"
          ],
          "examples": [
            "//@version=6\nindicator(\"/=\")\n// Equals to expr1 = expr1 / expr2.\nfloat a = 3.0\nb = 3\na /= b\n// Result: a = 1.\nplot(a)"
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": "%=",
          "desc": [
            ""
          ],
          "syntax": [
            "expr1 %= expr2"
          ],
          "examples": [
            "//@version=6\nindicator(\"%=\")\n// Equals to expr1 = expr1 % expr2.\na = 3\nb = 3\na %= b\n// Result: a = 0.\nplot(a)"
          ],
          "returns": [
            ""
          ]
        },
        {
          "name": "=>",
          "desc": [
            "",
            ""
          ],
          "syntax": [
            "<identifier>([<parameter_name>[=<default_value>]], ...) =>\n    <local_block>\n    <function_result>"
          ],
          "detailedDesc": [
            {
              "desc": [
                "",
                ""
              ],
              "examples": [
                "//@version=6\nindicator(\"=>\")\n// single-line function\nf1(x, y) => x + y\n// multi-line function\nf2(x, y) =>\n\tsum = x + y\n\tsumChange = ta.change(sum, 10)\n\t// Function automatically returns the last expression used in it\nplot(f1(30, 8) + f2(1, 3))"
              ]
            }
          ],
          "remarks": [
            ""
          ]
        }
      ]
    }
  ],
  "annotations": [
    {
      "title": "Built-in @Annotation",
      "docs": [
        {
          "name": "@version=",
          "desc": [
            ""
          ],
          "detailedDesc": [
            {
              "desc": [],
              "examples": [
                "//@version=6\nindicator(\"Pine v6 Indicator\")\nplot(close)"
              ]
            },
            {
              "desc": [],
              "examples": [
                "//This indicator has no version annotation, so it will try to use v1.\n//Pine Script® v1 has no function named `indicator()`, so the script will not compile.\nindicator(\"Pine v1 Indicator\")\nplot(close)"
              ]
            }
          ],
          "remarks": [
            ""
          ]
        },
        {
          "name": "@description",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\n// @description Provides a tool to quickly output a label on the chart.\nlibrary(\"MyLibrary\")\n\n// @function Outputs a label with `labelText` on the bar's high.\n// @param labelText (series string) The text to display on the label.\n// @returns Drawn label.\nexport drawLabel(string labelText) =>\n\tlabel.new(bar_index, high, text = labelText)"
          ]
        },
        {
          "name": "@enum",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"Session highlight\", overlay = true)\n\n//@enum       Contains fields with popular timezones as titles.\n//@field exch Has an empty string as the title to represent the chart timezone.\nenum tz\n\tutc  = \"UTC\"\n\texch = \"\"\n\tny   = \"America/New_York\"\n\tchi  = \"America/Chicago\"\n\tlon  = \"Europe/London\"\n\ttok  = \"Asia/Tokyo\"\n\n//@variable The session string.\nselectedSession = input.session(\"1200-1500\", \"Session\")\n//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.\nselectedTimezone = input.enum(tz.utc, \"Session Timezone\")\n\n//@variable Is `true` if the current bar's time is in the specified session.\nbool inSession = false\nif not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))\n\tinSession := true\n\n// Highlight the background when `inSession` is `true`.\nbgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")"
          ]
        },
        {
          "name": "@function",
          "desc": [
            "",
            ""
          ],
          "examples": [
            "//@version=6\n// @description Provides a tool to quickly output a label on the chart.\nlibrary(\"MyLibrary\")\n\n// @function Outputs a label with `labelText` on the bar's high.\n// @param labelText (series string) The text to display on the label.\n// @returns Drawn label.\nexport drawLabel(string labelText) =>\n\tlabel.new(bar_index, high, text = labelText)"
          ]
        },
        {
          "name": "@param",
          "desc": [
            "",
            ""
          ],
          "examples": [
            "//@version=6\n// @description Provides a tool to quickly output a label on the chart.\nlibrary(\"MyLibrary\")\n\n// @function Outputs a label with `labelText` on the bar's high.\n// @param labelText (series string) The text to display on the label.\n// @returns Drawn label.\nexport drawLabel(string labelText) =>\n\tlabel.new(bar_index, high, text = labelText)"
          ]
        },
        {
          "name": "@returns",
          "desc": [
            "",
            ""
          ],
          "examples": [
            "//@version=6\n// @description Provides a tool to quickly output a label on the chart.\nlibrary(\"MyLibrary\")\n\n// @function Outputs a label with `labelText` on the bar's high.\n// @param labelText (series string) The text to display on the label.\n// @returns Drawn label.\nexport drawLabel(string labelText) =>\n\tlabel.new(bar_index, high, text = labelText)"
          ]
        },
        {
          "name": "@variable",
          "desc": [
            "",
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"New high over the last 20 bars\", overlay = true)\n\n//@type A point on a chart.\n//@field index The index of the bar where the point is located, i.e., its `x` coordinate.\n//@field price The price where the point is located, i.e., its `y` coordinate.\ntype Point\n    int index\n    float price\n\n//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.\nPoint highest = na\n\nif ta.highestbars(high, 20) == 0\n    highest := Point.new(bar_index, high)\n    label.new(highest.index, highest.price, str.tostring(highest.price))"
          ]
        },
        {
          "name": "@type",
          "desc": [
            "",
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"New high over the last 20 bars\", overlay = true)\n\n//@type A point on a chart.\n//@field index The index of the bar where the point is located, i.e., its `x` coordinate.\n//@field price The price where the point is located, i.e., its `y` coordinate.\ntype Point\n    int index\n    float price\n\n//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.\nPoint highest = na\n\nif ta.highestbars(high, 20) == 0\n    highest := Point.new(bar_index, high)\n    label.new(highest.index, highest.price, str.tostring(highest.price))"
          ]
        },
        {
          "name": "@field",
          "desc": [
            "",
            ""
          ],
          "examples": [
            "//@version=6\nindicator(\"New high over the last 20 bars\", overlay = true)\n\n//@type A point on a chart.\n//@field index The index of the bar where the point is located, i.e., its `x` coordinate.\n//@field price The price where the point is located, i.e., its `y` coordinate.\ntype Point\n    int index\n    float price\n\n//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.\nPoint highest = na\n\nif ta.highestbars(high, 20) == 0\n    highest := Point.new(bar_index, high)\n    label.new(highest.index, highest.price, str.tostring(highest.price))"
          ]
        },
        {
          "name": "@strategy_alert_message",
          "desc": [
            ""
          ],
          "examples": [
            "//@version=6\nstrategy(\"My strategy\", overlay=true, margin_long=100, margin_short=100)\n//@strategy_alert_message Strategy alert on symbol {{ticker}}\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n    strategy.entry(\"My Long Entry Id\", strategy.long)\nstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = 10 / syminfo.mintick, loss = 10 / syminfo.mintick)"
          ]
        }
      ]
    }
  ],
  "fields": [
    {
      "title": "Fields",
      "docs": []
    }
  ]
}